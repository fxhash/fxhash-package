schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
columns and relationships of "Account"
"""
type Account {
  """An array relationship"""
  authoredProjects(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """An array relationship"""
  curatedProjects(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!
  id: uuid!

  """An array relationship"""
  profile(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [AccountRole_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [AccountRole_order_by!]

    """filter the rows returned"""
    where: AccountRole_bool_exp
  ): [AccountRole!]!
  status: AccountStatus!
  username: String!

  """An array relationship"""
  wallets(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!
}

"""
columns and relationships of "AccountRole"
"""
type AccountRole {
  accountId: uuid!
  id: Int!
  role: AccountRoles!
}

"""
order by aggregate values of table "AccountRole"
"""
input AccountRole_aggregate_order_by {
  avg: AccountRole_avg_order_by
  count: order_by
  max: AccountRole_max_order_by
  min: AccountRole_min_order_by
  stddev: AccountRole_stddev_order_by
  stddev_pop: AccountRole_stddev_pop_order_by
  stddev_samp: AccountRole_stddev_samp_order_by
  sum: AccountRole_sum_order_by
  var_pop: AccountRole_var_pop_order_by
  var_samp: AccountRole_var_samp_order_by
  variance: AccountRole_variance_order_by
}

"""
order by avg() on columns of table "AccountRole"
"""
input AccountRole_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "AccountRole". All fields are combined with a logical 'AND'.
"""
input AccountRole_bool_exp {
  _and: [AccountRole_bool_exp!]
  _not: AccountRole_bool_exp
  _or: [AccountRole_bool_exp!]
  accountId: uuid_comparison_exp
  id: Int_comparison_exp
  role: AccountRoles_comparison_exp
}

"""
order by max() on columns of table "AccountRole"
"""
input AccountRole_max_order_by {
  accountId: order_by
  id: order_by
  role: order_by
}

"""
order by min() on columns of table "AccountRole"
"""
input AccountRole_min_order_by {
  accountId: order_by
  id: order_by
  role: order_by
}

"""Ordering options when selecting data from "AccountRole"."""
input AccountRole_order_by {
  accountId: order_by
  id: order_by
  role: order_by
}

"""
select columns of table "AccountRole"
"""
enum AccountRole_select_column {
  """column name"""
  accountId

  """column name"""
  id

  """column name"""
  role
}

"""
order by stddev() on columns of table "AccountRole"
"""
input AccountRole_stddev_order_by {
  id: order_by
}

"""
order by stddev_pop() on columns of table "AccountRole"
"""
input AccountRole_stddev_pop_order_by {
  id: order_by
}

"""
order by stddev_samp() on columns of table "AccountRole"
"""
input AccountRole_stddev_samp_order_by {
  id: order_by
}

"""
Streaming cursor of the table "AccountRole"
"""
input AccountRole_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: AccountRole_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input AccountRole_stream_cursor_value_input {
  accountId: uuid
  id: Int
  role: AccountRoles
}

"""
order by sum() on columns of table "AccountRole"
"""
input AccountRole_sum_order_by {
  id: order_by
}

"""
order by var_pop() on columns of table "AccountRole"
"""
input AccountRole_var_pop_order_by {
  id: order_by
}

"""
order by var_samp() on columns of table "AccountRole"
"""
input AccountRole_var_samp_order_by {
  id: order_by
}

"""
order by variance() on columns of table "AccountRole"
"""
input AccountRole_variance_order_by {
  id: order_by
}

scalar AccountRoles

"""
Boolean expression to compare columns of type "AccountRoles". All fields are combined with logical 'AND'.
"""
input AccountRoles_comparison_exp {
  _eq: AccountRoles
  _gt: AccountRoles
  _gte: AccountRoles
  _in: [AccountRoles!]
  _is_null: Boolean
  _lt: AccountRoles
  _lte: AccountRoles
  _neq: AccountRoles
  _nin: [AccountRoles!]
}

scalar AccountStatus

"""
Boolean expression to compare columns of type "AccountStatus". All fields are combined with logical 'AND'.
"""
input AccountStatus_comparison_exp {
  _eq: AccountStatus
  _gt: AccountStatus
  _gte: AccountStatus
  _in: [AccountStatus!]
  _is_null: Boolean
  _lt: AccountStatus
  _lte: AccountStatus
  _neq: AccountStatus
  _nin: [AccountStatus!]
}

"""
Boolean expression to filter rows from the table "Account". All fields are combined with a logical 'AND'.
"""
input Account_bool_exp {
  _and: [Account_bool_exp!]
  _not: Account_bool_exp
  _or: [Account_bool_exp!]
  authoredProjects: Project_bool_exp
  curatedProjects: Project_bool_exp
  id: uuid_comparison_exp
  profile: Profile_bool_exp
  roles: AccountRole_bool_exp
  status: AccountStatus_comparison_exp
  username: String_comparison_exp
  wallets: Wallet_bool_exp
}

"""
response of any mutation on the table "Account"
"""
type Account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Account!]!
}

"""Ordering options when selecting data from "Account"."""
input Account_order_by {
  authoredProjects_aggregate: Project_aggregate_order_by
  curatedProjects_aggregate: Project_aggregate_order_by
  id: order_by
  profile_aggregate: Profile_aggregate_order_by
  roles_aggregate: AccountRole_aggregate_order_by
  status: order_by
  username: order_by
  wallets_aggregate: Wallet_aggregate_order_by
}

"""primary key columns input for table: Account"""
input Account_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Account"
"""
enum Account_select_column {
  """column name"""
  id

  """column name"""
  status

  """column name"""
  username
}

"""
input type for updating data in table "Account"
"""
input Account_set_input {
  username: String
}

"""
Streaming cursor of the table "Account"
"""
input Account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Account_stream_cursor_value_input {
  id: uuid
  status: AccountStatus
  username: String
}

input Account_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Account_set_input

  """filter the rows which have to be updated"""
  where: Account_bool_exp!
}

scalar BlockchainNetwork

"""
Boolean expression to compare columns of type "BlockchainNetwork". All fields are combined with logical 'AND'.
"""
input BlockchainNetwork_comparison_exp {
  _eq: BlockchainNetwork
  _gt: BlockchainNetwork
  _gte: BlockchainNetwork
  _in: [BlockchainNetwork!]
  _is_null: Boolean
  _lt: BlockchainNetwork
  _lte: BlockchainNetwork
  _neq: BlockchainNetwork
  _nin: [BlockchainNetwork!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "Media"
"""
type Media {
  createdAt: timestamp!
  etag: String!
  id: uuid!
  name: String!

  """An array relationship"""
  project(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!
  size: Int!
  updatedAt: timestamp!

  """An object relationship"""
  uploader: Account
  uploaderId: uuid
}

"""
Boolean expression to filter rows from the table "Media". All fields are combined with a logical 'AND'.
"""
input Media_bool_exp {
  _and: [Media_bool_exp!]
  _not: Media_bool_exp
  _or: [Media_bool_exp!]
  createdAt: timestamp_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  project: ProjectMedia_bool_exp
  size: Int_comparison_exp
  updatedAt: timestamp_comparison_exp
  uploader: Account_bool_exp
  uploaderId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "Media"
"""
enum Media_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Media_pkey
}

"""
input type for inserting data into table "Media"
"""
input Media_insert_input {
  bucketId: String
  etag: String
  name: String
  project: ProjectMedia_arr_rel_insert_input
  s3key: String
  size: Int
}

"""
response of any mutation on the table "Media"
"""
type Media_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Media!]!
}

"""
input type for inserting object relation for remote table "Media"
"""
input Media_obj_rel_insert_input {
  data: Media_insert_input!

  """upsert condition"""
  on_conflict: Media_on_conflict
}

"""
on_conflict condition type for table "Media"
"""
input Media_on_conflict {
  constraint: Media_constraint!
  update_columns: [Media_update_column!]! = []
  where: Media_bool_exp
}

"""Ordering options when selecting data from "Media"."""
input Media_order_by {
  createdAt: order_by
  etag: order_by
  id: order_by
  name: order_by
  project_aggregate: ProjectMedia_aggregate_order_by
  size: order_by
  updatedAt: order_by
  uploader: Account_order_by
  uploaderId: order_by
}

"""
select columns of table "Media"
"""
enum Media_select_column {
  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploaderId
}

"""
Streaming cursor of the table "Media"
"""
input Media_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Media_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Media_stream_cursor_value_input {
  createdAt: timestamp
  etag: String
  id: uuid
  name: String
  size: Int
  updatedAt: timestamp
  uploaderId: uuid
}

"""
placeholder for update columns of table "Media" (current role has no relevant permissions)
"""
enum Media_update_column {
  """placeholder (do not use)"""
  _PLACEHOLDER
}

"""
columns and relationships of "Profile"
"""
type Profile {
  accountId: uuid!
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
order by aggregate values of table "Profile"
"""
input Profile_aggregate_order_by {
  count: order_by
  max: Profile_max_order_by
  min: Profile_min_order_by
}

"""
Boolean expression to filter rows from the table "Profile". All fields are combined with a logical 'AND'.
"""
input Profile_bool_exp {
  _and: [Profile_bool_exp!]
  _not: Profile_bool_exp
  _or: [Profile_bool_exp!]
  accountId: uuid_comparison_exp
  description: String_comparison_exp
  instagram: String_comparison_exp
  picture: String_comparison_exp
  twitter: String_comparison_exp
  website: String_comparison_exp
}

"""
order by max() on columns of table "Profile"
"""
input Profile_max_order_by {
  accountId: order_by
  description: order_by
  instagram: order_by
  picture: order_by
  twitter: order_by
  website: order_by
}

"""
order by min() on columns of table "Profile"
"""
input Profile_min_order_by {
  accountId: order_by
  description: order_by
  instagram: order_by
  picture: order_by
  twitter: order_by
  website: order_by
}

"""
response of any mutation on the table "Profile"
"""
type Profile_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Profile!]!
}

"""Ordering options when selecting data from "Profile"."""
input Profile_order_by {
  accountId: order_by
  description: order_by
  instagram: order_by
  picture: order_by
  twitter: order_by
  website: order_by
}

"""primary key columns input for table: Profile"""
input Profile_pk_columns_input {
  accountId: uuid!
}

"""
select columns of table "Profile"
"""
enum Profile_select_column {
  """column name"""
  accountId

  """column name"""
  description

  """column name"""
  instagram

  """column name"""
  picture

  """column name"""
  twitter

  """column name"""
  website
}

"""
input type for updating data in table "Profile"
"""
input Profile_set_input {
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
Streaming cursor of the table "Profile"
"""
input Profile_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Profile_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Profile_stream_cursor_value_input {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

input Profile_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Profile_set_input

  """filter the rows which have to be updated"""
  where: Profile_bool_exp!
}

"""
columns and relationships of "Project"
"""
type Project {
  """An object relationship"""
  author: Account!
  authorId: uuid!
  blockchain: BlockchainNetwork

  """An object relationship"""
  curator: Account
  curatorId: uuid
  description: String
  id: uuid!
  pricing(
    """JSON select path"""
    path: String
  ): jsonb

  """An array relationship"""
  projectMedias(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!
  releaseAt: timestamp
  state: ProjectState!
  storage: Storage
  title: String!
}

"""
columns and relationships of "ProjectMedia"
"""
type ProjectMedia {
  index: smallint!

  """An object relationship"""
  media: Media!
  mediaId: uuid!

  """An object relationship"""
  project: Project!
  projectId: uuid!
}

"""
order by aggregate values of table "ProjectMedia"
"""
input ProjectMedia_aggregate_order_by {
  avg: ProjectMedia_avg_order_by
  count: order_by
  max: ProjectMedia_max_order_by
  min: ProjectMedia_min_order_by
  stddev: ProjectMedia_stddev_order_by
  stddev_pop: ProjectMedia_stddev_pop_order_by
  stddev_samp: ProjectMedia_stddev_samp_order_by
  sum: ProjectMedia_sum_order_by
  var_pop: ProjectMedia_var_pop_order_by
  var_samp: ProjectMedia_var_samp_order_by
  variance: ProjectMedia_variance_order_by
}

"""
input type for inserting array relation for remote table "ProjectMedia"
"""
input ProjectMedia_arr_rel_insert_input {
  data: [ProjectMedia_insert_input!]!

  """upsert condition"""
  on_conflict: ProjectMedia_on_conflict
}

"""
order by avg() on columns of table "ProjectMedia"
"""
input ProjectMedia_avg_order_by {
  index: order_by
}

"""
Boolean expression to filter rows from the table "ProjectMedia". All fields are combined with a logical 'AND'.
"""
input ProjectMedia_bool_exp {
  _and: [ProjectMedia_bool_exp!]
  _not: ProjectMedia_bool_exp
  _or: [ProjectMedia_bool_exp!]
  index: smallint_comparison_exp
  media: Media_bool_exp
  mediaId: uuid_comparison_exp
  project: Project_bool_exp
  projectId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "ProjectMedia"
"""
enum ProjectMedia_constraint {
  """
  unique or primary key constraint on columns "index", "mediaId", "projectId"
  """
  ProjectMedia_index_projectId_mediaId_key
}

"""
input type for incrementing numeric columns in table "ProjectMedia"
"""
input ProjectMedia_inc_input {
  index: smallint
}

"""
input type for inserting data into table "ProjectMedia"
"""
input ProjectMedia_insert_input {
  index: smallint
  media: Media_obj_rel_insert_input
  mediaId: uuid
  project: Project_obj_rel_insert_input
  projectId: uuid
}

"""
order by max() on columns of table "ProjectMedia"
"""
input ProjectMedia_max_order_by {
  index: order_by
  mediaId: order_by
  projectId: order_by
}

"""
order by min() on columns of table "ProjectMedia"
"""
input ProjectMedia_min_order_by {
  index: order_by
  mediaId: order_by
  projectId: order_by
}

"""
response of any mutation on the table "ProjectMedia"
"""
type ProjectMedia_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ProjectMedia!]!
}

"""
on_conflict condition type for table "ProjectMedia"
"""
input ProjectMedia_on_conflict {
  constraint: ProjectMedia_constraint!
  update_columns: [ProjectMedia_update_column!]! = []
  where: ProjectMedia_bool_exp
}

"""Ordering options when selecting data from "ProjectMedia"."""
input ProjectMedia_order_by {
  index: order_by
  media: Media_order_by
  mediaId: order_by
  project: Project_order_by
  projectId: order_by
}

"""
select columns of table "ProjectMedia"
"""
enum ProjectMedia_select_column {
  """column name"""
  index

  """column name"""
  mediaId

  """column name"""
  projectId
}

"""
input type for updating data in table "ProjectMedia"
"""
input ProjectMedia_set_input {
  index: smallint
  mediaId: uuid
  projectId: uuid
}

"""
order by stddev() on columns of table "ProjectMedia"
"""
input ProjectMedia_stddev_order_by {
  index: order_by
}

"""
order by stddev_pop() on columns of table "ProjectMedia"
"""
input ProjectMedia_stddev_pop_order_by {
  index: order_by
}

"""
order by stddev_samp() on columns of table "ProjectMedia"
"""
input ProjectMedia_stddev_samp_order_by {
  index: order_by
}

"""
Streaming cursor of the table "ProjectMedia"
"""
input ProjectMedia_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ProjectMedia_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ProjectMedia_stream_cursor_value_input {
  index: smallint
  mediaId: uuid
  projectId: uuid
}

"""
order by sum() on columns of table "ProjectMedia"
"""
input ProjectMedia_sum_order_by {
  index: order_by
}

"""
update columns of table "ProjectMedia"
"""
enum ProjectMedia_update_column {
  """column name"""
  index

  """column name"""
  mediaId

  """column name"""
  projectId
}

input ProjectMedia_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: ProjectMedia_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: ProjectMedia_set_input

  """filter the rows which have to be updated"""
  where: ProjectMedia_bool_exp!
}

"""
order by var_pop() on columns of table "ProjectMedia"
"""
input ProjectMedia_var_pop_order_by {
  index: order_by
}

"""
order by var_samp() on columns of table "ProjectMedia"
"""
input ProjectMedia_var_samp_order_by {
  index: order_by
}

"""
order by variance() on columns of table "ProjectMedia"
"""
input ProjectMedia_variance_order_by {
  index: order_by
}

scalar ProjectState

"""
Boolean expression to compare columns of type "ProjectState". All fields are combined with logical 'AND'.
"""
input ProjectState_comparison_exp {
  _eq: ProjectState
  _gt: ProjectState
  _gte: ProjectState
  _in: [ProjectState!]
  _is_null: Boolean
  _lt: ProjectState
  _lte: ProjectState
  _neq: ProjectState
  _nin: [ProjectState!]
}

"""
order by aggregate values of table "Project"
"""
input Project_aggregate_order_by {
  count: order_by
  max: Project_max_order_by
  min: Project_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input Project_append_input {
  pricing: jsonb
}

"""
Boolean expression to filter rows from the table "Project". All fields are combined with a logical 'AND'.
"""
input Project_bool_exp {
  _and: [Project_bool_exp!]
  _not: Project_bool_exp
  _or: [Project_bool_exp!]
  author: Account_bool_exp
  authorId: uuid_comparison_exp
  blockchain: BlockchainNetwork_comparison_exp
  curator: Account_bool_exp
  curatorId: uuid_comparison_exp
  description: String_comparison_exp
  id: uuid_comparison_exp
  pricing: jsonb_comparison_exp
  projectMedias: ProjectMedia_bool_exp
  releaseAt: timestamp_comparison_exp
  state: ProjectState_comparison_exp
  storage: Storage_comparison_exp
  title: String_comparison_exp
}

"""
unique or primary key constraints on table "Project"
"""
enum Project_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Project_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input Project_delete_at_path_input {
  pricing: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input Project_delete_elem_input {
  pricing: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input Project_delete_key_input {
  pricing: String
}

"""
input type for inserting data into table "Project"
"""
input Project_insert_input {
  blockchain: BlockchainNetwork
  curatorId: uuid
  description: String
  pricing: jsonb
  projectMedias: ProjectMedia_arr_rel_insert_input
  releaseAt: timestamp
  storage: Storage
  title: String
}

"""
order by max() on columns of table "Project"
"""
input Project_max_order_by {
  authorId: order_by
  blockchain: order_by
  curatorId: order_by
  description: order_by
  id: order_by
  releaseAt: order_by
  state: order_by
  storage: order_by
  title: order_by
}

"""
order by min() on columns of table "Project"
"""
input Project_min_order_by {
  authorId: order_by
  blockchain: order_by
  curatorId: order_by
  description: order_by
  id: order_by
  releaseAt: order_by
  state: order_by
  storage: order_by
  title: order_by
}

"""
response of any mutation on the table "Project"
"""
type Project_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Project!]!
}

"""
input type for inserting object relation for remote table "Project"
"""
input Project_obj_rel_insert_input {
  data: Project_insert_input!

  """upsert condition"""
  on_conflict: Project_on_conflict
}

"""
on_conflict condition type for table "Project"
"""
input Project_on_conflict {
  constraint: Project_constraint!
  update_columns: [Project_update_column!]! = []
  where: Project_bool_exp
}

"""Ordering options when selecting data from "Project"."""
input Project_order_by {
  author: Account_order_by
  authorId: order_by
  blockchain: order_by
  curator: Account_order_by
  curatorId: order_by
  description: order_by
  id: order_by
  pricing: order_by
  projectMedias_aggregate: ProjectMedia_aggregate_order_by
  releaseAt: order_by
  state: order_by
  storage: order_by
  title: order_by
}

"""primary key columns input for table: Project"""
input Project_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input Project_prepend_input {
  pricing: jsonb
}

"""
select columns of table "Project"
"""
enum Project_select_column {
  """column name"""
  authorId

  """column name"""
  blockchain

  """column name"""
  curatorId

  """column name"""
  description

  """column name"""
  id

  """column name"""
  pricing

  """column name"""
  releaseAt

  """column name"""
  state

  """column name"""
  storage

  """column name"""
  title
}

"""
input type for updating data in table "Project"
"""
input Project_set_input {
  blockchain: BlockchainNetwork
  curatorId: uuid
  description: String
  pricing: jsonb
  releaseAt: timestamp
  storage: Storage
  title: String
}

"""
Streaming cursor of the table "Project"
"""
input Project_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Project_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Project_stream_cursor_value_input {
  authorId: uuid
  blockchain: BlockchainNetwork
  curatorId: uuid
  description: String
  id: uuid
  pricing: jsonb
  releaseAt: timestamp
  state: ProjectState
  storage: Storage
  title: String
}

"""
update columns of table "Project"
"""
enum Project_update_column {
  """column name"""
  blockchain

  """column name"""
  curatorId

  """column name"""
  description

  """column name"""
  pricing

  """column name"""
  releaseAt

  """column name"""
  storage

  """column name"""
  title
}

input Project_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: Project_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: Project_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: Project_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: Project_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: Project_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: Project_set_input

  """filter the rows which have to be updated"""
  where: Project_bool_exp!
}

scalar Storage

"""
Boolean expression to compare columns of type "Storage". All fields are combined with logical 'AND'.
"""
input Storage_comparison_exp {
  _eq: Storage
  _gt: Storage
  _gte: Storage
  _in: [Storage!]
  _is_null: Boolean
  _lt: Storage
  _lte: Storage
  _neq: Storage
  _nin: [Storage!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "Wallet"
"""
type Wallet {
  accountId: uuid!
  address: String!
  network: BlockchainNetwork!
}

"""
order by aggregate values of table "Wallet"
"""
input Wallet_aggregate_order_by {
  count: order_by
  max: Wallet_max_order_by
  min: Wallet_min_order_by
}

"""
Boolean expression to filter rows from the table "Wallet". All fields are combined with a logical 'AND'.
"""
input Wallet_bool_exp {
  _and: [Wallet_bool_exp!]
  _not: Wallet_bool_exp
  _or: [Wallet_bool_exp!]
  accountId: uuid_comparison_exp
  address: String_comparison_exp
  network: BlockchainNetwork_comparison_exp
}

"""
order by max() on columns of table "Wallet"
"""
input Wallet_max_order_by {
  accountId: order_by
  address: order_by
  network: order_by
}

"""
order by min() on columns of table "Wallet"
"""
input Wallet_min_order_by {
  accountId: order_by
  address: order_by
  network: order_by
}

"""Ordering options when selecting data from "Wallet"."""
input Wallet_order_by {
  accountId: order_by
  address: order_by
  network: order_by
}

"""
select columns of table "Wallet"
"""
enum Wallet_select_column {
  """column name"""
  accountId

  """column name"""
  address

  """column name"""
  network
}

"""
Streaming cursor of the table "Wallet"
"""
input Wallet_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Wallet_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Wallet_stream_cursor_value_input {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "ProjectMedia"
  """
  delete_ProjectMedia(
    """filter the rows which have to be deleted"""
    where: ProjectMedia_bool_exp!
  ): ProjectMedia_mutation_response

  """
  insert data into the table: "Media"
  """
  insert_Media(
    """the rows to be inserted"""
    objects: [Media_insert_input!]!

    """upsert condition"""
    on_conflict: Media_on_conflict
  ): Media_mutation_response

  """
  insert a single row into the table: "Media"
  """
  insert_Media_one(
    """the row to be inserted"""
    object: Media_insert_input!

    """upsert condition"""
    on_conflict: Media_on_conflict
  ): Media

  """
  insert data into the table: "Project"
  """
  insert_Project(
    """the rows to be inserted"""
    objects: [Project_insert_input!]!

    """upsert condition"""
    on_conflict: Project_on_conflict
  ): Project_mutation_response

  """
  insert data into the table: "ProjectMedia"
  """
  insert_ProjectMedia(
    """the rows to be inserted"""
    objects: [ProjectMedia_insert_input!]!

    """upsert condition"""
    on_conflict: ProjectMedia_on_conflict
  ): ProjectMedia_mutation_response

  """
  insert a single row into the table: "ProjectMedia"
  """
  insert_ProjectMedia_one(
    """the row to be inserted"""
    object: ProjectMedia_insert_input!

    """upsert condition"""
    on_conflict: ProjectMedia_on_conflict
  ): ProjectMedia

  """
  insert a single row into the table: "Project"
  """
  insert_Project_one(
    """the row to be inserted"""
    object: Project_insert_input!

    """upsert condition"""
    on_conflict: Project_on_conflict
  ): Project

  """
  update data of the table: "Account"
  """
  update_Account(
    """sets the columns of the filtered rows to the given values"""
    _set: Account_set_input

    """filter the rows which have to be updated"""
    where: Account_bool_exp!
  ): Account_mutation_response

  """
  update single row of the table: "Account"
  """
  update_Account_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Account_set_input
    pk_columns: Account_pk_columns_input!
  ): Account

  """
  update multiples rows of table: "Account"
  """
  update_Account_many(
    """updates to execute, in order"""
    updates: [Account_updates!]!
  ): [Account_mutation_response]

  """
  update data of the table: "Profile"
  """
  update_Profile(
    """sets the columns of the filtered rows to the given values"""
    _set: Profile_set_input

    """filter the rows which have to be updated"""
    where: Profile_bool_exp!
  ): Profile_mutation_response

  """
  update single row of the table: "Profile"
  """
  update_Profile_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Profile_set_input
    pk_columns: Profile_pk_columns_input!
  ): Profile

  """
  update multiples rows of table: "Profile"
  """
  update_Profile_many(
    """updates to execute, in order"""
    updates: [Profile_updates!]!
  ): [Profile_mutation_response]

  """
  update data of the table: "Project"
  """
  update_Project(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Project_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Project_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: Project_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Project_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Project_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Project_set_input

    """filter the rows which have to be updated"""
    where: Project_bool_exp!
  ): Project_mutation_response

  """
  update data of the table: "ProjectMedia"
  """
  update_ProjectMedia(
    """increments the numeric columns with given value of the filtered values"""
    _inc: ProjectMedia_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: ProjectMedia_set_input

    """filter the rows which have to be updated"""
    where: ProjectMedia_bool_exp!
  ): ProjectMedia_mutation_response

  """
  update multiples rows of table: "ProjectMedia"
  """
  update_ProjectMedia_many(
    """updates to execute, in order"""
    updates: [ProjectMedia_updates!]!
  ): [ProjectMedia_mutation_response]

  """
  update single row of the table: "Project"
  """
  update_Project_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: Project_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: Project_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: Project_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: Project_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: Project_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: Project_set_input
    pk_columns: Project_pk_columns_input!
  ): Project

  """
  update multiples rows of table: "Project"
  """
  update_Project_many(
    """updates to execute, in order"""
    updates: [Project_updates!]!
  ): [Project_mutation_response]
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "Account"
  """
  Account(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch data from the table: "AccountRole"
  """
  AccountRole(
    """distinct select on columns"""
    distinct_on: [AccountRole_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [AccountRole_order_by!]

    """filter the rows returned"""
    where: AccountRole_bool_exp
  ): [AccountRole!]!

  """fetch data from the table: "AccountRole" using primary key columns"""
  AccountRole_by_pk(id: Int!): AccountRole

  """fetch data from the table: "Account" using primary key columns"""
  Account_by_pk(id: uuid!): Account

  """
  fetch data from the table: "Media"
  """
  Media(
    """distinct select on columns"""
    distinct_on: [Media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Media_order_by!]

    """filter the rows returned"""
    where: Media_bool_exp
  ): [Media!]!

  """fetch data from the table: "Media" using primary key columns"""
  Media_by_pk(id: uuid!): Media

  """
  fetch data from the table: "Profile"
  """
  Profile(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """fetch data from the table: "Profile" using primary key columns"""
  Profile_by_pk(accountId: uuid!): Profile

  """
  fetch data from the table: "Project"
  """
  Project(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """
  fetch data from the table: "ProjectMedia"
  """
  ProjectMedia(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!

  """fetch data from the table: "Project" using primary key columns"""
  Project_by_pk(id: uuid!): Project

  """
  fetch data from the table: "Wallet"
  """
  Wallet(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """fetch data from the table: "Wallet" using primary key columns"""
  Wallet_by_pk(address: String!): Wallet
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

type subscription_root {
  """
  fetch data from the table: "Account"
  """
  Account(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch data from the table: "AccountRole"
  """
  AccountRole(
    """distinct select on columns"""
    distinct_on: [AccountRole_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [AccountRole_order_by!]

    """filter the rows returned"""
    where: AccountRole_bool_exp
  ): [AccountRole!]!

  """fetch data from the table: "AccountRole" using primary key columns"""
  AccountRole_by_pk(id: Int!): AccountRole

  """
  fetch data from the table in a streaming manner: "AccountRole"
  """
  AccountRole_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [AccountRole_stream_cursor_input]!

    """filter the rows returned"""
    where: AccountRole_bool_exp
  ): [AccountRole!]!

  """fetch data from the table: "Account" using primary key columns"""
  Account_by_pk(id: uuid!): Account

  """
  fetch data from the table in a streaming manner: "Account"
  """
  Account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Account_stream_cursor_input]!

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch data from the table: "Media"
  """
  Media(
    """distinct select on columns"""
    distinct_on: [Media_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Media_order_by!]

    """filter the rows returned"""
    where: Media_bool_exp
  ): [Media!]!

  """fetch data from the table: "Media" using primary key columns"""
  Media_by_pk(id: uuid!): Media

  """
  fetch data from the table in a streaming manner: "Media"
  """
  Media_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Media_stream_cursor_input]!

    """filter the rows returned"""
    where: Media_bool_exp
  ): [Media!]!

  """
  fetch data from the table: "Profile"
  """
  Profile(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """fetch data from the table: "Profile" using primary key columns"""
  Profile_by_pk(accountId: uuid!): Profile

  """
  fetch data from the table in a streaming manner: "Profile"
  """
  Profile_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Profile_stream_cursor_input]!

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """
  fetch data from the table: "Project"
  """
  Project(
    """distinct select on columns"""
    distinct_on: [Project_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Project_order_by!]

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """
  fetch data from the table: "ProjectMedia"
  """
  ProjectMedia(
    """distinct select on columns"""
    distinct_on: [ProjectMedia_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ProjectMedia_order_by!]

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!

  """
  fetch data from the table in a streaming manner: "ProjectMedia"
  """
  ProjectMedia_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ProjectMedia_stream_cursor_input]!

    """filter the rows returned"""
    where: ProjectMedia_bool_exp
  ): [ProjectMedia!]!

  """fetch data from the table: "Project" using primary key columns"""
  Project_by_pk(id: uuid!): Project

  """
  fetch data from the table in a streaming manner: "Project"
  """
  Project_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Project_stream_cursor_input]!

    """filter the rows returned"""
    where: Project_bool_exp
  ): [Project!]!

  """
  fetch data from the table: "Wallet"
  """
  Wallet(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """fetch data from the table: "Wallet" using primary key columns"""
  Wallet_by_pk(address: String!): Wallet

  """
  fetch data from the table in a streaming manner: "Wallet"
  """
  Wallet_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Wallet_stream_cursor_input]!

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """refresh the cache entry"""
  refresh: Boolean! = false

  """measured in seconds"""
  ttl: Int! = 60
) on QUERY

"""
columns and relationships of "Account"
"""
type Account {
  """An object relationship"""
  Profile: Profile

  """An array relationship"""
  Wallets(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """An aggregate relationship"""
  Wallets_aggregate(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): Wallet_aggregate!
  id: uuid!
  status: AccountStatus!
  username: String!
}

scalar AccountStatus

"""
Boolean expression to compare columns of type "AccountStatus". All fields are combined with logical 'AND'.
"""
input AccountStatus_comparison_exp {
  _eq: AccountStatus
  _gt: AccountStatus
  _gte: AccountStatus
  _in: [AccountStatus!]
  _is_null: Boolean
  _lt: AccountStatus
  _lte: AccountStatus
  _neq: AccountStatus
  _nin: [AccountStatus!]
}

"""
aggregated selection of "Account"
"""
type Account_aggregate {
  aggregate: Account_aggregate_fields
  nodes: [Account!]!
}

"""
aggregate fields of "Account"
"""
type Account_aggregate_fields {
  count(columns: [Account_select_column!], distinct: Boolean): Int!
  max: Account_max_fields
  min: Account_min_fields
}

"""
Boolean expression to filter rows from the table "Account". All fields are combined with a logical 'AND'.
"""
input Account_bool_exp {
  Profile: Profile_bool_exp
  Wallets: Wallet_bool_exp
  Wallets_aggregate: Wallet_aggregate_bool_exp
  _and: [Account_bool_exp!]
  _not: Account_bool_exp
  _or: [Account_bool_exp!]
  id: uuid_comparison_exp
  status: AccountStatus_comparison_exp
  username: String_comparison_exp
}

"""
unique or primary key constraints on table "Account"
"""
enum Account_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  Account_pkey

  """
  unique or primary key constraint on columns "username"
  """
  Account_username_key
}

"""
input type for inserting data into table "Account"
"""
input Account_insert_input {
  Profile: Profile_obj_rel_insert_input
  Wallets: Wallet_arr_rel_insert_input
  id: uuid
  status: AccountStatus
  username: String
}

"""aggregate max on columns"""
type Account_max_fields {
  id: uuid
  status: AccountStatus
  username: String
}

"""aggregate min on columns"""
type Account_min_fields {
  id: uuid
  status: AccountStatus
  username: String
}

"""
response of any mutation on the table "Account"
"""
type Account_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Account!]!
}

"""
input type for inserting object relation for remote table "Account"
"""
input Account_obj_rel_insert_input {
  data: Account_insert_input!

  """upsert condition"""
  on_conflict: Account_on_conflict
}

"""
on_conflict condition type for table "Account"
"""
input Account_on_conflict {
  constraint: Account_constraint!
  update_columns: [Account_update_column!]! = []
  where: Account_bool_exp
}

"""Ordering options when selecting data from "Account"."""
input Account_order_by {
  Profile: Profile_order_by
  Wallets_aggregate: Wallet_aggregate_order_by
  id: order_by
  status: order_by
  username: order_by
}

"""primary key columns input for table: Account"""
input Account_pk_columns_input {
  id: uuid!
}

"""
select columns of table "Account"
"""
enum Account_select_column {
  """column name"""
  id

  """column name"""
  status

  """column name"""
  username
}

"""
input type for updating data in table "Account"
"""
input Account_set_input {
  id: uuid
  status: AccountStatus
  username: String
}

"""
Streaming cursor of the table "Account"
"""
input Account_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Account_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Account_stream_cursor_value_input {
  id: uuid
  status: AccountStatus
  username: String
}

"""
update columns of table "Account"
"""
enum Account_update_column {
  """column name"""
  id

  """column name"""
  status

  """column name"""
  username
}

input Account_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Account_set_input

  """filter the rows which have to be updated"""
  where: Account_bool_exp!
}

scalar BlockchainNetwork

"""
Boolean expression to compare columns of type "BlockchainNetwork". All fields are combined with logical 'AND'.
"""
input BlockchainNetwork_comparison_exp {
  _eq: BlockchainNetwork
  _gt: BlockchainNetwork
  _gte: BlockchainNetwork
  _in: [BlockchainNetwork!]
  _is_null: Boolean
  _lt: BlockchainNetwork
  _lte: BlockchainNetwork
  _neq: BlockchainNetwork
  _nin: [BlockchainNetwork!]
}

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'.
"""
input Float_comparison_exp {
  _eq: Float
  _gt: Float
  _gte: Float
  _in: [Float!]
  _is_null: Boolean
  _lt: Float
  _lte: Float
  _neq: Float
  _nin: [Float!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
columns and relationships of "Profile"
"""
type Profile {
  """An object relationship"""
  Account: Account!
  accountId: uuid!
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
aggregated selection of "Profile"
"""
type Profile_aggregate {
  aggregate: Profile_aggregate_fields
  nodes: [Profile!]!
}

"""
aggregate fields of "Profile"
"""
type Profile_aggregate_fields {
  count(columns: [Profile_select_column!], distinct: Boolean): Int!
  max: Profile_max_fields
  min: Profile_min_fields
}

"""
Boolean expression to filter rows from the table "Profile". All fields are combined with a logical 'AND'.
"""
input Profile_bool_exp {
  Account: Account_bool_exp
  _and: [Profile_bool_exp!]
  _not: Profile_bool_exp
  _or: [Profile_bool_exp!]
  accountId: uuid_comparison_exp
  description: String_comparison_exp
  instagram: String_comparison_exp
  picture: String_comparison_exp
  twitter: String_comparison_exp
  website: String_comparison_exp
}

"""
unique or primary key constraints on table "Profile"
"""
enum Profile_constraint {
  """
  unique or primary key constraint on columns "accountId"
  """
  Profile_pkey
}

"""
input type for inserting data into table "Profile"
"""
input Profile_insert_input {
  Account: Account_obj_rel_insert_input
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""aggregate max on columns"""
type Profile_max_fields {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""aggregate min on columns"""
type Profile_min_fields {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
response of any mutation on the table "Profile"
"""
type Profile_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Profile!]!
}

"""
input type for inserting object relation for remote table "Profile"
"""
input Profile_obj_rel_insert_input {
  data: Profile_insert_input!

  """upsert condition"""
  on_conflict: Profile_on_conflict
}

"""
on_conflict condition type for table "Profile"
"""
input Profile_on_conflict {
  constraint: Profile_constraint!
  update_columns: [Profile_update_column!]! = []
  where: Profile_bool_exp
}

"""Ordering options when selecting data from "Profile"."""
input Profile_order_by {
  Account: Account_order_by
  accountId: order_by
  description: order_by
  instagram: order_by
  picture: order_by
  twitter: order_by
  website: order_by
}

"""primary key columns input for table: Profile"""
input Profile_pk_columns_input {
  accountId: uuid!
}

"""
select columns of table "Profile"
"""
enum Profile_select_column {
  """column name"""
  accountId

  """column name"""
  description

  """column name"""
  instagram

  """column name"""
  picture

  """column name"""
  twitter

  """column name"""
  website
}

"""
input type for updating data in table "Profile"
"""
input Profile_set_input {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
Streaming cursor of the table "Profile"
"""
input Profile_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Profile_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Profile_stream_cursor_value_input {
  accountId: uuid
  description: String
  instagram: String
  picture: String
  twitter: String
  website: String
}

"""
update columns of table "Profile"
"""
enum Profile_update_column {
  """column name"""
  accountId

  """column name"""
  description

  """column name"""
  instagram

  """column name"""
  picture

  """column name"""
  twitter

  """column name"""
  website
}

input Profile_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Profile_set_input

  """filter the rows which have to be updated"""
  where: Profile_bool_exp!
}

type SetWhitelistOutput {
  merkleRoot: String
  message: String
  success: Boolean!
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "Wallet"
"""
type Wallet {
  """An object relationship"""
  Account: Account!
  accountId: uuid!
  address: String!
  network: BlockchainNetwork!
}

"""
aggregated selection of "Wallet"
"""
type Wallet_aggregate {
  aggregate: Wallet_aggregate_fields
  nodes: [Wallet!]!
}

input Wallet_aggregate_bool_exp {
  count: Wallet_aggregate_bool_exp_count
}

input Wallet_aggregate_bool_exp_count {
  arguments: [Wallet_select_column!]
  distinct: Boolean
  filter: Wallet_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "Wallet"
"""
type Wallet_aggregate_fields {
  count(columns: [Wallet_select_column!], distinct: Boolean): Int!
  max: Wallet_max_fields
  min: Wallet_min_fields
}

"""
order by aggregate values of table "Wallet"
"""
input Wallet_aggregate_order_by {
  count: order_by
  max: Wallet_max_order_by
  min: Wallet_min_order_by
}

"""
input type for inserting array relation for remote table "Wallet"
"""
input Wallet_arr_rel_insert_input {
  data: [Wallet_insert_input!]!

  """upsert condition"""
  on_conflict: Wallet_on_conflict
}

"""
Boolean expression to filter rows from the table "Wallet". All fields are combined with a logical 'AND'.
"""
input Wallet_bool_exp {
  Account: Account_bool_exp
  _and: [Wallet_bool_exp!]
  _not: Wallet_bool_exp
  _or: [Wallet_bool_exp!]
  accountId: uuid_comparison_exp
  address: String_comparison_exp
  network: BlockchainNetwork_comparison_exp
}

"""
unique or primary key constraints on table "Wallet"
"""
enum Wallet_constraint {
  """
  unique or primary key constraint on columns "address"
  """
  Wallet_pkey
}

"""
input type for inserting data into table "Wallet"
"""
input Wallet_insert_input {
  Account: Account_obj_rel_insert_input
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""aggregate max on columns"""
type Wallet_max_fields {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""
order by max() on columns of table "Wallet"
"""
input Wallet_max_order_by {
  accountId: order_by
  address: order_by
  network: order_by
}

"""aggregate min on columns"""
type Wallet_min_fields {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""
order by min() on columns of table "Wallet"
"""
input Wallet_min_order_by {
  accountId: order_by
  address: order_by
  network: order_by
}

"""
response of any mutation on the table "Wallet"
"""
type Wallet_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Wallet!]!
}

"""
on_conflict condition type for table "Wallet"
"""
input Wallet_on_conflict {
  constraint: Wallet_constraint!
  update_columns: [Wallet_update_column!]! = []
  where: Wallet_bool_exp
}

"""Ordering options when selecting data from "Wallet"."""
input Wallet_order_by {
  Account: Account_order_by
  accountId: order_by
  address: order_by
  network: order_by
}

"""primary key columns input for table: Wallet"""
input Wallet_pk_columns_input {
  address: String!
}

"""
select columns of table "Wallet"
"""
enum Wallet_select_column {
  """column name"""
  accountId

  """column name"""
  address

  """column name"""
  network
}

"""
input type for updating data in table "Wallet"
"""
input Wallet_set_input {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""
Streaming cursor of the table "Wallet"
"""
input Wallet_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Wallet_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Wallet_stream_cursor_value_input {
  accountId: uuid
  address: String
  network: BlockchainNetwork
}

"""
update columns of table "Wallet"
"""
enum Wallet_update_column {
  """column name"""
  accountId

  """column name"""
  address

  """column name"""
  network
}

input Wallet_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Wallet_set_input

  """filter the rows which have to be updated"""
  where: Wallet_bool_exp!
}

"""
columns and relationships of "Whitelist"
"""
type Whitelist {
  """An array relationship"""
  Whitelist_WhitelistEntries(
    """distinct select on columns"""
    distinct_on: [WhitelistEntries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WhitelistEntries_order_by!]

    """filter the rows returned"""
    where: WhitelistEntries_bool_exp
  ): [WhitelistEntries!]!

  """An aggregate relationship"""
  Whitelist_WhitelistEntries_aggregate(
    """distinct select on columns"""
    distinct_on: [WhitelistEntries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WhitelistEntries_order_by!]

    """filter the rows returned"""
    where: WhitelistEntries_bool_exp
  ): WhitelistEntries_aggregate!
  merkleRoot: String!
}

"""
columns and relationships of "WhitelistEntries"
"""
type WhitelistEntries {
  """An object relationship"""
  WhitelistEntries_Whitelist: Whitelist!
  merkleRoot: String!
  walletAddress: String!
  whitelistIndex: Int!
}

"""
aggregated selection of "WhitelistEntries"
"""
type WhitelistEntries_aggregate {
  aggregate: WhitelistEntries_aggregate_fields
  nodes: [WhitelistEntries!]!
}

input WhitelistEntries_aggregate_bool_exp {
  count: WhitelistEntries_aggregate_bool_exp_count
}

input WhitelistEntries_aggregate_bool_exp_count {
  arguments: [WhitelistEntries_select_column!]
  distinct: Boolean
  filter: WhitelistEntries_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "WhitelistEntries"
"""
type WhitelistEntries_aggregate_fields {
  avg: WhitelistEntries_avg_fields
  count(columns: [WhitelistEntries_select_column!], distinct: Boolean): Int!
  max: WhitelistEntries_max_fields
  min: WhitelistEntries_min_fields
  stddev: WhitelistEntries_stddev_fields
  stddev_pop: WhitelistEntries_stddev_pop_fields
  stddev_samp: WhitelistEntries_stddev_samp_fields
  sum: WhitelistEntries_sum_fields
  var_pop: WhitelistEntries_var_pop_fields
  var_samp: WhitelistEntries_var_samp_fields
  variance: WhitelistEntries_variance_fields
}

"""
order by aggregate values of table "WhitelistEntries"
"""
input WhitelistEntries_aggregate_order_by {
  avg: WhitelistEntries_avg_order_by
  count: order_by
  max: WhitelistEntries_max_order_by
  min: WhitelistEntries_min_order_by
  stddev: WhitelistEntries_stddev_order_by
  stddev_pop: WhitelistEntries_stddev_pop_order_by
  stddev_samp: WhitelistEntries_stddev_samp_order_by
  sum: WhitelistEntries_sum_order_by
  var_pop: WhitelistEntries_var_pop_order_by
  var_samp: WhitelistEntries_var_samp_order_by
  variance: WhitelistEntries_variance_order_by
}

"""
input type for inserting array relation for remote table "WhitelistEntries"
"""
input WhitelistEntries_arr_rel_insert_input {
  data: [WhitelistEntries_insert_input!]!

  """upsert condition"""
  on_conflict: WhitelistEntries_on_conflict
}

"""aggregate avg on columns"""
type WhitelistEntries_avg_fields {
  whitelistIndex: Float
}

"""
order by avg() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_avg_order_by {
  whitelistIndex: order_by
}

"""
Boolean expression to filter rows from the table "WhitelistEntries". All fields are combined with a logical 'AND'.
"""
input WhitelistEntries_bool_exp {
  WhitelistEntries_Whitelist: Whitelist_bool_exp
  _and: [WhitelistEntries_bool_exp!]
  _not: WhitelistEntries_bool_exp
  _or: [WhitelistEntries_bool_exp!]
  merkleRoot: String_comparison_exp
  walletAddress: String_comparison_exp
  whitelistIndex: Int_comparison_exp
}

"""
unique or primary key constraints on table "WhitelistEntries"
"""
enum WhitelistEntries_constraint {
  """
  unique or primary key constraint on columns "whitelistIndex", "merkleRoot"
  """
  WhitelistEntries_pkey
}

"""
input type for incrementing numeric columns in table "WhitelistEntries"
"""
input WhitelistEntries_inc_input {
  whitelistIndex: Int
}

"""
input type for inserting data into table "WhitelistEntries"
"""
input WhitelistEntries_insert_input {
  WhitelistEntries_Whitelist: Whitelist_obj_rel_insert_input
  merkleRoot: String
  walletAddress: String
  whitelistIndex: Int
}

"""aggregate max on columns"""
type WhitelistEntries_max_fields {
  merkleRoot: String
  walletAddress: String
  whitelistIndex: Int
}

"""
order by max() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_max_order_by {
  merkleRoot: order_by
  walletAddress: order_by
  whitelistIndex: order_by
}

"""aggregate min on columns"""
type WhitelistEntries_min_fields {
  merkleRoot: String
  walletAddress: String
  whitelistIndex: Int
}

"""
order by min() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_min_order_by {
  merkleRoot: order_by
  walletAddress: order_by
  whitelistIndex: order_by
}

"""
response of any mutation on the table "WhitelistEntries"
"""
type WhitelistEntries_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [WhitelistEntries!]!
}

"""
on_conflict condition type for table "WhitelistEntries"
"""
input WhitelistEntries_on_conflict {
  constraint: WhitelistEntries_constraint!
  update_columns: [WhitelistEntries_update_column!]! = []
  where: WhitelistEntries_bool_exp
}

"""Ordering options when selecting data from "WhitelistEntries"."""
input WhitelistEntries_order_by {
  WhitelistEntries_Whitelist: Whitelist_order_by
  merkleRoot: order_by
  walletAddress: order_by
  whitelistIndex: order_by
}

"""primary key columns input for table: WhitelistEntries"""
input WhitelistEntries_pk_columns_input {
  merkleRoot: String!
  whitelistIndex: Int!
}

"""
select columns of table "WhitelistEntries"
"""
enum WhitelistEntries_select_column {
  """column name"""
  merkleRoot

  """column name"""
  walletAddress

  """column name"""
  whitelistIndex
}

"""
input type for updating data in table "WhitelistEntries"
"""
input WhitelistEntries_set_input {
  merkleRoot: String
  walletAddress: String
  whitelistIndex: Int
}

"""aggregate stddev on columns"""
type WhitelistEntries_stddev_fields {
  whitelistIndex: Float
}

"""
order by stddev() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_stddev_order_by {
  whitelistIndex: order_by
}

"""aggregate stddev_pop on columns"""
type WhitelistEntries_stddev_pop_fields {
  whitelistIndex: Float
}

"""
order by stddev_pop() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_stddev_pop_order_by {
  whitelistIndex: order_by
}

"""aggregate stddev_samp on columns"""
type WhitelistEntries_stddev_samp_fields {
  whitelistIndex: Float
}

"""
order by stddev_samp() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_stddev_samp_order_by {
  whitelistIndex: order_by
}

"""
Streaming cursor of the table "WhitelistEntries"
"""
input WhitelistEntries_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: WhitelistEntries_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input WhitelistEntries_stream_cursor_value_input {
  merkleRoot: String
  walletAddress: String
  whitelistIndex: Int
}

"""aggregate sum on columns"""
type WhitelistEntries_sum_fields {
  whitelistIndex: Int
}

"""
order by sum() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_sum_order_by {
  whitelistIndex: order_by
}

"""
update columns of table "WhitelistEntries"
"""
enum WhitelistEntries_update_column {
  """column name"""
  merkleRoot

  """column name"""
  walletAddress

  """column name"""
  whitelistIndex
}

input WhitelistEntries_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: WhitelistEntries_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: WhitelistEntries_set_input

  """filter the rows which have to be updated"""
  where: WhitelistEntries_bool_exp!
}

"""aggregate var_pop on columns"""
type WhitelistEntries_var_pop_fields {
  whitelistIndex: Float
}

"""
order by var_pop() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_var_pop_order_by {
  whitelistIndex: order_by
}

"""aggregate var_samp on columns"""
type WhitelistEntries_var_samp_fields {
  whitelistIndex: Float
}

"""
order by var_samp() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_var_samp_order_by {
  whitelistIndex: order_by
}

"""aggregate variance on columns"""
type WhitelistEntries_variance_fields {
  whitelistIndex: Float
}

"""
order by variance() on columns of table "WhitelistEntries"
"""
input WhitelistEntries_variance_order_by {
  whitelistIndex: order_by
}

"""
aggregated selection of "Whitelist"
"""
type Whitelist_aggregate {
  aggregate: Whitelist_aggregate_fields
  nodes: [Whitelist!]!
}

"""
aggregate fields of "Whitelist"
"""
type Whitelist_aggregate_fields {
  count(columns: [Whitelist_select_column!], distinct: Boolean): Int!
  max: Whitelist_max_fields
  min: Whitelist_min_fields
}

"""
Boolean expression to filter rows from the table "Whitelist". All fields are combined with a logical 'AND'.
"""
input Whitelist_bool_exp {
  Whitelist_WhitelistEntries: WhitelistEntries_bool_exp
  Whitelist_WhitelistEntries_aggregate: WhitelistEntries_aggregate_bool_exp
  _and: [Whitelist_bool_exp!]
  _not: Whitelist_bool_exp
  _or: [Whitelist_bool_exp!]
  merkleRoot: String_comparison_exp
}

"""
unique or primary key constraints on table "Whitelist"
"""
enum Whitelist_constraint {
  """
  unique or primary key constraint on columns "merkleRoot"
  """
  Whitelist_pkey
}

"""
input type for inserting data into table "Whitelist"
"""
input Whitelist_insert_input {
  Whitelist_WhitelistEntries: WhitelistEntries_arr_rel_insert_input
  merkleRoot: String
}

"""aggregate max on columns"""
type Whitelist_max_fields {
  merkleRoot: String
}

"""aggregate min on columns"""
type Whitelist_min_fields {
  merkleRoot: String
}

"""
response of any mutation on the table "Whitelist"
"""
type Whitelist_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [Whitelist!]!
}

"""
input type for inserting object relation for remote table "Whitelist"
"""
input Whitelist_obj_rel_insert_input {
  data: Whitelist_insert_input!

  """upsert condition"""
  on_conflict: Whitelist_on_conflict
}

"""
on_conflict condition type for table "Whitelist"
"""
input Whitelist_on_conflict {
  constraint: Whitelist_constraint!
  update_columns: [Whitelist_update_column!]! = []
  where: Whitelist_bool_exp
}

"""Ordering options when selecting data from "Whitelist"."""
input Whitelist_order_by {
  Whitelist_WhitelistEntries_aggregate: WhitelistEntries_aggregate_order_by
  merkleRoot: order_by
}

"""primary key columns input for table: Whitelist"""
input Whitelist_pk_columns_input {
  merkleRoot: String!
}

"""
select columns of table "Whitelist"
"""
enum Whitelist_select_column {
  """column name"""
  merkleRoot
}

"""
input type for updating data in table "Whitelist"
"""
input Whitelist_set_input {
  merkleRoot: String
}

"""
Streaming cursor of the table "Whitelist"
"""
input Whitelist_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: Whitelist_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input Whitelist_stream_cursor_value_input {
  merkleRoot: String
}

"""
update columns of table "Whitelist"
"""
enum Whitelist_update_column {
  """column name"""
  merkleRoot
}

input Whitelist_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: Whitelist_set_input

  """filter the rows which have to be updated"""
  where: Whitelist_bool_exp!
}

scalar _int2

"""
Boolean expression to compare columns of type "_int2". All fields are combined with logical 'AND'.
"""
input _int2_comparison_exp {
  _eq: _int2
  _gt: _int2
  _gte: _int2
  _in: [_int2!]
  _is_null: Boolean
  _lt: _int2
  _lte: _int2
  _neq: _int2
  _nin: [_int2!]
}

scalar _int4

"""
Boolean expression to compare columns of type "_int4". All fields are combined with logical 'AND'.
"""
input _int4_comparison_exp {
  _eq: _int4
  _gt: _int4
  _gte: _int4
  _in: [_int4!]
  _is_null: Boolean
  _lt: _int4
  _lte: _int4
  _neq: _int4
  _nin: [_int4!]
}

scalar _int8

"""
Boolean expression to compare columns of type "_int8". All fields are combined with logical 'AND'.
"""
input _int8_comparison_exp {
  _eq: _int8
  _gt: _int8
  _gte: _int8
  _in: [_int8!]
  _is_null: Boolean
  _lt: _int8
  _lte: _int8
  _neq: _int8
  _nin: [_int8!]
}

scalar _text

"""
Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'.
"""
input _text_comparison_exp {
  _eq: _text
  _gt: _text
  _gte: _text
  _in: [_text!]
  _is_null: Boolean
  _lt: _text
  _lte: _text
  _neq: _text
  _nin: [_text!]
}

"""
columns and relationships of "action"
"""
type action {
  """An object relationship"""
  article: article
  article_id: Int
  created_at: timestamptz!

  """An object relationship"""
  generative_token: generative_token
  id: uuid!
  issuer_id: String
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  numeric_value: numeric

  """An object relationship"""
  objkt: objkt
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String!

  """An object relationship"""
  redeemable: redeemable
  redeemable_address: String
  target_id: String
  ticket_id: String
  token_id: String
  type: action_type_enum!

  """An object relationship"""
  user: user

  """An object relationship"""
  userByIssuerId: user
}

"""
aggregated selection of "action"
"""
type action_aggregate {
  aggregate: action_aggregate_fields
  nodes: [action!]!
}

input action_aggregate_bool_exp {
  count: action_aggregate_bool_exp_count
}

input action_aggregate_bool_exp_count {
  arguments: [action_select_column!]
  distinct: Boolean
  filter: action_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "action"
"""
type action_aggregate_fields {
  avg: action_avg_fields
  count(columns: [action_select_column!], distinct: Boolean): Int!
  max: action_max_fields
  min: action_min_fields
  stddev: action_stddev_fields
  stddev_pop: action_stddev_pop_fields
  stddev_samp: action_stddev_samp_fields
  sum: action_sum_fields
  var_pop: action_var_pop_fields
  var_samp: action_var_samp_fields
  variance: action_variance_fields
}

"""
order by aggregate values of table "action"
"""
input action_aggregate_order_by {
  avg: action_avg_order_by
  count: order_by
  max: action_max_order_by
  min: action_min_order_by
  stddev: action_stddev_order_by
  stddev_pop: action_stddev_pop_order_by
  stddev_samp: action_stddev_samp_order_by
  sum: action_sum_order_by
  var_pop: action_var_pop_order_by
  var_samp: action_var_samp_order_by
  variance: action_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input action_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "action"
"""
input action_arr_rel_insert_input {
  data: [action_insert_input!]!

  """upsert condition"""
  on_conflict: action_on_conflict
}

"""aggregate avg on columns"""
type action_avg_fields {
  article_id: Float
  numeric_value: Float
}

"""
order by avg() on columns of table "action"
"""
input action_avg_order_by {
  article_id: order_by
  numeric_value: order_by
}

"""
Boolean expression to filter rows from the table "action". All fields are combined with a logical 'AND'.
"""
input action_bool_exp {
  _and: [action_bool_exp!]
  _not: action_bool_exp
  _or: [action_bool_exp!]
  article: article_bool_exp
  article_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  generative_token: generative_token_bool_exp
  id: uuid_comparison_exp
  issuer_id: String_comparison_exp
  metadata: jsonb_comparison_exp
  numeric_value: numeric_comparison_exp
  objkt: objkt_bool_exp
  objkt_id: String_comparison_exp
  objkt_issuer_version: generative_token_version_comparison_exp
  op_hash: String_comparison_exp
  redeemable: redeemable_bool_exp
  redeemable_address: String_comparison_exp
  target_id: String_comparison_exp
  ticket_id: String_comparison_exp
  token_id: String_comparison_exp
  type: action_type_enum_comparison_exp
  user: user_bool_exp
  userByIssuerId: user_bool_exp
}

"""
unique or primary key constraints on table "action"
"""
enum action_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_2d9db9cf5edfbbae74eb56e3a39
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input action_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input action_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input action_delete_key_input {
  metadata: String
}

"""
input type for incrementing numeric columns in table "action"
"""
input action_inc_input {
  article_id: Int
  numeric_value: numeric
}

"""
input type for inserting data into table "action"
"""
input action_insert_input {
  article: article_obj_rel_insert_input
  article_id: Int
  created_at: timestamptz
  generative_token: generative_token_obj_rel_insert_input
  id: uuid
  issuer_id: String
  metadata: jsonb
  numeric_value: numeric
  objkt: objkt_obj_rel_insert_input
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  redeemable: redeemable_obj_rel_insert_input
  redeemable_address: String
  target_id: String
  ticket_id: String
  token_id: String
  type: action_type_enum
  user: user_obj_rel_insert_input
  userByIssuerId: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type action_max_fields {
  article_id: Int
  created_at: timestamptz
  id: uuid
  issuer_id: String
  numeric_value: numeric
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  redeemable_address: String
  target_id: String
  ticket_id: String
  token_id: String
  type: action_type_enum
}

"""
order by max() on columns of table "action"
"""
input action_max_order_by {
  article_id: order_by
  created_at: order_by
  id: order_by
  issuer_id: order_by
  numeric_value: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  op_hash: order_by
  redeemable_address: order_by
  target_id: order_by
  ticket_id: order_by
  token_id: order_by
  type: order_by
}

"""aggregate min on columns"""
type action_min_fields {
  article_id: Int
  created_at: timestamptz
  id: uuid
  issuer_id: String
  numeric_value: numeric
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  redeemable_address: String
  target_id: String
  ticket_id: String
  token_id: String
  type: action_type_enum
}

"""
order by min() on columns of table "action"
"""
input action_min_order_by {
  article_id: order_by
  created_at: order_by
  id: order_by
  issuer_id: order_by
  numeric_value: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  op_hash: order_by
  redeemable_address: order_by
  target_id: order_by
  ticket_id: order_by
  token_id: order_by
  type: order_by
}

"""
response of any mutation on the table "action"
"""
type action_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [action!]!
}

"""
on_conflict condition type for table "action"
"""
input action_on_conflict {
  constraint: action_constraint!
  update_columns: [action_update_column!]! = []
  where: action_bool_exp
}

"""Ordering options when selecting data from "action"."""
input action_order_by {
  article: article_order_by
  article_id: order_by
  created_at: order_by
  generative_token: generative_token_order_by
  id: order_by
  issuer_id: order_by
  metadata: order_by
  numeric_value: order_by
  objkt: objkt_order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  op_hash: order_by
  redeemable: redeemable_order_by
  redeemable_address: order_by
  target_id: order_by
  ticket_id: order_by
  token_id: order_by
  type: order_by
  user: user_order_by
  userByIssuerId: user_order_by
}

"""primary key columns input for table: action"""
input action_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input action_prepend_input {
  metadata: jsonb
}

"""
select columns of table "action"
"""
enum action_select_column {
  """column name"""
  article_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  issuer_id

  """column name"""
  metadata

  """column name"""
  numeric_value

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  op_hash

  """column name"""
  redeemable_address

  """column name"""
  target_id

  """column name"""
  ticket_id

  """column name"""
  token_id

  """column name"""
  type
}

"""
input type for updating data in table "action"
"""
input action_set_input {
  article_id: Int
  created_at: timestamptz
  id: uuid
  issuer_id: String
  metadata: jsonb
  numeric_value: numeric
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  redeemable_address: String
  target_id: String
  ticket_id: String
  token_id: String
  type: action_type_enum
}

"""aggregate stddev on columns"""
type action_stddev_fields {
  article_id: Float
  numeric_value: Float
}

"""
order by stddev() on columns of table "action"
"""
input action_stddev_order_by {
  article_id: order_by
  numeric_value: order_by
}

"""aggregate stddev_pop on columns"""
type action_stddev_pop_fields {
  article_id: Float
  numeric_value: Float
}

"""
order by stddev_pop() on columns of table "action"
"""
input action_stddev_pop_order_by {
  article_id: order_by
  numeric_value: order_by
}

"""aggregate stddev_samp on columns"""
type action_stddev_samp_fields {
  article_id: Float
  numeric_value: Float
}

"""
order by stddev_samp() on columns of table "action"
"""
input action_stddev_samp_order_by {
  article_id: order_by
  numeric_value: order_by
}

"""
Streaming cursor of the table "action"
"""
input action_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: action_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input action_stream_cursor_value_input {
  article_id: Int
  created_at: timestamptz
  id: uuid
  issuer_id: String
  metadata: jsonb
  numeric_value: numeric
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  redeemable_address: String
  target_id: String
  ticket_id: String
  token_id: String
  type: action_type_enum
}

"""aggregate sum on columns"""
type action_sum_fields {
  article_id: Int
  numeric_value: numeric
}

"""
order by sum() on columns of table "action"
"""
input action_sum_order_by {
  article_id: order_by
  numeric_value: order_by
}

scalar action_type_enum

"""
Boolean expression to compare columns of type "action_type_enum". All fields are combined with logical 'AND'.
"""
input action_type_enum_comparison_exp {
  _eq: action_type_enum
  _gt: action_type_enum
  _gte: action_type_enum
  _in: [action_type_enum!]
  _is_null: Boolean
  _lt: action_type_enum
  _lte: action_type_enum
  _neq: action_type_enum
  _nin: [action_type_enum!]
}

"""
update columns of table "action"
"""
enum action_update_column {
  """column name"""
  article_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  issuer_id

  """column name"""
  metadata

  """column name"""
  numeric_value

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  op_hash

  """column name"""
  redeemable_address

  """column name"""
  target_id

  """column name"""
  ticket_id

  """column name"""
  token_id

  """column name"""
  type
}

input action_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: action_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: action_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: action_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: action_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: action_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: action_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: action_set_input

  """filter the rows which have to be updated"""
  where: action_bool_exp!
}

"""aggregate var_pop on columns"""
type action_var_pop_fields {
  article_id: Float
  numeric_value: Float
}

"""
order by var_pop() on columns of table "action"
"""
input action_var_pop_order_by {
  article_id: order_by
  numeric_value: order_by
}

"""aggregate var_samp on columns"""
type action_var_samp_fields {
  article_id: Float
  numeric_value: Float
}

"""
order by var_samp() on columns of table "action"
"""
input action_var_samp_order_by {
  article_id: order_by
  numeric_value: order_by
}

"""aggregate variance on columns"""
type action_variance_fields {
  article_id: Float
  numeric_value: Float
}

"""
order by variance() on columns of table "action"
"""
input action_variance_order_by {
  article_id: order_by
  numeric_value: order_by
}

"""
columns and relationships of "article"
"""
type article {
  """An array relationship"""
  actions(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """An aggregate relationship"""
  actions_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """An array relationship"""
  article_ledgers(
    """distinct select on columns"""
    distinct_on: [article_ledger_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_ledger_order_by!]

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): [article_ledger!]!

  """An aggregate relationship"""
  article_ledgers_aggregate(
    """distinct select on columns"""
    distinct_on: [article_ledger_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_ledger_order_by!]

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): article_ledger_aggregate!

  """An array relationship"""
  article_revisions(
    """distinct select on columns"""
    distinct_on: [article_revision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_revision_order_by!]

    """filter the rows returned"""
    where: article_revision_bool_exp
  ): [article_revision!]!

  """An aggregate relationship"""
  article_revisions_aggregate(
    """distinct select on columns"""
    distinct_on: [article_revision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_revision_order_by!]

    """filter the rows returned"""
    where: article_revision_bool_exp
  ): article_revision_aggregate!
  artifact_uri: String!
  author_id: String!
  body: String!
  created_at: timestamptz!
  description: String!
  display_uri: String!
  editions: bigint!
  flag: article_flag_enum!
  id: Int!
  language: String!

  """An array relationship"""
  listings(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): [listing!]!

  """An aggregate relationship"""
  listings_aggregate(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): listing_aggregate!

  """An object relationship"""
  media_image: media_image
  metadata(
    """JSON select path"""
    path: String
  ): json!
  metadata_locked: Boolean!
  metadata_uri: String!
  mint_op_hash: String!

  """An object relationship"""
  moderation_reason: moderation_reason
  moderation_reason_id: String
  platforms: _text
  royalties: Int!
  slug: String!

  """An array relationship"""
  splits(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """An aggregate relationship"""
  splits_aggregate(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): split_aggregate!
  tags: _text!
  thumbnailMediaId: bpchar
  thumbnail_caption: String
  thumbnail_uri: String!
  title: String!

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """An object relationship"""
  user: user!
}

"""
aggregated selection of "article"
"""
type article_aggregate {
  aggregate: article_aggregate_fields
  nodes: [article!]!
}

input article_aggregate_bool_exp {
  bool_and: article_aggregate_bool_exp_bool_and
  bool_or: article_aggregate_bool_exp_bool_or
  count: article_aggregate_bool_exp_count
}

input article_aggregate_bool_exp_bool_and {
  arguments: article_select_column_article_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: article_bool_exp
  predicate: Boolean_comparison_exp!
}

input article_aggregate_bool_exp_bool_or {
  arguments: article_select_column_article_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: article_bool_exp
  predicate: Boolean_comparison_exp!
}

input article_aggregate_bool_exp_count {
  arguments: [article_select_column!]
  distinct: Boolean
  filter: article_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "article"
"""
type article_aggregate_fields {
  avg: article_avg_fields
  count(columns: [article_select_column!], distinct: Boolean): Int!
  max: article_max_fields
  min: article_min_fields
  stddev: article_stddev_fields
  stddev_pop: article_stddev_pop_fields
  stddev_samp: article_stddev_samp_fields
  sum: article_sum_fields
  var_pop: article_var_pop_fields
  var_samp: article_var_samp_fields
  variance: article_variance_fields
}

"""
order by aggregate values of table "article"
"""
input article_aggregate_order_by {
  avg: article_avg_order_by
  count: order_by
  max: article_max_order_by
  min: article_min_order_by
  stddev: article_stddev_order_by
  stddev_pop: article_stddev_pop_order_by
  stddev_samp: article_stddev_samp_order_by
  sum: article_sum_order_by
  var_pop: article_var_pop_order_by
  var_samp: article_var_samp_order_by
  variance: article_variance_order_by
}

"""
input type for inserting array relation for remote table "article"
"""
input article_arr_rel_insert_input {
  data: [article_insert_input!]!

  """upsert condition"""
  on_conflict: article_on_conflict
}

"""aggregate avg on columns"""
type article_avg_fields {
  editions: Float
  id: Float
  royalties: Float
}

"""
order by avg() on columns of table "article"
"""
input article_avg_order_by {
  editions: order_by
  id: order_by
  royalties: order_by
}

"""
Boolean expression to filter rows from the table "article". All fields are combined with a logical 'AND'.
"""
input article_bool_exp {
  _and: [article_bool_exp!]
  _not: article_bool_exp
  _or: [article_bool_exp!]
  actions: action_bool_exp
  actions_aggregate: action_aggregate_bool_exp
  article_ledgers: article_ledger_bool_exp
  article_ledgers_aggregate: article_ledger_aggregate_bool_exp
  article_revisions: article_revision_bool_exp
  article_revisions_aggregate: article_revision_aggregate_bool_exp
  artifact_uri: String_comparison_exp
  author_id: String_comparison_exp
  body: String_comparison_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  display_uri: String_comparison_exp
  editions: bigint_comparison_exp
  flag: article_flag_enum_comparison_exp
  id: Int_comparison_exp
  language: String_comparison_exp
  listings: listing_bool_exp
  listings_aggregate: listing_aggregate_bool_exp
  media_image: media_image_bool_exp
  metadata: json_comparison_exp
  metadata_locked: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  mint_op_hash: String_comparison_exp
  moderation_reason: moderation_reason_bool_exp
  moderation_reason_id: String_comparison_exp
  platforms: _text_comparison_exp
  royalties: Int_comparison_exp
  slug: String_comparison_exp
  splits: split_bool_exp
  splits_aggregate: split_aggregate_bool_exp
  tags: _text_comparison_exp
  thumbnailMediaId: bpchar_comparison_exp
  thumbnail_caption: String_comparison_exp
  thumbnail_uri: String_comparison_exp
  title: String_comparison_exp
  transactions: transaction_bool_exp
  transactions_aggregate: transaction_aggregate_bool_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "article"
"""
enum article_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_40808690eb7b915046558c0f81b
}

scalar article_flag_enum

"""
Boolean expression to compare columns of type "article_flag_enum". All fields are combined with logical 'AND'.
"""
input article_flag_enum_comparison_exp {
  _eq: article_flag_enum
  _gt: article_flag_enum
  _gte: article_flag_enum
  _in: [article_flag_enum!]
  _is_null: Boolean
  _lt: article_flag_enum
  _lte: article_flag_enum
  _neq: article_flag_enum
  _nin: [article_flag_enum!]
}

"""
columns and relationships of "article_generative_token"
"""
type article_generative_token {
  article_id: Int!
  generative_token_id: String!
  line: Int!
}

"""
aggregated selection of "article_generative_token"
"""
type article_generative_token_aggregate {
  aggregate: article_generative_token_aggregate_fields
  nodes: [article_generative_token!]!
}

"""
aggregate fields of "article_generative_token"
"""
type article_generative_token_aggregate_fields {
  avg: article_generative_token_avg_fields
  count(columns: [article_generative_token_select_column!], distinct: Boolean): Int!
  max: article_generative_token_max_fields
  min: article_generative_token_min_fields
  stddev: article_generative_token_stddev_fields
  stddev_pop: article_generative_token_stddev_pop_fields
  stddev_samp: article_generative_token_stddev_samp_fields
  sum: article_generative_token_sum_fields
  var_pop: article_generative_token_var_pop_fields
  var_samp: article_generative_token_var_samp_fields
  variance: article_generative_token_variance_fields
}

"""aggregate avg on columns"""
type article_generative_token_avg_fields {
  article_id: Float
  line: Float
}

"""
Boolean expression to filter rows from the table "article_generative_token". All fields are combined with a logical 'AND'.
"""
input article_generative_token_bool_exp {
  _and: [article_generative_token_bool_exp!]
  _not: article_generative_token_bool_exp
  _or: [article_generative_token_bool_exp!]
  article_id: Int_comparison_exp
  generative_token_id: String_comparison_exp
  line: Int_comparison_exp
}

"""
unique or primary key constraints on table "article_generative_token"
"""
enum article_generative_token_constraint {
  """
  unique or primary key constraint on columns "generative_token_id", "article_id"
  """
  PK_10ab76f2a055c1017ea7371332b
}

"""
input type for incrementing numeric columns in table "article_generative_token"
"""
input article_generative_token_inc_input {
  article_id: Int
  line: Int
}

"""
input type for inserting data into table "article_generative_token"
"""
input article_generative_token_insert_input {
  article_id: Int
  generative_token_id: String
  line: Int
}

"""aggregate max on columns"""
type article_generative_token_max_fields {
  article_id: Int
  generative_token_id: String
  line: Int
}

"""aggregate min on columns"""
type article_generative_token_min_fields {
  article_id: Int
  generative_token_id: String
  line: Int
}

"""
response of any mutation on the table "article_generative_token"
"""
type article_generative_token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [article_generative_token!]!
}

"""
on_conflict condition type for table "article_generative_token"
"""
input article_generative_token_on_conflict {
  constraint: article_generative_token_constraint!
  update_columns: [article_generative_token_update_column!]! = []
  where: article_generative_token_bool_exp
}

"""Ordering options when selecting data from "article_generative_token"."""
input article_generative_token_order_by {
  article_id: order_by
  generative_token_id: order_by
  line: order_by
}

"""primary key columns input for table: article_generative_token"""
input article_generative_token_pk_columns_input {
  article_id: Int!
  generative_token_id: String!
}

"""
select columns of table "article_generative_token"
"""
enum article_generative_token_select_column {
  """column name"""
  article_id

  """column name"""
  generative_token_id

  """column name"""
  line
}

"""
input type for updating data in table "article_generative_token"
"""
input article_generative_token_set_input {
  article_id: Int
  generative_token_id: String
  line: Int
}

"""aggregate stddev on columns"""
type article_generative_token_stddev_fields {
  article_id: Float
  line: Float
}

"""aggregate stddev_pop on columns"""
type article_generative_token_stddev_pop_fields {
  article_id: Float
  line: Float
}

"""aggregate stddev_samp on columns"""
type article_generative_token_stddev_samp_fields {
  article_id: Float
  line: Float
}

"""
Streaming cursor of the table "article_generative_token"
"""
input article_generative_token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: article_generative_token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input article_generative_token_stream_cursor_value_input {
  article_id: Int
  generative_token_id: String
  line: Int
}

"""aggregate sum on columns"""
type article_generative_token_sum_fields {
  article_id: Int
  line: Int
}

"""
update columns of table "article_generative_token"
"""
enum article_generative_token_update_column {
  """column name"""
  article_id

  """column name"""
  generative_token_id

  """column name"""
  line
}

input article_generative_token_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: article_generative_token_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: article_generative_token_set_input

  """filter the rows which have to be updated"""
  where: article_generative_token_bool_exp!
}

"""aggregate var_pop on columns"""
type article_generative_token_var_pop_fields {
  article_id: Float
  line: Float
}

"""aggregate var_samp on columns"""
type article_generative_token_var_samp_fields {
  article_id: Float
  line: Float
}

"""aggregate variance on columns"""
type article_generative_token_variance_fields {
  article_id: Float
  line: Float
}

"""
input type for incrementing numeric columns in table "article"
"""
input article_inc_input {
  editions: bigint
  id: Int
  royalties: Int
}

"""
input type for inserting data into table "article"
"""
input article_insert_input {
  actions: action_arr_rel_insert_input
  article_ledgers: article_ledger_arr_rel_insert_input
  article_revisions: article_revision_arr_rel_insert_input
  artifact_uri: String
  author_id: String
  body: String
  created_at: timestamptz
  description: String
  display_uri: String
  editions: bigint
  flag: article_flag_enum
  id: Int
  language: String
  listings: listing_arr_rel_insert_input
  media_image: media_image_obj_rel_insert_input
  metadata: json
  metadata_locked: Boolean
  metadata_uri: String
  mint_op_hash: String
  moderation_reason: moderation_reason_obj_rel_insert_input
  moderation_reason_id: String
  platforms: _text
  royalties: Int
  slug: String
  splits: split_arr_rel_insert_input
  tags: _text
  thumbnailMediaId: bpchar
  thumbnail_caption: String
  thumbnail_uri: String
  title: String
  transactions: transaction_arr_rel_insert_input
  user: user_obj_rel_insert_input
}

"""
columns and relationships of "article_ledger"
"""
type article_ledger {
  amount: bigint!

  """An object relationship"""
  article: article!
  article_id: Int!
  owner_id: String!

  """An object relationship"""
  user: user!
}

"""
aggregated selection of "article_ledger"
"""
type article_ledger_aggregate {
  aggregate: article_ledger_aggregate_fields
  nodes: [article_ledger!]!
}

input article_ledger_aggregate_bool_exp {
  count: article_ledger_aggregate_bool_exp_count
}

input article_ledger_aggregate_bool_exp_count {
  arguments: [article_ledger_select_column!]
  distinct: Boolean
  filter: article_ledger_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "article_ledger"
"""
type article_ledger_aggregate_fields {
  avg: article_ledger_avg_fields
  count(columns: [article_ledger_select_column!], distinct: Boolean): Int!
  max: article_ledger_max_fields
  min: article_ledger_min_fields
  stddev: article_ledger_stddev_fields
  stddev_pop: article_ledger_stddev_pop_fields
  stddev_samp: article_ledger_stddev_samp_fields
  sum: article_ledger_sum_fields
  var_pop: article_ledger_var_pop_fields
  var_samp: article_ledger_var_samp_fields
  variance: article_ledger_variance_fields
}

"""
order by aggregate values of table "article_ledger"
"""
input article_ledger_aggregate_order_by {
  avg: article_ledger_avg_order_by
  count: order_by
  max: article_ledger_max_order_by
  min: article_ledger_min_order_by
  stddev: article_ledger_stddev_order_by
  stddev_pop: article_ledger_stddev_pop_order_by
  stddev_samp: article_ledger_stddev_samp_order_by
  sum: article_ledger_sum_order_by
  var_pop: article_ledger_var_pop_order_by
  var_samp: article_ledger_var_samp_order_by
  variance: article_ledger_variance_order_by
}

"""
input type for inserting array relation for remote table "article_ledger"
"""
input article_ledger_arr_rel_insert_input {
  data: [article_ledger_insert_input!]!

  """upsert condition"""
  on_conflict: article_ledger_on_conflict
}

"""aggregate avg on columns"""
type article_ledger_avg_fields {
  amount: Float
  article_id: Float
}

"""
order by avg() on columns of table "article_ledger"
"""
input article_ledger_avg_order_by {
  amount: order_by
  article_id: order_by
}

"""
Boolean expression to filter rows from the table "article_ledger". All fields are combined with a logical 'AND'.
"""
input article_ledger_bool_exp {
  _and: [article_ledger_bool_exp!]
  _not: article_ledger_bool_exp
  _or: [article_ledger_bool_exp!]
  amount: bigint_comparison_exp
  article: article_bool_exp
  article_id: Int_comparison_exp
  owner_id: String_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "article_ledger"
"""
enum article_ledger_constraint {
  """
  unique or primary key constraint on columns "owner_id", "article_id"
  """
  PK_eeea7173c4f29f2f62b92b0efdf
}

"""
input type for incrementing numeric columns in table "article_ledger"
"""
input article_ledger_inc_input {
  amount: bigint
  article_id: Int
}

"""
input type for inserting data into table "article_ledger"
"""
input article_ledger_insert_input {
  amount: bigint
  article: article_obj_rel_insert_input
  article_id: Int
  owner_id: String
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type article_ledger_max_fields {
  amount: bigint
  article_id: Int
  owner_id: String
}

"""
order by max() on columns of table "article_ledger"
"""
input article_ledger_max_order_by {
  amount: order_by
  article_id: order_by
  owner_id: order_by
}

"""aggregate min on columns"""
type article_ledger_min_fields {
  amount: bigint
  article_id: Int
  owner_id: String
}

"""
order by min() on columns of table "article_ledger"
"""
input article_ledger_min_order_by {
  amount: order_by
  article_id: order_by
  owner_id: order_by
}

"""
response of any mutation on the table "article_ledger"
"""
type article_ledger_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [article_ledger!]!
}

"""
on_conflict condition type for table "article_ledger"
"""
input article_ledger_on_conflict {
  constraint: article_ledger_constraint!
  update_columns: [article_ledger_update_column!]! = []
  where: article_ledger_bool_exp
}

"""Ordering options when selecting data from "article_ledger"."""
input article_ledger_order_by {
  amount: order_by
  article: article_order_by
  article_id: order_by
  owner_id: order_by
  user: user_order_by
}

"""primary key columns input for table: article_ledger"""
input article_ledger_pk_columns_input {
  article_id: Int!
  owner_id: String!
}

"""
select columns of table "article_ledger"
"""
enum article_ledger_select_column {
  """column name"""
  amount

  """column name"""
  article_id

  """column name"""
  owner_id
}

"""
input type for updating data in table "article_ledger"
"""
input article_ledger_set_input {
  amount: bigint
  article_id: Int
  owner_id: String
}

"""aggregate stddev on columns"""
type article_ledger_stddev_fields {
  amount: Float
  article_id: Float
}

"""
order by stddev() on columns of table "article_ledger"
"""
input article_ledger_stddev_order_by {
  amount: order_by
  article_id: order_by
}

"""aggregate stddev_pop on columns"""
type article_ledger_stddev_pop_fields {
  amount: Float
  article_id: Float
}

"""
order by stddev_pop() on columns of table "article_ledger"
"""
input article_ledger_stddev_pop_order_by {
  amount: order_by
  article_id: order_by
}

"""aggregate stddev_samp on columns"""
type article_ledger_stddev_samp_fields {
  amount: Float
  article_id: Float
}

"""
order by stddev_samp() on columns of table "article_ledger"
"""
input article_ledger_stddev_samp_order_by {
  amount: order_by
  article_id: order_by
}

"""
Streaming cursor of the table "article_ledger"
"""
input article_ledger_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: article_ledger_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input article_ledger_stream_cursor_value_input {
  amount: bigint
  article_id: Int
  owner_id: String
}

"""aggregate sum on columns"""
type article_ledger_sum_fields {
  amount: bigint
  article_id: Int
}

"""
order by sum() on columns of table "article_ledger"
"""
input article_ledger_sum_order_by {
  amount: order_by
  article_id: order_by
}

"""
update columns of table "article_ledger"
"""
enum article_ledger_update_column {
  """column name"""
  amount

  """column name"""
  article_id

  """column name"""
  owner_id
}

input article_ledger_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: article_ledger_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: article_ledger_set_input

  """filter the rows which have to be updated"""
  where: article_ledger_bool_exp!
}

"""aggregate var_pop on columns"""
type article_ledger_var_pop_fields {
  amount: Float
  article_id: Float
}

"""
order by var_pop() on columns of table "article_ledger"
"""
input article_ledger_var_pop_order_by {
  amount: order_by
  article_id: order_by
}

"""aggregate var_samp on columns"""
type article_ledger_var_samp_fields {
  amount: Float
  article_id: Float
}

"""
order by var_samp() on columns of table "article_ledger"
"""
input article_ledger_var_samp_order_by {
  amount: order_by
  article_id: order_by
}

"""aggregate variance on columns"""
type article_ledger_variance_fields {
  amount: Float
  article_id: Float
}

"""
order by variance() on columns of table "article_ledger"
"""
input article_ledger_variance_order_by {
  amount: order_by
  article_id: order_by
}

"""aggregate max on columns"""
type article_max_fields {
  artifact_uri: String
  author_id: String
  body: String
  created_at: timestamptz
  description: String
  display_uri: String
  editions: bigint
  flag: article_flag_enum
  id: Int
  language: String
  metadata_uri: String
  mint_op_hash: String
  moderation_reason_id: String
  royalties: Int
  slug: String
  thumbnailMediaId: bpchar
  thumbnail_caption: String
  thumbnail_uri: String
  title: String
}

"""
order by max() on columns of table "article"
"""
input article_max_order_by {
  artifact_uri: order_by
  author_id: order_by
  body: order_by
  created_at: order_by
  description: order_by
  display_uri: order_by
  editions: order_by
  flag: order_by
  id: order_by
  language: order_by
  metadata_uri: order_by
  mint_op_hash: order_by
  moderation_reason_id: order_by
  royalties: order_by
  slug: order_by
  thumbnailMediaId: order_by
  thumbnail_caption: order_by
  thumbnail_uri: order_by
  title: order_by
}

"""aggregate min on columns"""
type article_min_fields {
  artifact_uri: String
  author_id: String
  body: String
  created_at: timestamptz
  description: String
  display_uri: String
  editions: bigint
  flag: article_flag_enum
  id: Int
  language: String
  metadata_uri: String
  mint_op_hash: String
  moderation_reason_id: String
  royalties: Int
  slug: String
  thumbnailMediaId: bpchar
  thumbnail_caption: String
  thumbnail_uri: String
  title: String
}

"""
order by min() on columns of table "article"
"""
input article_min_order_by {
  artifact_uri: order_by
  author_id: order_by
  body: order_by
  created_at: order_by
  description: order_by
  display_uri: order_by
  editions: order_by
  flag: order_by
  id: order_by
  language: order_by
  metadata_uri: order_by
  mint_op_hash: order_by
  moderation_reason_id: order_by
  royalties: order_by
  slug: order_by
  thumbnailMediaId: order_by
  thumbnail_caption: order_by
  thumbnail_uri: order_by
  title: order_by
}

"""
response of any mutation on the table "article"
"""
type article_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [article!]!
}

"""
input type for inserting object relation for remote table "article"
"""
input article_obj_rel_insert_input {
  data: article_insert_input!

  """upsert condition"""
  on_conflict: article_on_conflict
}

"""
on_conflict condition type for table "article"
"""
input article_on_conflict {
  constraint: article_constraint!
  update_columns: [article_update_column!]! = []
  where: article_bool_exp
}

"""Ordering options when selecting data from "article"."""
input article_order_by {
  actions_aggregate: action_aggregate_order_by
  article_ledgers_aggregate: article_ledger_aggregate_order_by
  article_revisions_aggregate: article_revision_aggregate_order_by
  artifact_uri: order_by
  author_id: order_by
  body: order_by
  created_at: order_by
  description: order_by
  display_uri: order_by
  editions: order_by
  flag: order_by
  id: order_by
  language: order_by
  listings_aggregate: listing_aggregate_order_by
  media_image: media_image_order_by
  metadata: order_by
  metadata_locked: order_by
  metadata_uri: order_by
  mint_op_hash: order_by
  moderation_reason: moderation_reason_order_by
  moderation_reason_id: order_by
  platforms: order_by
  royalties: order_by
  slug: order_by
  splits_aggregate: split_aggregate_order_by
  tags: order_by
  thumbnailMediaId: order_by
  thumbnail_caption: order_by
  thumbnail_uri: order_by
  title: order_by
  transactions_aggregate: transaction_aggregate_order_by
  user: user_order_by
}

"""primary key columns input for table: article"""
input article_pk_columns_input {
  id: Int!
}

"""
columns and relationships of "article_revision"
"""
type article_revision {
  """An object relationship"""
  article: article!
  article_id: Int!
  created_at: timestamptz!
  iteration: smallint!
  metadata_uri: String!
  op_hash: String!
}

"""
aggregated selection of "article_revision"
"""
type article_revision_aggregate {
  aggregate: article_revision_aggregate_fields
  nodes: [article_revision!]!
}

input article_revision_aggregate_bool_exp {
  count: article_revision_aggregate_bool_exp_count
}

input article_revision_aggregate_bool_exp_count {
  arguments: [article_revision_select_column!]
  distinct: Boolean
  filter: article_revision_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "article_revision"
"""
type article_revision_aggregate_fields {
  avg: article_revision_avg_fields
  count(columns: [article_revision_select_column!], distinct: Boolean): Int!
  max: article_revision_max_fields
  min: article_revision_min_fields
  stddev: article_revision_stddev_fields
  stddev_pop: article_revision_stddev_pop_fields
  stddev_samp: article_revision_stddev_samp_fields
  sum: article_revision_sum_fields
  var_pop: article_revision_var_pop_fields
  var_samp: article_revision_var_samp_fields
  variance: article_revision_variance_fields
}

"""
order by aggregate values of table "article_revision"
"""
input article_revision_aggregate_order_by {
  avg: article_revision_avg_order_by
  count: order_by
  max: article_revision_max_order_by
  min: article_revision_min_order_by
  stddev: article_revision_stddev_order_by
  stddev_pop: article_revision_stddev_pop_order_by
  stddev_samp: article_revision_stddev_samp_order_by
  sum: article_revision_sum_order_by
  var_pop: article_revision_var_pop_order_by
  var_samp: article_revision_var_samp_order_by
  variance: article_revision_variance_order_by
}

"""
input type for inserting array relation for remote table "article_revision"
"""
input article_revision_arr_rel_insert_input {
  data: [article_revision_insert_input!]!

  """upsert condition"""
  on_conflict: article_revision_on_conflict
}

"""aggregate avg on columns"""
type article_revision_avg_fields {
  article_id: Float
  iteration: Float
}

"""
order by avg() on columns of table "article_revision"
"""
input article_revision_avg_order_by {
  article_id: order_by
  iteration: order_by
}

"""
Boolean expression to filter rows from the table "article_revision". All fields are combined with a logical 'AND'.
"""
input article_revision_bool_exp {
  _and: [article_revision_bool_exp!]
  _not: article_revision_bool_exp
  _or: [article_revision_bool_exp!]
  article: article_bool_exp
  article_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  iteration: smallint_comparison_exp
  metadata_uri: String_comparison_exp
  op_hash: String_comparison_exp
}

"""
unique or primary key constraints on table "article_revision"
"""
enum article_revision_constraint {
  """
  unique or primary key constraint on columns "article_id", "iteration"
  """
  PK_6dccdbb0aa1593c3c560c23c5e9
}

"""
input type for incrementing numeric columns in table "article_revision"
"""
input article_revision_inc_input {
  article_id: Int
  iteration: smallint
}

"""
input type for inserting data into table "article_revision"
"""
input article_revision_insert_input {
  article: article_obj_rel_insert_input
  article_id: Int
  created_at: timestamptz
  iteration: smallint
  metadata_uri: String
  op_hash: String
}

"""aggregate max on columns"""
type article_revision_max_fields {
  article_id: Int
  created_at: timestamptz
  iteration: smallint
  metadata_uri: String
  op_hash: String
}

"""
order by max() on columns of table "article_revision"
"""
input article_revision_max_order_by {
  article_id: order_by
  created_at: order_by
  iteration: order_by
  metadata_uri: order_by
  op_hash: order_by
}

"""aggregate min on columns"""
type article_revision_min_fields {
  article_id: Int
  created_at: timestamptz
  iteration: smallint
  metadata_uri: String
  op_hash: String
}

"""
order by min() on columns of table "article_revision"
"""
input article_revision_min_order_by {
  article_id: order_by
  created_at: order_by
  iteration: order_by
  metadata_uri: order_by
  op_hash: order_by
}

"""
response of any mutation on the table "article_revision"
"""
type article_revision_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [article_revision!]!
}

"""
on_conflict condition type for table "article_revision"
"""
input article_revision_on_conflict {
  constraint: article_revision_constraint!
  update_columns: [article_revision_update_column!]! = []
  where: article_revision_bool_exp
}

"""Ordering options when selecting data from "article_revision"."""
input article_revision_order_by {
  article: article_order_by
  article_id: order_by
  created_at: order_by
  iteration: order_by
  metadata_uri: order_by
  op_hash: order_by
}

"""primary key columns input for table: article_revision"""
input article_revision_pk_columns_input {
  article_id: Int!
  iteration: smallint!
}

"""
select columns of table "article_revision"
"""
enum article_revision_select_column {
  """column name"""
  article_id

  """column name"""
  created_at

  """column name"""
  iteration

  """column name"""
  metadata_uri

  """column name"""
  op_hash
}

"""
input type for updating data in table "article_revision"
"""
input article_revision_set_input {
  article_id: Int
  created_at: timestamptz
  iteration: smallint
  metadata_uri: String
  op_hash: String
}

"""aggregate stddev on columns"""
type article_revision_stddev_fields {
  article_id: Float
  iteration: Float
}

"""
order by stddev() on columns of table "article_revision"
"""
input article_revision_stddev_order_by {
  article_id: order_by
  iteration: order_by
}

"""aggregate stddev_pop on columns"""
type article_revision_stddev_pop_fields {
  article_id: Float
  iteration: Float
}

"""
order by stddev_pop() on columns of table "article_revision"
"""
input article_revision_stddev_pop_order_by {
  article_id: order_by
  iteration: order_by
}

"""aggregate stddev_samp on columns"""
type article_revision_stddev_samp_fields {
  article_id: Float
  iteration: Float
}

"""
order by stddev_samp() on columns of table "article_revision"
"""
input article_revision_stddev_samp_order_by {
  article_id: order_by
  iteration: order_by
}

"""
Streaming cursor of the table "article_revision"
"""
input article_revision_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: article_revision_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input article_revision_stream_cursor_value_input {
  article_id: Int
  created_at: timestamptz
  iteration: smallint
  metadata_uri: String
  op_hash: String
}

"""aggregate sum on columns"""
type article_revision_sum_fields {
  article_id: Int
  iteration: smallint
}

"""
order by sum() on columns of table "article_revision"
"""
input article_revision_sum_order_by {
  article_id: order_by
  iteration: order_by
}

"""
update columns of table "article_revision"
"""
enum article_revision_update_column {
  """column name"""
  article_id

  """column name"""
  created_at

  """column name"""
  iteration

  """column name"""
  metadata_uri

  """column name"""
  op_hash
}

input article_revision_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: article_revision_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: article_revision_set_input

  """filter the rows which have to be updated"""
  where: article_revision_bool_exp!
}

"""aggregate var_pop on columns"""
type article_revision_var_pop_fields {
  article_id: Float
  iteration: Float
}

"""
order by var_pop() on columns of table "article_revision"
"""
input article_revision_var_pop_order_by {
  article_id: order_by
  iteration: order_by
}

"""aggregate var_samp on columns"""
type article_revision_var_samp_fields {
  article_id: Float
  iteration: Float
}

"""
order by var_samp() on columns of table "article_revision"
"""
input article_revision_var_samp_order_by {
  article_id: order_by
  iteration: order_by
}

"""aggregate variance on columns"""
type article_revision_variance_fields {
  article_id: Float
  iteration: Float
}

"""
order by variance() on columns of table "article_revision"
"""
input article_revision_variance_order_by {
  article_id: order_by
  iteration: order_by
}

"""
select columns of table "article"
"""
enum article_select_column {
  """column name"""
  artifact_uri

  """column name"""
  author_id

  """column name"""
  body

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  display_uri

  """column name"""
  editions

  """column name"""
  flag

  """column name"""
  id

  """column name"""
  language

  """column name"""
  metadata

  """column name"""
  metadata_locked

  """column name"""
  metadata_uri

  """column name"""
  mint_op_hash

  """column name"""
  moderation_reason_id

  """column name"""
  platforms

  """column name"""
  royalties

  """column name"""
  slug

  """column name"""
  tags

  """column name"""
  thumbnailMediaId

  """column name"""
  thumbnail_caption

  """column name"""
  thumbnail_uri

  """column name"""
  title
}

"""
select "article_aggregate_bool_exp_bool_and_arguments_columns" columns of table "article"
"""
enum article_select_column_article_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  metadata_locked
}

"""
select "article_aggregate_bool_exp_bool_or_arguments_columns" columns of table "article"
"""
enum article_select_column_article_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  metadata_locked
}

"""
input type for updating data in table "article"
"""
input article_set_input {
  artifact_uri: String
  author_id: String
  body: String
  created_at: timestamptz
  description: String
  display_uri: String
  editions: bigint
  flag: article_flag_enum
  id: Int
  language: String
  metadata: json
  metadata_locked: Boolean
  metadata_uri: String
  mint_op_hash: String
  moderation_reason_id: String
  platforms: _text
  royalties: Int
  slug: String
  tags: _text
  thumbnailMediaId: bpchar
  thumbnail_caption: String
  thumbnail_uri: String
  title: String
}

"""aggregate stddev on columns"""
type article_stddev_fields {
  editions: Float
  id: Float
  royalties: Float
}

"""
order by stddev() on columns of table "article"
"""
input article_stddev_order_by {
  editions: order_by
  id: order_by
  royalties: order_by
}

"""aggregate stddev_pop on columns"""
type article_stddev_pop_fields {
  editions: Float
  id: Float
  royalties: Float
}

"""
order by stddev_pop() on columns of table "article"
"""
input article_stddev_pop_order_by {
  editions: order_by
  id: order_by
  royalties: order_by
}

"""aggregate stddev_samp on columns"""
type article_stddev_samp_fields {
  editions: Float
  id: Float
  royalties: Float
}

"""
order by stddev_samp() on columns of table "article"
"""
input article_stddev_samp_order_by {
  editions: order_by
  id: order_by
  royalties: order_by
}

"""
Streaming cursor of the table "article"
"""
input article_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: article_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input article_stream_cursor_value_input {
  artifact_uri: String
  author_id: String
  body: String
  created_at: timestamptz
  description: String
  display_uri: String
  editions: bigint
  flag: article_flag_enum
  id: Int
  language: String
  metadata: json
  metadata_locked: Boolean
  metadata_uri: String
  mint_op_hash: String
  moderation_reason_id: String
  platforms: _text
  royalties: Int
  slug: String
  tags: _text
  thumbnailMediaId: bpchar
  thumbnail_caption: String
  thumbnail_uri: String
  title: String
}

"""aggregate sum on columns"""
type article_sum_fields {
  editions: bigint
  id: Int
  royalties: Int
}

"""
order by sum() on columns of table "article"
"""
input article_sum_order_by {
  editions: order_by
  id: order_by
  royalties: order_by
}

"""
update columns of table "article"
"""
enum article_update_column {
  """column name"""
  artifact_uri

  """column name"""
  author_id

  """column name"""
  body

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  display_uri

  """column name"""
  editions

  """column name"""
  flag

  """column name"""
  id

  """column name"""
  language

  """column name"""
  metadata

  """column name"""
  metadata_locked

  """column name"""
  metadata_uri

  """column name"""
  mint_op_hash

  """column name"""
  moderation_reason_id

  """column name"""
  platforms

  """column name"""
  royalties

  """column name"""
  slug

  """column name"""
  tags

  """column name"""
  thumbnailMediaId

  """column name"""
  thumbnail_caption

  """column name"""
  thumbnail_uri

  """column name"""
  title
}

input article_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: article_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: article_set_input

  """filter the rows which have to be updated"""
  where: article_bool_exp!
}

"""aggregate var_pop on columns"""
type article_var_pop_fields {
  editions: Float
  id: Float
  royalties: Float
}

"""
order by var_pop() on columns of table "article"
"""
input article_var_pop_order_by {
  editions: order_by
  id: order_by
  royalties: order_by
}

"""aggregate var_samp on columns"""
type article_var_samp_fields {
  editions: Float
  id: Float
  royalties: Float
}

"""
order by var_samp() on columns of table "article"
"""
input article_var_samp_order_by {
  editions: order_by
  id: order_by
  royalties: order_by
}

"""aggregate variance on columns"""
type article_variance_fields {
  editions: Float
  id: Float
  royalties: Float
}

"""
order by variance() on columns of table "article"
"""
input article_variance_order_by {
  editions: order_by
  id: order_by
  royalties: order_by
}

"""
columns and relationships of "auction"
"""
type auction {
  """An object relationship"""
  auction_bid_table: auction_bid_table

  """An array relationship"""
  auction_bids(
    """distinct select on columns"""
    distinct_on: [auction_bid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_order_by!]

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): [auction_bid!]!

  """An aggregate relationship"""
  auction_bids_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_bid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_order_by!]

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): auction_bid_aggregate!
  bid_table_id: Int
  bid_time_increment: Int!
  cancelled_at: timestamptz
  created_at: timestamptz!
  ends_at: timestamptz
  fulfilled_at: timestamptz
  id: Int!
  min_duration: Int!

  """An object relationship"""
  objkt: objkt
  objkt_id: String
  objkt_issuer_version: generative_token_version
  reserve_price: bigint!
  seller_id: String

  """An object relationship"""
  user: user
  version: Int!
}

"""
aggregated selection of "auction"
"""
type auction_aggregate {
  aggregate: auction_aggregate_fields
  nodes: [auction!]!
}

input auction_aggregate_bool_exp {
  count: auction_aggregate_bool_exp_count
}

input auction_aggregate_bool_exp_count {
  arguments: [auction_select_column!]
  distinct: Boolean
  filter: auction_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auction"
"""
type auction_aggregate_fields {
  avg: auction_avg_fields
  count(columns: [auction_select_column!], distinct: Boolean): Int!
  max: auction_max_fields
  min: auction_min_fields
  stddev: auction_stddev_fields
  stddev_pop: auction_stddev_pop_fields
  stddev_samp: auction_stddev_samp_fields
  sum: auction_sum_fields
  var_pop: auction_var_pop_fields
  var_samp: auction_var_samp_fields
  variance: auction_variance_fields
}

"""
order by aggregate values of table "auction"
"""
input auction_aggregate_order_by {
  avg: auction_avg_order_by
  count: order_by
  max: auction_max_order_by
  min: auction_min_order_by
  stddev: auction_stddev_order_by
  stddev_pop: auction_stddev_pop_order_by
  stddev_samp: auction_stddev_samp_order_by
  sum: auction_sum_order_by
  var_pop: auction_var_pop_order_by
  var_samp: auction_var_samp_order_by
  variance: auction_variance_order_by
}

"""
input type for inserting array relation for remote table "auction"
"""
input auction_arr_rel_insert_input {
  data: [auction_insert_input!]!

  """upsert condition"""
  on_conflict: auction_on_conflict
}

"""aggregate avg on columns"""
type auction_avg_fields {
  bid_table_id: Float
  bid_time_increment: Float
  id: Float
  min_duration: Float
  reserve_price: Float
  version: Float
}

"""
order by avg() on columns of table "auction"
"""
input auction_avg_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  id: order_by
  min_duration: order_by
  reserve_price: order_by
  version: order_by
}

"""
columns and relationships of "auction_bid"
"""
type auction_bid {
  """An object relationship"""
  auction: auction
  auction_id: Int
  auction_version: Int
  bidder_id: String
  created_at: timestamptz!
  id: uuid!
  price: numeric!

  """An object relationship"""
  user: user
}

"""
aggregated selection of "auction_bid"
"""
type auction_bid_aggregate {
  aggregate: auction_bid_aggregate_fields
  nodes: [auction_bid!]!
}

input auction_bid_aggregate_bool_exp {
  count: auction_bid_aggregate_bool_exp_count
}

input auction_bid_aggregate_bool_exp_count {
  arguments: [auction_bid_select_column!]
  distinct: Boolean
  filter: auction_bid_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "auction_bid"
"""
type auction_bid_aggregate_fields {
  avg: auction_bid_avg_fields
  count(columns: [auction_bid_select_column!], distinct: Boolean): Int!
  max: auction_bid_max_fields
  min: auction_bid_min_fields
  stddev: auction_bid_stddev_fields
  stddev_pop: auction_bid_stddev_pop_fields
  stddev_samp: auction_bid_stddev_samp_fields
  sum: auction_bid_sum_fields
  var_pop: auction_bid_var_pop_fields
  var_samp: auction_bid_var_samp_fields
  variance: auction_bid_variance_fields
}

"""
order by aggregate values of table "auction_bid"
"""
input auction_bid_aggregate_order_by {
  avg: auction_bid_avg_order_by
  count: order_by
  max: auction_bid_max_order_by
  min: auction_bid_min_order_by
  stddev: auction_bid_stddev_order_by
  stddev_pop: auction_bid_stddev_pop_order_by
  stddev_samp: auction_bid_stddev_samp_order_by
  sum: auction_bid_sum_order_by
  var_pop: auction_bid_var_pop_order_by
  var_samp: auction_bid_var_samp_order_by
  variance: auction_bid_variance_order_by
}

"""
input type for inserting array relation for remote table "auction_bid"
"""
input auction_bid_arr_rel_insert_input {
  data: [auction_bid_insert_input!]!

  """upsert condition"""
  on_conflict: auction_bid_on_conflict
}

"""aggregate avg on columns"""
type auction_bid_avg_fields {
  auction_id: Float
  auction_version: Float
  price: Float
}

"""
order by avg() on columns of table "auction_bid"
"""
input auction_bid_avg_order_by {
  auction_id: order_by
  auction_version: order_by
  price: order_by
}

"""
Boolean expression to filter rows from the table "auction_bid". All fields are combined with a logical 'AND'.
"""
input auction_bid_bool_exp {
  _and: [auction_bid_bool_exp!]
  _not: auction_bid_bool_exp
  _or: [auction_bid_bool_exp!]
  auction: auction_bool_exp
  auction_id: Int_comparison_exp
  auction_version: Int_comparison_exp
  bidder_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  price: numeric_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "auction_bid"
"""
enum auction_bid_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_bb11c1cfa7707fac20673b28ef5
}

"""
input type for incrementing numeric columns in table "auction_bid"
"""
input auction_bid_inc_input {
  auction_id: Int
  auction_version: Int
  price: numeric
}

"""
input type for inserting data into table "auction_bid"
"""
input auction_bid_insert_input {
  auction: auction_obj_rel_insert_input
  auction_id: Int
  auction_version: Int
  bidder_id: String
  created_at: timestamptz
  id: uuid
  price: numeric
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type auction_bid_max_fields {
  auction_id: Int
  auction_version: Int
  bidder_id: String
  created_at: timestamptz
  id: uuid
  price: numeric
}

"""
order by max() on columns of table "auction_bid"
"""
input auction_bid_max_order_by {
  auction_id: order_by
  auction_version: order_by
  bidder_id: order_by
  created_at: order_by
  id: order_by
  price: order_by
}

"""aggregate min on columns"""
type auction_bid_min_fields {
  auction_id: Int
  auction_version: Int
  bidder_id: String
  created_at: timestamptz
  id: uuid
  price: numeric
}

"""
order by min() on columns of table "auction_bid"
"""
input auction_bid_min_order_by {
  auction_id: order_by
  auction_version: order_by
  bidder_id: order_by
  created_at: order_by
  id: order_by
  price: order_by
}

"""
response of any mutation on the table "auction_bid"
"""
type auction_bid_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auction_bid!]!
}

"""
on_conflict condition type for table "auction_bid"
"""
input auction_bid_on_conflict {
  constraint: auction_bid_constraint!
  update_columns: [auction_bid_update_column!]! = []
  where: auction_bid_bool_exp
}

"""Ordering options when selecting data from "auction_bid"."""
input auction_bid_order_by {
  auction: auction_order_by
  auction_id: order_by
  auction_version: order_by
  bidder_id: order_by
  created_at: order_by
  id: order_by
  price: order_by
  user: user_order_by
}

"""primary key columns input for table: auction_bid"""
input auction_bid_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auction_bid"
"""
enum auction_bid_select_column {
  """column name"""
  auction_id

  """column name"""
  auction_version

  """column name"""
  bidder_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  price
}

"""
input type for updating data in table "auction_bid"
"""
input auction_bid_set_input {
  auction_id: Int
  auction_version: Int
  bidder_id: String
  created_at: timestamptz
  id: uuid
  price: numeric
}

"""aggregate stddev on columns"""
type auction_bid_stddev_fields {
  auction_id: Float
  auction_version: Float
  price: Float
}

"""
order by stddev() on columns of table "auction_bid"
"""
input auction_bid_stddev_order_by {
  auction_id: order_by
  auction_version: order_by
  price: order_by
}

"""aggregate stddev_pop on columns"""
type auction_bid_stddev_pop_fields {
  auction_id: Float
  auction_version: Float
  price: Float
}

"""
order by stddev_pop() on columns of table "auction_bid"
"""
input auction_bid_stddev_pop_order_by {
  auction_id: order_by
  auction_version: order_by
  price: order_by
}

"""aggregate stddev_samp on columns"""
type auction_bid_stddev_samp_fields {
  auction_id: Float
  auction_version: Float
  price: Float
}

"""
order by stddev_samp() on columns of table "auction_bid"
"""
input auction_bid_stddev_samp_order_by {
  auction_id: order_by
  auction_version: order_by
  price: order_by
}

"""
Streaming cursor of the table "auction_bid"
"""
input auction_bid_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auction_bid_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auction_bid_stream_cursor_value_input {
  auction_id: Int
  auction_version: Int
  bidder_id: String
  created_at: timestamptz
  id: uuid
  price: numeric
}

"""aggregate sum on columns"""
type auction_bid_sum_fields {
  auction_id: Int
  auction_version: Int
  price: numeric
}

"""
order by sum() on columns of table "auction_bid"
"""
input auction_bid_sum_order_by {
  auction_id: order_by
  auction_version: order_by
  price: order_by
}

"""
columns and relationships of "auction_bid_table"
"""
type auction_bid_table {
  """An array relationship"""
  auctions(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): [auction!]!

  """An aggregate relationship"""
  auctions_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): auction_aggregate!
  id: Int!
  table(
    """JSON select path"""
    path: String
  ): jsonb!
}

"""
aggregated selection of "auction_bid_table"
"""
type auction_bid_table_aggregate {
  aggregate: auction_bid_table_aggregate_fields
  nodes: [auction_bid_table!]!
}

"""
aggregate fields of "auction_bid_table"
"""
type auction_bid_table_aggregate_fields {
  avg: auction_bid_table_avg_fields
  count(columns: [auction_bid_table_select_column!], distinct: Boolean): Int!
  max: auction_bid_table_max_fields
  min: auction_bid_table_min_fields
  stddev: auction_bid_table_stddev_fields
  stddev_pop: auction_bid_table_stddev_pop_fields
  stddev_samp: auction_bid_table_stddev_samp_fields
  sum: auction_bid_table_sum_fields
  var_pop: auction_bid_table_var_pop_fields
  var_samp: auction_bid_table_var_samp_fields
  variance: auction_bid_table_variance_fields
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auction_bid_table_append_input {
  table: jsonb
}

"""aggregate avg on columns"""
type auction_bid_table_avg_fields {
  id: Float
}

"""
Boolean expression to filter rows from the table "auction_bid_table". All fields are combined with a logical 'AND'.
"""
input auction_bid_table_bool_exp {
  _and: [auction_bid_table_bool_exp!]
  _not: auction_bid_table_bool_exp
  _or: [auction_bid_table_bool_exp!]
  auctions: auction_bool_exp
  auctions_aggregate: auction_aggregate_bool_exp
  id: Int_comparison_exp
  table: jsonb_comparison_exp
}

"""
unique or primary key constraints on table "auction_bid_table"
"""
enum auction_bid_table_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_57b09fff66c5df1611c7b595a10
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auction_bid_table_delete_at_path_input {
  table: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auction_bid_table_delete_elem_input {
  table: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auction_bid_table_delete_key_input {
  table: String
}

"""
input type for incrementing numeric columns in table "auction_bid_table"
"""
input auction_bid_table_inc_input {
  id: Int
}

"""
input type for inserting data into table "auction_bid_table"
"""
input auction_bid_table_insert_input {
  auctions: auction_arr_rel_insert_input
  id: Int
  table: jsonb
}

"""aggregate max on columns"""
type auction_bid_table_max_fields {
  id: Int
}

"""aggregate min on columns"""
type auction_bid_table_min_fields {
  id: Int
}

"""
response of any mutation on the table "auction_bid_table"
"""
type auction_bid_table_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auction_bid_table!]!
}

"""
input type for inserting object relation for remote table "auction_bid_table"
"""
input auction_bid_table_obj_rel_insert_input {
  data: auction_bid_table_insert_input!

  """upsert condition"""
  on_conflict: auction_bid_table_on_conflict
}

"""
on_conflict condition type for table "auction_bid_table"
"""
input auction_bid_table_on_conflict {
  constraint: auction_bid_table_constraint!
  update_columns: [auction_bid_table_update_column!]! = []
  where: auction_bid_table_bool_exp
}

"""Ordering options when selecting data from "auction_bid_table"."""
input auction_bid_table_order_by {
  auctions_aggregate: auction_aggregate_order_by
  id: order_by
  table: order_by
}

"""primary key columns input for table: auction_bid_table"""
input auction_bid_table_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auction_bid_table_prepend_input {
  table: jsonb
}

"""
select columns of table "auction_bid_table"
"""
enum auction_bid_table_select_column {
  """column name"""
  id

  """column name"""
  table
}

"""
input type for updating data in table "auction_bid_table"
"""
input auction_bid_table_set_input {
  id: Int
  table: jsonb
}

"""aggregate stddev on columns"""
type auction_bid_table_stddev_fields {
  id: Float
}

"""aggregate stddev_pop on columns"""
type auction_bid_table_stddev_pop_fields {
  id: Float
}

"""aggregate stddev_samp on columns"""
type auction_bid_table_stddev_samp_fields {
  id: Float
}

"""
Streaming cursor of the table "auction_bid_table"
"""
input auction_bid_table_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auction_bid_table_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auction_bid_table_stream_cursor_value_input {
  id: Int
  table: jsonb
}

"""aggregate sum on columns"""
type auction_bid_table_sum_fields {
  id: Int
}

"""
update columns of table "auction_bid_table"
"""
enum auction_bid_table_update_column {
  """column name"""
  id

  """column name"""
  table
}

input auction_bid_table_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: auction_bid_table_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: auction_bid_table_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: auction_bid_table_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: auction_bid_table_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: auction_bid_table_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: auction_bid_table_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: auction_bid_table_set_input

  """filter the rows which have to be updated"""
  where: auction_bid_table_bool_exp!
}

"""aggregate var_pop on columns"""
type auction_bid_table_var_pop_fields {
  id: Float
}

"""aggregate var_samp on columns"""
type auction_bid_table_var_samp_fields {
  id: Float
}

"""aggregate variance on columns"""
type auction_bid_table_variance_fields {
  id: Float
}

"""
update columns of table "auction_bid"
"""
enum auction_bid_update_column {
  """column name"""
  auction_id

  """column name"""
  auction_version

  """column name"""
  bidder_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  price
}

input auction_bid_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: auction_bid_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: auction_bid_set_input

  """filter the rows which have to be updated"""
  where: auction_bid_bool_exp!
}

"""aggregate var_pop on columns"""
type auction_bid_var_pop_fields {
  auction_id: Float
  auction_version: Float
  price: Float
}

"""
order by var_pop() on columns of table "auction_bid"
"""
input auction_bid_var_pop_order_by {
  auction_id: order_by
  auction_version: order_by
  price: order_by
}

"""aggregate var_samp on columns"""
type auction_bid_var_samp_fields {
  auction_id: Float
  auction_version: Float
  price: Float
}

"""
order by var_samp() on columns of table "auction_bid"
"""
input auction_bid_var_samp_order_by {
  auction_id: order_by
  auction_version: order_by
  price: order_by
}

"""aggregate variance on columns"""
type auction_bid_variance_fields {
  auction_id: Float
  auction_version: Float
  price: Float
}

"""
order by variance() on columns of table "auction_bid"
"""
input auction_bid_variance_order_by {
  auction_id: order_by
  auction_version: order_by
  price: order_by
}

"""
Boolean expression to filter rows from the table "auction". All fields are combined with a logical 'AND'.
"""
input auction_bool_exp {
  _and: [auction_bool_exp!]
  _not: auction_bool_exp
  _or: [auction_bool_exp!]
  auction_bid_table: auction_bid_table_bool_exp
  auction_bids: auction_bid_bool_exp
  auction_bids_aggregate: auction_bid_aggregate_bool_exp
  bid_table_id: Int_comparison_exp
  bid_time_increment: Int_comparison_exp
  cancelled_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  ends_at: timestamptz_comparison_exp
  fulfilled_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  min_duration: Int_comparison_exp
  objkt: objkt_bool_exp
  objkt_id: String_comparison_exp
  objkt_issuer_version: generative_token_version_comparison_exp
  reserve_price: bigint_comparison_exp
  seller_id: String_comparison_exp
  user: user_bool_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "auction"
"""
enum auction_constraint {
  """
  unique or primary key constraint on columns "id", "version"
  """
  PK_b15570c9d210ca79ad2c9b4e398
}

"""
input type for incrementing numeric columns in table "auction"
"""
input auction_inc_input {
  bid_table_id: Int
  bid_time_increment: Int
  id: Int
  min_duration: Int
  reserve_price: bigint
  version: Int
}

"""
input type for inserting data into table "auction"
"""
input auction_insert_input {
  auction_bid_table: auction_bid_table_obj_rel_insert_input
  auction_bids: auction_bid_arr_rel_insert_input
  bid_table_id: Int
  bid_time_increment: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  ends_at: timestamptz
  fulfilled_at: timestamptz
  id: Int
  min_duration: Int
  objkt: objkt_obj_rel_insert_input
  objkt_id: String
  objkt_issuer_version: generative_token_version
  reserve_price: bigint
  seller_id: String
  user: user_obj_rel_insert_input
  version: Int
}

"""aggregate max on columns"""
type auction_max_fields {
  bid_table_id: Int
  bid_time_increment: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  ends_at: timestamptz
  fulfilled_at: timestamptz
  id: Int
  min_duration: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  reserve_price: bigint
  seller_id: String
  version: Int
}

"""
order by max() on columns of table "auction"
"""
input auction_max_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  cancelled_at: order_by
  created_at: order_by
  ends_at: order_by
  fulfilled_at: order_by
  id: order_by
  min_duration: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  reserve_price: order_by
  seller_id: order_by
  version: order_by
}

"""aggregate min on columns"""
type auction_min_fields {
  bid_table_id: Int
  bid_time_increment: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  ends_at: timestamptz
  fulfilled_at: timestamptz
  id: Int
  min_duration: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  reserve_price: bigint
  seller_id: String
  version: Int
}

"""
order by min() on columns of table "auction"
"""
input auction_min_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  cancelled_at: order_by
  created_at: order_by
  ends_at: order_by
  fulfilled_at: order_by
  id: order_by
  min_duration: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  reserve_price: order_by
  seller_id: order_by
  version: order_by
}

"""
response of any mutation on the table "auction"
"""
type auction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [auction!]!
}

"""
input type for inserting object relation for remote table "auction"
"""
input auction_obj_rel_insert_input {
  data: auction_insert_input!

  """upsert condition"""
  on_conflict: auction_on_conflict
}

"""
on_conflict condition type for table "auction"
"""
input auction_on_conflict {
  constraint: auction_constraint!
  update_columns: [auction_update_column!]! = []
  where: auction_bool_exp
}

"""Ordering options when selecting data from "auction"."""
input auction_order_by {
  auction_bid_table: auction_bid_table_order_by
  auction_bids_aggregate: auction_bid_aggregate_order_by
  bid_table_id: order_by
  bid_time_increment: order_by
  cancelled_at: order_by
  created_at: order_by
  ends_at: order_by
  fulfilled_at: order_by
  id: order_by
  min_duration: order_by
  objkt: objkt_order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  reserve_price: order_by
  seller_id: order_by
  user: user_order_by
  version: order_by
}

"""primary key columns input for table: auction"""
input auction_pk_columns_input {
  id: Int!
  version: Int!
}

"""
select columns of table "auction"
"""
enum auction_select_column {
  """column name"""
  bid_table_id

  """column name"""
  bid_time_increment

  """column name"""
  cancelled_at

  """column name"""
  created_at

  """column name"""
  ends_at

  """column name"""
  fulfilled_at

  """column name"""
  id

  """column name"""
  min_duration

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  reserve_price

  """column name"""
  seller_id

  """column name"""
  version
}

"""
input type for updating data in table "auction"
"""
input auction_set_input {
  bid_table_id: Int
  bid_time_increment: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  ends_at: timestamptz
  fulfilled_at: timestamptz
  id: Int
  min_duration: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  reserve_price: bigint
  seller_id: String
  version: Int
}

"""aggregate stddev on columns"""
type auction_stddev_fields {
  bid_table_id: Float
  bid_time_increment: Float
  id: Float
  min_duration: Float
  reserve_price: Float
  version: Float
}

"""
order by stddev() on columns of table "auction"
"""
input auction_stddev_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  id: order_by
  min_duration: order_by
  reserve_price: order_by
  version: order_by
}

"""aggregate stddev_pop on columns"""
type auction_stddev_pop_fields {
  bid_table_id: Float
  bid_time_increment: Float
  id: Float
  min_duration: Float
  reserve_price: Float
  version: Float
}

"""
order by stddev_pop() on columns of table "auction"
"""
input auction_stddev_pop_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  id: order_by
  min_duration: order_by
  reserve_price: order_by
  version: order_by
}

"""aggregate stddev_samp on columns"""
type auction_stddev_samp_fields {
  bid_table_id: Float
  bid_time_increment: Float
  id: Float
  min_duration: Float
  reserve_price: Float
  version: Float
}

"""
order by stddev_samp() on columns of table "auction"
"""
input auction_stddev_samp_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  id: order_by
  min_duration: order_by
  reserve_price: order_by
  version: order_by
}

"""
Streaming cursor of the table "auction"
"""
input auction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: auction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input auction_stream_cursor_value_input {
  bid_table_id: Int
  bid_time_increment: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  ends_at: timestamptz
  fulfilled_at: timestamptz
  id: Int
  min_duration: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  reserve_price: bigint
  seller_id: String
  version: Int
}

"""aggregate sum on columns"""
type auction_sum_fields {
  bid_table_id: Int
  bid_time_increment: Int
  id: Int
  min_duration: Int
  reserve_price: bigint
  version: Int
}

"""
order by sum() on columns of table "auction"
"""
input auction_sum_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  id: order_by
  min_duration: order_by
  reserve_price: order_by
  version: order_by
}

"""
update columns of table "auction"
"""
enum auction_update_column {
  """column name"""
  bid_table_id

  """column name"""
  bid_time_increment

  """column name"""
  cancelled_at

  """column name"""
  created_at

  """column name"""
  ends_at

  """column name"""
  fulfilled_at

  """column name"""
  id

  """column name"""
  min_duration

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  reserve_price

  """column name"""
  seller_id

  """column name"""
  version
}

input auction_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: auction_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: auction_set_input

  """filter the rows which have to be updated"""
  where: auction_bool_exp!
}

"""aggregate var_pop on columns"""
type auction_var_pop_fields {
  bid_table_id: Float
  bid_time_increment: Float
  id: Float
  min_duration: Float
  reserve_price: Float
  version: Float
}

"""
order by var_pop() on columns of table "auction"
"""
input auction_var_pop_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  id: order_by
  min_duration: order_by
  reserve_price: order_by
  version: order_by
}

"""aggregate var_samp on columns"""
type auction_var_samp_fields {
  bid_table_id: Float
  bid_time_increment: Float
  id: Float
  min_duration: Float
  reserve_price: Float
  version: Float
}

"""
order by var_samp() on columns of table "auction"
"""
input auction_var_samp_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  id: order_by
  min_duration: order_by
  reserve_price: order_by
  version: order_by
}

"""aggregate variance on columns"""
type auction_variance_fields {
  bid_table_id: Float
  bid_time_increment: Float
  id: Float
  min_duration: Float
  reserve_price: Float
  version: Float
}

"""
order by variance() on columns of table "auction"
"""
input auction_variance_order_by {
  bid_table_id: order_by
  bid_time_increment: order_by
  id: order_by
  min_duration: order_by
  reserve_price: order_by
  version: order_by
}

scalar bigint

"""
Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'.
"""
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

scalar bpchar

"""
Boolean expression to compare columns of type "bpchar". All fields are combined with logical 'AND'.
"""
input bpchar_comparison_exp {
  _eq: bpchar
  _gt: bpchar
  _gte: bpchar

  """does the column match the given case-insensitive pattern"""
  _ilike: bpchar
  _in: [bpchar!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: bpchar
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: bpchar
  _lt: bpchar
  _lte: bpchar
  _neq: bpchar

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: bpchar
  _nin: [bpchar!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: bpchar

  """does the column NOT match the given pattern"""
  _nlike: bpchar

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: bpchar

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: bpchar

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: bpchar

  """does the column match the given SQL regular expression"""
  _similar: bpchar
}

"""
columns and relationships of "codex"
"""
type codex {
  author_id: String!

  """An array relationship"""
  generative_tokens(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): [generative_token!]!

  """An aggregate relationship"""
  generative_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): generative_token_aggregate!
  id: String!
  locked: Boolean!
  token_version: generative_token_version!
  type: codex_type_enum!

  """An object relationship"""
  user: user!
  value: String
}

"""
aggregated selection of "codex"
"""
type codex_aggregate {
  aggregate: codex_aggregate_fields
  nodes: [codex!]!
}

input codex_aggregate_bool_exp {
  bool_and: codex_aggregate_bool_exp_bool_and
  bool_or: codex_aggregate_bool_exp_bool_or
  count: codex_aggregate_bool_exp_count
}

input codex_aggregate_bool_exp_bool_and {
  arguments: codex_select_column_codex_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: codex_bool_exp
  predicate: Boolean_comparison_exp!
}

input codex_aggregate_bool_exp_bool_or {
  arguments: codex_select_column_codex_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: codex_bool_exp
  predicate: Boolean_comparison_exp!
}

input codex_aggregate_bool_exp_count {
  arguments: [codex_select_column!]
  distinct: Boolean
  filter: codex_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "codex"
"""
type codex_aggregate_fields {
  count(columns: [codex_select_column!], distinct: Boolean): Int!
  max: codex_max_fields
  min: codex_min_fields
}

"""
order by aggregate values of table "codex"
"""
input codex_aggregate_order_by {
  count: order_by
  max: codex_max_order_by
  min: codex_min_order_by
}

"""
input type for inserting array relation for remote table "codex"
"""
input codex_arr_rel_insert_input {
  data: [codex_insert_input!]!

  """upsert condition"""
  on_conflict: codex_on_conflict
}

"""
Boolean expression to filter rows from the table "codex". All fields are combined with a logical 'AND'.
"""
input codex_bool_exp {
  _and: [codex_bool_exp!]
  _not: codex_bool_exp
  _or: [codex_bool_exp!]
  author_id: String_comparison_exp
  generative_tokens: generative_token_bool_exp
  generative_tokens_aggregate: generative_token_aggregate_bool_exp
  id: String_comparison_exp
  locked: Boolean_comparison_exp
  token_version: generative_token_version_comparison_exp
  type: codex_type_enum_comparison_exp
  user: user_bool_exp
  value: String_comparison_exp
}

"""
unique or primary key constraints on table "codex"
"""
enum codex_constraint {
  """
  unique or primary key constraint on columns "id", "token_version"
  """
  PK_c3191249ea093f9859ee0d383c1
}

"""
input type for inserting data into table "codex"
"""
input codex_insert_input {
  author_id: String
  generative_tokens: generative_token_arr_rel_insert_input
  id: String
  locked: Boolean
  token_version: generative_token_version
  type: codex_type_enum
  user: user_obj_rel_insert_input
  value: String
}

"""aggregate max on columns"""
type codex_max_fields {
  author_id: String
  id: String
  token_version: generative_token_version
  type: codex_type_enum
  value: String
}

"""
order by max() on columns of table "codex"
"""
input codex_max_order_by {
  author_id: order_by
  id: order_by
  token_version: order_by
  type: order_by
  value: order_by
}

"""aggregate min on columns"""
type codex_min_fields {
  author_id: String
  id: String
  token_version: generative_token_version
  type: codex_type_enum
  value: String
}

"""
order by min() on columns of table "codex"
"""
input codex_min_order_by {
  author_id: order_by
  id: order_by
  token_version: order_by
  type: order_by
  value: order_by
}

"""
response of any mutation on the table "codex"
"""
type codex_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [codex!]!
}

"""
input type for inserting object relation for remote table "codex"
"""
input codex_obj_rel_insert_input {
  data: codex_insert_input!

  """upsert condition"""
  on_conflict: codex_on_conflict
}

"""
on_conflict condition type for table "codex"
"""
input codex_on_conflict {
  constraint: codex_constraint!
  update_columns: [codex_update_column!]! = []
  where: codex_bool_exp
}

"""Ordering options when selecting data from "codex"."""
input codex_order_by {
  author_id: order_by
  generative_tokens_aggregate: generative_token_aggregate_order_by
  id: order_by
  locked: order_by
  token_version: order_by
  type: order_by
  user: user_order_by
  value: order_by
}

"""primary key columns input for table: codex"""
input codex_pk_columns_input {
  id: String!
  token_version: generative_token_version!
}

"""
select columns of table "codex"
"""
enum codex_select_column {
  """column name"""
  author_id

  """column name"""
  id

  """column name"""
  locked

  """column name"""
  token_version

  """column name"""
  type

  """column name"""
  value
}

"""
select "codex_aggregate_bool_exp_bool_and_arguments_columns" columns of table "codex"
"""
enum codex_select_column_codex_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  locked
}

"""
select "codex_aggregate_bool_exp_bool_or_arguments_columns" columns of table "codex"
"""
enum codex_select_column_codex_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  locked
}

"""
input type for updating data in table "codex"
"""
input codex_set_input {
  author_id: String
  id: String
  locked: Boolean
  token_version: generative_token_version
  type: codex_type_enum
  value: String
}

"""
Streaming cursor of the table "codex"
"""
input codex_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: codex_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input codex_stream_cursor_value_input {
  author_id: String
  id: String
  locked: Boolean
  token_version: generative_token_version
  type: codex_type_enum
  value: String
}

scalar codex_type_enum

"""
Boolean expression to compare columns of type "codex_type_enum". All fields are combined with logical 'AND'.
"""
input codex_type_enum_comparison_exp {
  _eq: codex_type_enum
  _gt: codex_type_enum
  _gte: codex_type_enum
  _in: [codex_type_enum!]
  _is_null: Boolean
  _lt: codex_type_enum
  _lte: codex_type_enum
  _neq: codex_type_enum
  _nin: [codex_type_enum!]
}

"""
update columns of table "codex"
"""
enum codex_update_column {
  """column name"""
  author_id

  """column name"""
  id

  """column name"""
  locked

  """column name"""
  token_version

  """column name"""
  type

  """column name"""
  value
}

"""
columns and relationships of "codex_update_request"
"""
type codex_update_request {
  codex_id: String!
  created_at: timestamptz!

  """An object relationship"""
  generative_token: generative_token!
  status: codex_update_request_status_enum!
  token_id: String!
  token_version: generative_token_version!
}

"""
aggregated selection of "codex_update_request"
"""
type codex_update_request_aggregate {
  aggregate: codex_update_request_aggregate_fields
  nodes: [codex_update_request!]!
}

input codex_update_request_aggregate_bool_exp {
  count: codex_update_request_aggregate_bool_exp_count
}

input codex_update_request_aggregate_bool_exp_count {
  arguments: [codex_update_request_select_column!]
  distinct: Boolean
  filter: codex_update_request_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "codex_update_request"
"""
type codex_update_request_aggregate_fields {
  count(columns: [codex_update_request_select_column!], distinct: Boolean): Int!
  max: codex_update_request_max_fields
  min: codex_update_request_min_fields
}

"""
order by aggregate values of table "codex_update_request"
"""
input codex_update_request_aggregate_order_by {
  count: order_by
  max: codex_update_request_max_order_by
  min: codex_update_request_min_order_by
}

"""
input type for inserting array relation for remote table "codex_update_request"
"""
input codex_update_request_arr_rel_insert_input {
  data: [codex_update_request_insert_input!]!

  """upsert condition"""
  on_conflict: codex_update_request_on_conflict
}

"""
Boolean expression to filter rows from the table "codex_update_request". All fields are combined with a logical 'AND'.
"""
input codex_update_request_bool_exp {
  _and: [codex_update_request_bool_exp!]
  _not: codex_update_request_bool_exp
  _or: [codex_update_request_bool_exp!]
  codex_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  generative_token: generative_token_bool_exp
  status: codex_update_request_status_enum_comparison_exp
  token_id: String_comparison_exp
  token_version: generative_token_version_comparison_exp
}

"""
unique or primary key constraints on table "codex_update_request"
"""
enum codex_update_request_constraint {
  """
  unique or primary key constraint on columns "token_id", "token_version", "codex_id"
  """
  PK_5841bafd692945d7920558190cd
}

"""
input type for inserting data into table "codex_update_request"
"""
input codex_update_request_insert_input {
  codex_id: String
  created_at: timestamptz
  generative_token: generative_token_obj_rel_insert_input
  status: codex_update_request_status_enum
  token_id: String
  token_version: generative_token_version
}

"""aggregate max on columns"""
type codex_update_request_max_fields {
  codex_id: String
  created_at: timestamptz
  status: codex_update_request_status_enum
  token_id: String
  token_version: generative_token_version
}

"""
order by max() on columns of table "codex_update_request"
"""
input codex_update_request_max_order_by {
  codex_id: order_by
  created_at: order_by
  status: order_by
  token_id: order_by
  token_version: order_by
}

"""aggregate min on columns"""
type codex_update_request_min_fields {
  codex_id: String
  created_at: timestamptz
  status: codex_update_request_status_enum
  token_id: String
  token_version: generative_token_version
}

"""
order by min() on columns of table "codex_update_request"
"""
input codex_update_request_min_order_by {
  codex_id: order_by
  created_at: order_by
  status: order_by
  token_id: order_by
  token_version: order_by
}

"""
response of any mutation on the table "codex_update_request"
"""
type codex_update_request_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [codex_update_request!]!
}

"""
on_conflict condition type for table "codex_update_request"
"""
input codex_update_request_on_conflict {
  constraint: codex_update_request_constraint!
  update_columns: [codex_update_request_update_column!]! = []
  where: codex_update_request_bool_exp
}

"""Ordering options when selecting data from "codex_update_request"."""
input codex_update_request_order_by {
  codex_id: order_by
  created_at: order_by
  generative_token: generative_token_order_by
  status: order_by
  token_id: order_by
  token_version: order_by
}

"""primary key columns input for table: codex_update_request"""
input codex_update_request_pk_columns_input {
  codex_id: String!
  token_id: String!
  token_version: generative_token_version!
}

"""
select columns of table "codex_update_request"
"""
enum codex_update_request_select_column {
  """column name"""
  codex_id

  """column name"""
  created_at

  """column name"""
  status

  """column name"""
  token_id

  """column name"""
  token_version
}

"""
input type for updating data in table "codex_update_request"
"""
input codex_update_request_set_input {
  codex_id: String
  created_at: timestamptz
  status: codex_update_request_status_enum
  token_id: String
  token_version: generative_token_version
}

scalar codex_update_request_status_enum

"""
Boolean expression to compare columns of type "codex_update_request_status_enum". All fields are combined with logical 'AND'.
"""
input codex_update_request_status_enum_comparison_exp {
  _eq: codex_update_request_status_enum
  _gt: codex_update_request_status_enum
  _gte: codex_update_request_status_enum
  _in: [codex_update_request_status_enum!]
  _is_null: Boolean
  _lt: codex_update_request_status_enum
  _lte: codex_update_request_status_enum
  _neq: codex_update_request_status_enum
  _nin: [codex_update_request_status_enum!]
}

"""
Streaming cursor of the table "codex_update_request"
"""
input codex_update_request_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: codex_update_request_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input codex_update_request_stream_cursor_value_input {
  codex_id: String
  created_at: timestamptz
  status: codex_update_request_status_enum
  token_id: String
  token_version: generative_token_version
}

"""
update columns of table "codex_update_request"
"""
enum codex_update_request_update_column {
  """column name"""
  codex_id

  """column name"""
  created_at

  """column name"""
  status

  """column name"""
  token_id

  """column name"""
  token_version
}

input codex_update_request_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: codex_update_request_set_input

  """filter the rows which have to be updated"""
  where: codex_update_request_bool_exp!
}

input codex_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: codex_set_input

  """filter the rows which have to be updated"""
  where: codex_bool_exp!
}

"""
columns and relationships of "collaboration"
"""
type collaboration {
  collaboration_contract_id: String!
  collaborator_id: String!

  """An object relationship"""
  user: user!

  """An object relationship"""
  userByCollaboratorId: user!
}

"""
aggregated selection of "collaboration"
"""
type collaboration_aggregate {
  aggregate: collaboration_aggregate_fields
  nodes: [collaboration!]!
}

input collaboration_aggregate_bool_exp {
  count: collaboration_aggregate_bool_exp_count
}

input collaboration_aggregate_bool_exp_count {
  arguments: [collaboration_select_column!]
  distinct: Boolean
  filter: collaboration_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "collaboration"
"""
type collaboration_aggregate_fields {
  count(columns: [collaboration_select_column!], distinct: Boolean): Int!
  max: collaboration_max_fields
  min: collaboration_min_fields
}

"""
order by aggregate values of table "collaboration"
"""
input collaboration_aggregate_order_by {
  count: order_by
  max: collaboration_max_order_by
  min: collaboration_min_order_by
}

"""
input type for inserting array relation for remote table "collaboration"
"""
input collaboration_arr_rel_insert_input {
  data: [collaboration_insert_input!]!

  """upsert condition"""
  on_conflict: collaboration_on_conflict
}

"""
Boolean expression to filter rows from the table "collaboration". All fields are combined with a logical 'AND'.
"""
input collaboration_bool_exp {
  _and: [collaboration_bool_exp!]
  _not: collaboration_bool_exp
  _or: [collaboration_bool_exp!]
  collaboration_contract_id: String_comparison_exp
  collaborator_id: String_comparison_exp
  user: user_bool_exp
  userByCollaboratorId: user_bool_exp
}

"""
unique or primary key constraints on table "collaboration"
"""
enum collaboration_constraint {
  """
  unique or primary key constraint on columns "collaboration_contract_id", "collaborator_id"
  """
  PK_40fb1f0eb56850dff4dbb5b0834
}

"""
input type for inserting data into table "collaboration"
"""
input collaboration_insert_input {
  collaboration_contract_id: String
  collaborator_id: String
  user: user_obj_rel_insert_input
  userByCollaboratorId: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type collaboration_max_fields {
  collaboration_contract_id: String
  collaborator_id: String
}

"""
order by max() on columns of table "collaboration"
"""
input collaboration_max_order_by {
  collaboration_contract_id: order_by
  collaborator_id: order_by
}

"""aggregate min on columns"""
type collaboration_min_fields {
  collaboration_contract_id: String
  collaborator_id: String
}

"""
order by min() on columns of table "collaboration"
"""
input collaboration_min_order_by {
  collaboration_contract_id: order_by
  collaborator_id: order_by
}

"""
response of any mutation on the table "collaboration"
"""
type collaboration_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [collaboration!]!
}

"""
on_conflict condition type for table "collaboration"
"""
input collaboration_on_conflict {
  constraint: collaboration_constraint!
  update_columns: [collaboration_update_column!]! = []
  where: collaboration_bool_exp
}

"""Ordering options when selecting data from "collaboration"."""
input collaboration_order_by {
  collaboration_contract_id: order_by
  collaborator_id: order_by
  user: user_order_by
  userByCollaboratorId: user_order_by
}

"""primary key columns input for table: collaboration"""
input collaboration_pk_columns_input {
  collaboration_contract_id: String!
  collaborator_id: String!
}

"""
select columns of table "collaboration"
"""
enum collaboration_select_column {
  """column name"""
  collaboration_contract_id

  """column name"""
  collaborator_id
}

"""
input type for updating data in table "collaboration"
"""
input collaboration_set_input {
  collaboration_contract_id: String
  collaborator_id: String
}

"""
Streaming cursor of the table "collaboration"
"""
input collaboration_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: collaboration_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input collaboration_stream_cursor_value_input {
  collaboration_contract_id: String
  collaborator_id: String
}

"""
update columns of table "collaboration"
"""
enum collaboration_update_column {
  """column name"""
  collaboration_contract_id

  """column name"""
  collaborator_id
}

input collaboration_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: collaboration_set_input

  """filter the rows which have to be updated"""
  where: collaboration_bool_exp!
}

"""
columns and relationships of "collection_offer"
"""
type collection_offer {
  amount: numeric!
  buyer_id: String!
  cancelled_at: timestamptz
  completed_at: timestamptz
  created_at: timestamptz!

  """An object relationship"""
  generative_token: generative_token!
  id: String!
  initial_amount: numeric!
  price: numeric!
  token_id: String!

  """An object relationship"""
  user: user!
  version: Int!
}

"""
aggregated selection of "collection_offer"
"""
type collection_offer_aggregate {
  aggregate: collection_offer_aggregate_fields
  nodes: [collection_offer!]!
}

input collection_offer_aggregate_bool_exp {
  count: collection_offer_aggregate_bool_exp_count
}

input collection_offer_aggregate_bool_exp_count {
  arguments: [collection_offer_select_column!]
  distinct: Boolean
  filter: collection_offer_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "collection_offer"
"""
type collection_offer_aggregate_fields {
  avg: collection_offer_avg_fields
  count(columns: [collection_offer_select_column!], distinct: Boolean): Int!
  max: collection_offer_max_fields
  min: collection_offer_min_fields
  stddev: collection_offer_stddev_fields
  stddev_pop: collection_offer_stddev_pop_fields
  stddev_samp: collection_offer_stddev_samp_fields
  sum: collection_offer_sum_fields
  var_pop: collection_offer_var_pop_fields
  var_samp: collection_offer_var_samp_fields
  variance: collection_offer_variance_fields
}

"""
order by aggregate values of table "collection_offer"
"""
input collection_offer_aggregate_order_by {
  avg: collection_offer_avg_order_by
  count: order_by
  max: collection_offer_max_order_by
  min: collection_offer_min_order_by
  stddev: collection_offer_stddev_order_by
  stddev_pop: collection_offer_stddev_pop_order_by
  stddev_samp: collection_offer_stddev_samp_order_by
  sum: collection_offer_sum_order_by
  var_pop: collection_offer_var_pop_order_by
  var_samp: collection_offer_var_samp_order_by
  variance: collection_offer_variance_order_by
}

"""
input type for inserting array relation for remote table "collection_offer"
"""
input collection_offer_arr_rel_insert_input {
  data: [collection_offer_insert_input!]!

  """upsert condition"""
  on_conflict: collection_offer_on_conflict
}

"""aggregate avg on columns"""
type collection_offer_avg_fields {
  amount: Float
  initial_amount: Float
  price: Float
  version: Float
}

"""
order by avg() on columns of table "collection_offer"
"""
input collection_offer_avg_order_by {
  amount: order_by
  initial_amount: order_by
  price: order_by
  version: order_by
}

"""
Boolean expression to filter rows from the table "collection_offer". All fields are combined with a logical 'AND'.
"""
input collection_offer_bool_exp {
  _and: [collection_offer_bool_exp!]
  _not: collection_offer_bool_exp
  _or: [collection_offer_bool_exp!]
  amount: numeric_comparison_exp
  buyer_id: String_comparison_exp
  cancelled_at: timestamptz_comparison_exp
  completed_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  generative_token: generative_token_bool_exp
  id: String_comparison_exp
  initial_amount: numeric_comparison_exp
  price: numeric_comparison_exp
  token_id: String_comparison_exp
  user: user_bool_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "collection_offer"
"""
enum collection_offer_constraint {
  """
  unique or primary key constraint on columns "id", "version"
  """
  PK_a367623ce45dde246af6122e71e
}

"""
input type for incrementing numeric columns in table "collection_offer"
"""
input collection_offer_inc_input {
  amount: numeric
  initial_amount: numeric
  price: numeric
  version: Int
}

"""
input type for inserting data into table "collection_offer"
"""
input collection_offer_insert_input {
  amount: numeric
  buyer_id: String
  cancelled_at: timestamptz
  completed_at: timestamptz
  created_at: timestamptz
  generative_token: generative_token_obj_rel_insert_input
  id: String
  initial_amount: numeric
  price: numeric
  token_id: String
  user: user_obj_rel_insert_input
  version: Int
}

"""aggregate max on columns"""
type collection_offer_max_fields {
  amount: numeric
  buyer_id: String
  cancelled_at: timestamptz
  completed_at: timestamptz
  created_at: timestamptz
  id: String
  initial_amount: numeric
  price: numeric
  token_id: String
  version: Int
}

"""
order by max() on columns of table "collection_offer"
"""
input collection_offer_max_order_by {
  amount: order_by
  buyer_id: order_by
  cancelled_at: order_by
  completed_at: order_by
  created_at: order_by
  id: order_by
  initial_amount: order_by
  price: order_by
  token_id: order_by
  version: order_by
}

"""aggregate min on columns"""
type collection_offer_min_fields {
  amount: numeric
  buyer_id: String
  cancelled_at: timestamptz
  completed_at: timestamptz
  created_at: timestamptz
  id: String
  initial_amount: numeric
  price: numeric
  token_id: String
  version: Int
}

"""
order by min() on columns of table "collection_offer"
"""
input collection_offer_min_order_by {
  amount: order_by
  buyer_id: order_by
  cancelled_at: order_by
  completed_at: order_by
  created_at: order_by
  id: order_by
  initial_amount: order_by
  price: order_by
  token_id: order_by
  version: order_by
}

"""
response of any mutation on the table "collection_offer"
"""
type collection_offer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [collection_offer!]!
}

"""
on_conflict condition type for table "collection_offer"
"""
input collection_offer_on_conflict {
  constraint: collection_offer_constraint!
  update_columns: [collection_offer_update_column!]! = []
  where: collection_offer_bool_exp
}

"""Ordering options when selecting data from "collection_offer"."""
input collection_offer_order_by {
  amount: order_by
  buyer_id: order_by
  cancelled_at: order_by
  completed_at: order_by
  created_at: order_by
  generative_token: generative_token_order_by
  id: order_by
  initial_amount: order_by
  price: order_by
  token_id: order_by
  user: user_order_by
  version: order_by
}

"""primary key columns input for table: collection_offer"""
input collection_offer_pk_columns_input {
  id: String!
  version: Int!
}

"""
select columns of table "collection_offer"
"""
enum collection_offer_select_column {
  """column name"""
  amount

  """column name"""
  buyer_id

  """column name"""
  cancelled_at

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  initial_amount

  """column name"""
  price

  """column name"""
  token_id

  """column name"""
  version
}

"""
input type for updating data in table "collection_offer"
"""
input collection_offer_set_input {
  amount: numeric
  buyer_id: String
  cancelled_at: timestamptz
  completed_at: timestamptz
  created_at: timestamptz
  id: String
  initial_amount: numeric
  price: numeric
  token_id: String
  version: Int
}

"""aggregate stddev on columns"""
type collection_offer_stddev_fields {
  amount: Float
  initial_amount: Float
  price: Float
  version: Float
}

"""
order by stddev() on columns of table "collection_offer"
"""
input collection_offer_stddev_order_by {
  amount: order_by
  initial_amount: order_by
  price: order_by
  version: order_by
}

"""aggregate stddev_pop on columns"""
type collection_offer_stddev_pop_fields {
  amount: Float
  initial_amount: Float
  price: Float
  version: Float
}

"""
order by stddev_pop() on columns of table "collection_offer"
"""
input collection_offer_stddev_pop_order_by {
  amount: order_by
  initial_amount: order_by
  price: order_by
  version: order_by
}

"""aggregate stddev_samp on columns"""
type collection_offer_stddev_samp_fields {
  amount: Float
  initial_amount: Float
  price: Float
  version: Float
}

"""
order by stddev_samp() on columns of table "collection_offer"
"""
input collection_offer_stddev_samp_order_by {
  amount: order_by
  initial_amount: order_by
  price: order_by
  version: order_by
}

"""
Streaming cursor of the table "collection_offer"
"""
input collection_offer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: collection_offer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input collection_offer_stream_cursor_value_input {
  amount: numeric
  buyer_id: String
  cancelled_at: timestamptz
  completed_at: timestamptz
  created_at: timestamptz
  id: String
  initial_amount: numeric
  price: numeric
  token_id: String
  version: Int
}

"""aggregate sum on columns"""
type collection_offer_sum_fields {
  amount: numeric
  initial_amount: numeric
  price: numeric
  version: Int
}

"""
order by sum() on columns of table "collection_offer"
"""
input collection_offer_sum_order_by {
  amount: order_by
  initial_amount: order_by
  price: order_by
  version: order_by
}

"""
update columns of table "collection_offer"
"""
enum collection_offer_update_column {
  """column name"""
  amount

  """column name"""
  buyer_id

  """column name"""
  cancelled_at

  """column name"""
  completed_at

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  initial_amount

  """column name"""
  price

  """column name"""
  token_id

  """column name"""
  version
}

input collection_offer_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: collection_offer_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: collection_offer_set_input

  """filter the rows which have to be updated"""
  where: collection_offer_bool_exp!
}

"""aggregate var_pop on columns"""
type collection_offer_var_pop_fields {
  amount: Float
  initial_amount: Float
  price: Float
  version: Float
}

"""
order by var_pop() on columns of table "collection_offer"
"""
input collection_offer_var_pop_order_by {
  amount: order_by
  initial_amount: order_by
  price: order_by
  version: order_by
}

"""aggregate var_samp on columns"""
type collection_offer_var_samp_fields {
  amount: Float
  initial_amount: Float
  price: Float
  version: Float
}

"""
order by var_samp() on columns of table "collection_offer"
"""
input collection_offer_var_samp_order_by {
  amount: order_by
  initial_amount: order_by
  price: order_by
  version: order_by
}

"""aggregate variance on columns"""
type collection_offer_variance_fields {
  amount: Float
  initial_amount: Float
  price: Float
  version: Float
}

"""
order by variance() on columns of table "collection_offer"
"""
input collection_offer_variance_order_by {
  amount: order_by
  initial_amount: order_by
  price: order_by
  version: order_by
}

"""ordering argument of a cursor"""
enum cursor_ordering {
  """ascending ordering of the cursor"""
  ASC

  """descending ordering of the cursor"""
  DESC
}

scalar float8

"""
Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'.
"""
input float8_comparison_exp {
  _eq: float8
  _gt: float8
  _gte: float8
  _in: [float8!]
  _is_null: Boolean
  _lt: float8
  _lte: float8
  _neq: float8
  _nin: [float8!]
}

"""
columns and relationships of "generative_token"
"""
type generative_token {
  """An array relationship"""
  actions(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """An aggregate relationship"""
  actions_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!
  author_id: String
  balance: numeric!
  captureMediaId: bpchar

  """An object relationship"""
  codex: codex
  codexId: String
  codex_id: String

  """An array relationship"""
  codex_update_requests(
    """distinct select on columns"""
    distinct_on: [codex_update_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_update_request_order_by!]

    """filter the rows returned"""
    where: codex_update_request_bool_exp
  ): [codex_update_request!]!

  """An aggregate relationship"""
  codex_update_requests_aggregate(
    """distinct select on columns"""
    distinct_on: [codex_update_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_update_request_order_by!]

    """filter the rows returned"""
    where: codex_update_request_bool_exp
  ): codex_update_request_aggregate!

  """An array relationship"""
  collection_offers(
    """distinct select on columns"""
    distinct_on: [collection_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_offer_order_by!]

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): [collection_offer!]!

  """An aggregate relationship"""
  collection_offers_aggregate(
    """distinct select on columns"""
    distinct_on: [collection_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_offer_order_by!]

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): collection_offer_aggregate!
  created_at: timestamptz!
  display_uri: String
  enabled: Boolean!
  flag: generative_token_flag_enum!
  generative_uri: String
  id: String!
  input_bytes_size: Int!
  iterations_count: numeric
  labels: _int4!
  lock_end: timestamptz!
  lock_price_for_reserves: Boolean!
  locked_seconds: Int!

  """An object relationship"""
  market_stat: market_stats

  """An array relationship"""
  market_stats_histories(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): [market_stats_history!]!

  """An aggregate relationship"""
  market_stats_histories_aggregate(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): market_stats_history_aggregate!

  """An object relationship"""
  media_image: media_image
  metadata(
    """JSON select path"""
    path: String
  ): json
  metadata_uri: String
  mint_opens_at: timestamptz!

  """An array relationship"""
  mint_ticket_settings(
    """distinct select on columns"""
    distinct_on: [mint_ticket_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_settings_order_by!]

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): [mint_ticket_settings!]!

  """An aggregate relationship"""
  mint_ticket_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_ticket_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_settings_order_by!]

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): mint_ticket_settings_aggregate!

  """An array relationship"""
  mint_tickets(
    """distinct select on columns"""
    distinct_on: [mint_ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_order_by!]

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): [mint_ticket!]!

  """An aggregate relationship"""
  mint_tickets_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_order_by!]

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): mint_ticket_aggregate!

  """An object relationship"""
  moderation_reason: moderation_reason
  moderation_reason_id: String
  name: String

  """An array relationship"""
  objkts(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): [objkt!]!

  """An aggregate relationship"""
  objkts_aggregate(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): objkt_aggregate!
  open_editions: Boolean!
  open_editions_ends_at: timestamptz
  original_supply: numeric!
  params_definition(
    """JSON select path"""
    path: String
  ): json
  preview_input_bytes: String

  """An array relationship"""
  pricing_dutch_auctions(
    """distinct select on columns"""
    distinct_on: [pricing_dutch_auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_dutch_auction_order_by!]

    """filter the rows returned"""
    where: pricing_dutch_auction_bool_exp
  ): [pricing_dutch_auction!]!

  """An aggregate relationship"""
  pricing_dutch_auctions_aggregate(
    """distinct select on columns"""
    distinct_on: [pricing_dutch_auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_dutch_auction_order_by!]

    """filter the rows returned"""
    where: pricing_dutch_auction_bool_exp
  ): pricing_dutch_auction_aggregate!

  """An array relationship"""
  pricing_fixeds(
    """distinct select on columns"""
    distinct_on: [pricing_fixed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_fixed_order_by!]

    """filter the rows returned"""
    where: pricing_fixed_bool_exp
  ): [pricing_fixed!]!

  """An aggregate relationship"""
  pricing_fixeds_aggregate(
    """distinct select on columns"""
    distinct_on: [pricing_fixed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_fixed_order_by!]

    """filter the rows returned"""
    where: pricing_fixed_bool_exp
  ): pricing_fixed_aggregate!

  """An array relationship"""
  redeemables(
    """distinct select on columns"""
    distinct_on: [redeemable_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redeemable_order_by!]

    """filter the rows returned"""
    where: redeemable_bool_exp
  ): [redeemable!]!

  """An aggregate relationship"""
  redeemables_aggregate(
    """distinct select on columns"""
    distinct_on: [redeemable_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redeemable_order_by!]

    """filter the rows returned"""
    where: redeemable_bool_exp
  ): redeemable_aggregate!

  """An array relationship"""
  reports(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!

  """An aggregate relationship"""
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): report_aggregate!

  """An array relationship"""
  reserves(
    """distinct select on columns"""
    distinct_on: [reserve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reserve_order_by!]

    """filter the rows returned"""
    where: reserve_bool_exp
  ): [reserve!]!

  """An aggregate relationship"""
  reserves_aggregate(
    """distinct select on columns"""
    distinct_on: [reserve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reserve_order_by!]

    """filter the rows returned"""
    where: reserve_bool_exp
  ): reserve_aggregate!
  royalties: Int!
  slug: String

  """An array relationship"""
  splits(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """An array relationship"""
  splitsByGenerativeTokenPrimaryId(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """An aggregate relationship"""
  splitsByGenerativeTokenPrimaryId_aggregate(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): split_aggregate!

  """An aggregate relationship"""
  splits_aggregate(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): split_aggregate!
  supply: numeric!
  tags: _text
  thumbnail_uri: String

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!
  updated_at: timestamptz

  """An object relationship"""
  user: user
  version: generative_token_version!
}

"""
aggregated selection of "generative_token"
"""
type generative_token_aggregate {
  aggregate: generative_token_aggregate_fields
  nodes: [generative_token!]!
}

input generative_token_aggregate_bool_exp {
  bool_and: generative_token_aggregate_bool_exp_bool_and
  bool_or: generative_token_aggregate_bool_exp_bool_or
  count: generative_token_aggregate_bool_exp_count
}

input generative_token_aggregate_bool_exp_bool_and {
  arguments: generative_token_select_column_generative_token_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: generative_token_bool_exp
  predicate: Boolean_comparison_exp!
}

input generative_token_aggregate_bool_exp_bool_or {
  arguments: generative_token_select_column_generative_token_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: generative_token_bool_exp
  predicate: Boolean_comparison_exp!
}

input generative_token_aggregate_bool_exp_count {
  arguments: [generative_token_select_column!]
  distinct: Boolean
  filter: generative_token_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "generative_token"
"""
type generative_token_aggregate_fields {
  avg: generative_token_avg_fields
  count(columns: [generative_token_select_column!], distinct: Boolean): Int!
  max: generative_token_max_fields
  min: generative_token_min_fields
  stddev: generative_token_stddev_fields
  stddev_pop: generative_token_stddev_pop_fields
  stddev_samp: generative_token_stddev_samp_fields
  sum: generative_token_sum_fields
  var_pop: generative_token_var_pop_fields
  var_samp: generative_token_var_samp_fields
  variance: generative_token_variance_fields
}

"""
order by aggregate values of table "generative_token"
"""
input generative_token_aggregate_order_by {
  avg: generative_token_avg_order_by
  count: order_by
  max: generative_token_max_order_by
  min: generative_token_min_order_by
  stddev: generative_token_stddev_order_by
  stddev_pop: generative_token_stddev_pop_order_by
  stddev_samp: generative_token_stddev_samp_order_by
  sum: generative_token_sum_order_by
  var_pop: generative_token_var_pop_order_by
  var_samp: generative_token_var_samp_order_by
  variance: generative_token_variance_order_by
}

"""
input type for inserting array relation for remote table "generative_token"
"""
input generative_token_arr_rel_insert_input {
  data: [generative_token_insert_input!]!

  """upsert condition"""
  on_conflict: generative_token_on_conflict
}

"""aggregate avg on columns"""
type generative_token_avg_fields {
  balance: Float
  input_bytes_size: Float
  iterations_count: Float
  locked_seconds: Float
  original_supply: Float
  royalties: Float
  supply: Float
}

"""
order by avg() on columns of table "generative_token"
"""
input generative_token_avg_order_by {
  balance: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  locked_seconds: order_by
  original_supply: order_by
  royalties: order_by
  supply: order_by
}

"""
Boolean expression to filter rows from the table "generative_token". All fields are combined with a logical 'AND'.
"""
input generative_token_bool_exp {
  _and: [generative_token_bool_exp!]
  _not: generative_token_bool_exp
  _or: [generative_token_bool_exp!]
  actions: action_bool_exp
  actions_aggregate: action_aggregate_bool_exp
  author_id: String_comparison_exp
  balance: numeric_comparison_exp
  captureMediaId: bpchar_comparison_exp
  codex: codex_bool_exp
  codexId: String_comparison_exp
  codex_id: String_comparison_exp
  codex_update_requests: codex_update_request_bool_exp
  codex_update_requests_aggregate: codex_update_request_aggregate_bool_exp
  collection_offers: collection_offer_bool_exp
  collection_offers_aggregate: collection_offer_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  display_uri: String_comparison_exp
  enabled: Boolean_comparison_exp
  flag: generative_token_flag_enum_comparison_exp
  generative_uri: String_comparison_exp
  id: String_comparison_exp
  input_bytes_size: Int_comparison_exp
  iterations_count: numeric_comparison_exp
  labels: _int4_comparison_exp
  lock_end: timestamptz_comparison_exp
  lock_price_for_reserves: Boolean_comparison_exp
  locked_seconds: Int_comparison_exp
  market_stat: market_stats_bool_exp
  market_stats_histories: market_stats_history_bool_exp
  market_stats_histories_aggregate: market_stats_history_aggregate_bool_exp
  media_image: media_image_bool_exp
  metadata: json_comparison_exp
  metadata_uri: String_comparison_exp
  mint_opens_at: timestamptz_comparison_exp
  mint_ticket_settings: mint_ticket_settings_bool_exp
  mint_ticket_settings_aggregate: mint_ticket_settings_aggregate_bool_exp
  mint_tickets: mint_ticket_bool_exp
  mint_tickets_aggregate: mint_ticket_aggregate_bool_exp
  moderation_reason: moderation_reason_bool_exp
  moderation_reason_id: String_comparison_exp
  name: String_comparison_exp
  objkts: objkt_bool_exp
  objkts_aggregate: objkt_aggregate_bool_exp
  open_editions: Boolean_comparison_exp
  open_editions_ends_at: timestamptz_comparison_exp
  original_supply: numeric_comparison_exp
  params_definition: json_comparison_exp
  preview_input_bytes: String_comparison_exp
  pricing_dutch_auctions: pricing_dutch_auction_bool_exp
  pricing_dutch_auctions_aggregate: pricing_dutch_auction_aggregate_bool_exp
  pricing_fixeds: pricing_fixed_bool_exp
  pricing_fixeds_aggregate: pricing_fixed_aggregate_bool_exp
  redeemables: redeemable_bool_exp
  redeemables_aggregate: redeemable_aggregate_bool_exp
  reports: report_bool_exp
  reports_aggregate: report_aggregate_bool_exp
  reserves: reserve_bool_exp
  reserves_aggregate: reserve_aggregate_bool_exp
  royalties: Int_comparison_exp
  slug: String_comparison_exp
  splits: split_bool_exp
  splitsByGenerativeTokenPrimaryId: split_bool_exp
  splitsByGenerativeTokenPrimaryId_aggregate: split_aggregate_bool_exp
  splits_aggregate: split_aggregate_bool_exp
  supply: numeric_comparison_exp
  tags: _text_comparison_exp
  thumbnail_uri: String_comparison_exp
  transactions: transaction_bool_exp
  transactions_aggregate: transaction_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  version: generative_token_version_comparison_exp
}

"""
unique or primary key constraints on table "generative_token"
"""
enum generative_token_constraint {
  """
  unique or primary key constraint on columns "slug"
  """
  IDX_d05e635a41301df6701d7be2d3

  """
  unique or primary key constraint on columns "id"
  """
  PK_cb76f91024475ec70a1625b1b27
}

scalar generative_token_flag_enum

"""
Boolean expression to compare columns of type "generative_token_flag_enum". All fields are combined with logical 'AND'.
"""
input generative_token_flag_enum_comparison_exp {
  _eq: generative_token_flag_enum
  _gt: generative_token_flag_enum
  _gte: generative_token_flag_enum
  _in: [generative_token_flag_enum!]
  _is_null: Boolean
  _lt: generative_token_flag_enum
  _lte: generative_token_flag_enum
  _neq: generative_token_flag_enum
  _nin: [generative_token_flag_enum!]
}

"""
input type for incrementing numeric columns in table "generative_token"
"""
input generative_token_inc_input {
  balance: numeric
  input_bytes_size: Int
  iterations_count: numeric
  locked_seconds: Int
  original_supply: numeric
  royalties: Int
  supply: numeric
}

"""
input type for inserting data into table "generative_token"
"""
input generative_token_insert_input {
  actions: action_arr_rel_insert_input
  author_id: String
  balance: numeric
  captureMediaId: bpchar
  codex: codex_obj_rel_insert_input
  codexId: String
  codex_id: String
  codex_update_requests: codex_update_request_arr_rel_insert_input
  collection_offers: collection_offer_arr_rel_insert_input
  created_at: timestamptz
  display_uri: String
  enabled: Boolean
  flag: generative_token_flag_enum
  generative_uri: String
  id: String
  input_bytes_size: Int
  iterations_count: numeric
  labels: _int4
  lock_end: timestamptz
  lock_price_for_reserves: Boolean
  locked_seconds: Int
  market_stat: market_stats_obj_rel_insert_input
  market_stats_histories: market_stats_history_arr_rel_insert_input
  media_image: media_image_obj_rel_insert_input
  metadata: json
  metadata_uri: String
  mint_opens_at: timestamptz
  mint_ticket_settings: mint_ticket_settings_arr_rel_insert_input
  mint_tickets: mint_ticket_arr_rel_insert_input
  moderation_reason: moderation_reason_obj_rel_insert_input
  moderation_reason_id: String
  name: String
  objkts: objkt_arr_rel_insert_input
  open_editions: Boolean
  open_editions_ends_at: timestamptz
  original_supply: numeric
  params_definition: json
  preview_input_bytes: String
  pricing_dutch_auctions: pricing_dutch_auction_arr_rel_insert_input
  pricing_fixeds: pricing_fixed_arr_rel_insert_input
  redeemables: redeemable_arr_rel_insert_input
  reports: report_arr_rel_insert_input
  reserves: reserve_arr_rel_insert_input
  royalties: Int
  slug: String
  splits: split_arr_rel_insert_input
  splitsByGenerativeTokenPrimaryId: split_arr_rel_insert_input
  supply: numeric
  tags: _text
  thumbnail_uri: String
  transactions: transaction_arr_rel_insert_input
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  version: generative_token_version
}

"""aggregate max on columns"""
type generative_token_max_fields {
  author_id: String
  balance: numeric
  captureMediaId: bpchar
  codexId: String
  codex_id: String
  created_at: timestamptz
  display_uri: String
  flag: generative_token_flag_enum
  generative_uri: String
  id: String
  input_bytes_size: Int
  iterations_count: numeric
  lock_end: timestamptz
  locked_seconds: Int
  metadata_uri: String
  mint_opens_at: timestamptz
  moderation_reason_id: String
  name: String
  open_editions_ends_at: timestamptz
  original_supply: numeric
  preview_input_bytes: String
  royalties: Int
  slug: String
  supply: numeric
  thumbnail_uri: String
  updated_at: timestamptz
  version: generative_token_version
}

"""
order by max() on columns of table "generative_token"
"""
input generative_token_max_order_by {
  author_id: order_by
  balance: order_by
  captureMediaId: order_by
  codexId: order_by
  codex_id: order_by
  created_at: order_by
  display_uri: order_by
  flag: order_by
  generative_uri: order_by
  id: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  lock_end: order_by
  locked_seconds: order_by
  metadata_uri: order_by
  mint_opens_at: order_by
  moderation_reason_id: order_by
  name: order_by
  open_editions_ends_at: order_by
  original_supply: order_by
  preview_input_bytes: order_by
  royalties: order_by
  slug: order_by
  supply: order_by
  thumbnail_uri: order_by
  updated_at: order_by
  version: order_by
}

"""aggregate min on columns"""
type generative_token_min_fields {
  author_id: String
  balance: numeric
  captureMediaId: bpchar
  codexId: String
  codex_id: String
  created_at: timestamptz
  display_uri: String
  flag: generative_token_flag_enum
  generative_uri: String
  id: String
  input_bytes_size: Int
  iterations_count: numeric
  lock_end: timestamptz
  locked_seconds: Int
  metadata_uri: String
  mint_opens_at: timestamptz
  moderation_reason_id: String
  name: String
  open_editions_ends_at: timestamptz
  original_supply: numeric
  preview_input_bytes: String
  royalties: Int
  slug: String
  supply: numeric
  thumbnail_uri: String
  updated_at: timestamptz
  version: generative_token_version
}

"""
order by min() on columns of table "generative_token"
"""
input generative_token_min_order_by {
  author_id: order_by
  balance: order_by
  captureMediaId: order_by
  codexId: order_by
  codex_id: order_by
  created_at: order_by
  display_uri: order_by
  flag: order_by
  generative_uri: order_by
  id: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  lock_end: order_by
  locked_seconds: order_by
  metadata_uri: order_by
  mint_opens_at: order_by
  moderation_reason_id: order_by
  name: order_by
  open_editions_ends_at: order_by
  original_supply: order_by
  preview_input_bytes: order_by
  royalties: order_by
  slug: order_by
  supply: order_by
  thumbnail_uri: order_by
  updated_at: order_by
  version: order_by
}

"""
response of any mutation on the table "generative_token"
"""
type generative_token_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [generative_token!]!
}

"""
input type for inserting object relation for remote table "generative_token"
"""
input generative_token_obj_rel_insert_input {
  data: generative_token_insert_input!

  """upsert condition"""
  on_conflict: generative_token_on_conflict
}

"""
on_conflict condition type for table "generative_token"
"""
input generative_token_on_conflict {
  constraint: generative_token_constraint!
  update_columns: [generative_token_update_column!]! = []
  where: generative_token_bool_exp
}

"""Ordering options when selecting data from "generative_token"."""
input generative_token_order_by {
  actions_aggregate: action_aggregate_order_by
  author_id: order_by
  balance: order_by
  captureMediaId: order_by
  codex: codex_order_by
  codexId: order_by
  codex_id: order_by
  codex_update_requests_aggregate: codex_update_request_aggregate_order_by
  collection_offers_aggregate: collection_offer_aggregate_order_by
  created_at: order_by
  display_uri: order_by
  enabled: order_by
  flag: order_by
  generative_uri: order_by
  id: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  labels: order_by
  lock_end: order_by
  lock_price_for_reserves: order_by
  locked_seconds: order_by
  market_stat: market_stats_order_by
  market_stats_histories_aggregate: market_stats_history_aggregate_order_by
  media_image: media_image_order_by
  metadata: order_by
  metadata_uri: order_by
  mint_opens_at: order_by
  mint_ticket_settings_aggregate: mint_ticket_settings_aggregate_order_by
  mint_tickets_aggregate: mint_ticket_aggregate_order_by
  moderation_reason: moderation_reason_order_by
  moderation_reason_id: order_by
  name: order_by
  objkts_aggregate: objkt_aggregate_order_by
  open_editions: order_by
  open_editions_ends_at: order_by
  original_supply: order_by
  params_definition: order_by
  preview_input_bytes: order_by
  pricing_dutch_auctions_aggregate: pricing_dutch_auction_aggregate_order_by
  pricing_fixeds_aggregate: pricing_fixed_aggregate_order_by
  redeemables_aggregate: redeemable_aggregate_order_by
  reports_aggregate: report_aggregate_order_by
  reserves_aggregate: reserve_aggregate_order_by
  royalties: order_by
  slug: order_by
  splitsByGenerativeTokenPrimaryId_aggregate: split_aggregate_order_by
  splits_aggregate: split_aggregate_order_by
  supply: order_by
  tags: order_by
  thumbnail_uri: order_by
  transactions_aggregate: transaction_aggregate_order_by
  updated_at: order_by
  user: user_order_by
  version: order_by
}

"""primary key columns input for table: generative_token"""
input generative_token_pk_columns_input {
  id: String!
}

"""
select columns of table "generative_token"
"""
enum generative_token_select_column {
  """column name"""
  author_id

  """column name"""
  balance

  """column name"""
  captureMediaId

  """column name"""
  codexId

  """column name"""
  codex_id

  """column name"""
  created_at

  """column name"""
  display_uri

  """column name"""
  enabled

  """column name"""
  flag

  """column name"""
  generative_uri

  """column name"""
  id

  """column name"""
  input_bytes_size

  """column name"""
  iterations_count

  """column name"""
  labels

  """column name"""
  lock_end

  """column name"""
  lock_price_for_reserves

  """column name"""
  locked_seconds

  """column name"""
  metadata

  """column name"""
  metadata_uri

  """column name"""
  mint_opens_at

  """column name"""
  moderation_reason_id

  """column name"""
  name

  """column name"""
  open_editions

  """column name"""
  open_editions_ends_at

  """column name"""
  original_supply

  """column name"""
  params_definition

  """column name"""
  preview_input_bytes

  """column name"""
  royalties

  """column name"""
  slug

  """column name"""
  supply

  """column name"""
  tags

  """column name"""
  thumbnail_uri

  """column name"""
  updated_at

  """column name"""
  version
}

"""
select "generative_token_aggregate_bool_exp_bool_and_arguments_columns" columns of table "generative_token"
"""
enum generative_token_select_column_generative_token_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  enabled

  """column name"""
  lock_price_for_reserves

  """column name"""
  open_editions
}

"""
select "generative_token_aggregate_bool_exp_bool_or_arguments_columns" columns of table "generative_token"
"""
enum generative_token_select_column_generative_token_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  enabled

  """column name"""
  lock_price_for_reserves

  """column name"""
  open_editions
}

"""
input type for updating data in table "generative_token"
"""
input generative_token_set_input {
  author_id: String
  balance: numeric
  captureMediaId: bpchar
  codexId: String
  codex_id: String
  created_at: timestamptz
  display_uri: String
  enabled: Boolean
  flag: generative_token_flag_enum
  generative_uri: String
  id: String
  input_bytes_size: Int
  iterations_count: numeric
  labels: _int4
  lock_end: timestamptz
  lock_price_for_reserves: Boolean
  locked_seconds: Int
  metadata: json
  metadata_uri: String
  mint_opens_at: timestamptz
  moderation_reason_id: String
  name: String
  open_editions: Boolean
  open_editions_ends_at: timestamptz
  original_supply: numeric
  params_definition: json
  preview_input_bytes: String
  royalties: Int
  slug: String
  supply: numeric
  tags: _text
  thumbnail_uri: String
  updated_at: timestamptz
  version: generative_token_version
}

"""aggregate stddev on columns"""
type generative_token_stddev_fields {
  balance: Float
  input_bytes_size: Float
  iterations_count: Float
  locked_seconds: Float
  original_supply: Float
  royalties: Float
  supply: Float
}

"""
order by stddev() on columns of table "generative_token"
"""
input generative_token_stddev_order_by {
  balance: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  locked_seconds: order_by
  original_supply: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate stddev_pop on columns"""
type generative_token_stddev_pop_fields {
  balance: Float
  input_bytes_size: Float
  iterations_count: Float
  locked_seconds: Float
  original_supply: Float
  royalties: Float
  supply: Float
}

"""
order by stddev_pop() on columns of table "generative_token"
"""
input generative_token_stddev_pop_order_by {
  balance: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  locked_seconds: order_by
  original_supply: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate stddev_samp on columns"""
type generative_token_stddev_samp_fields {
  balance: Float
  input_bytes_size: Float
  iterations_count: Float
  locked_seconds: Float
  original_supply: Float
  royalties: Float
  supply: Float
}

"""
order by stddev_samp() on columns of table "generative_token"
"""
input generative_token_stddev_samp_order_by {
  balance: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  locked_seconds: order_by
  original_supply: order_by
  royalties: order_by
  supply: order_by
}

"""
Streaming cursor of the table "generative_token"
"""
input generative_token_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: generative_token_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input generative_token_stream_cursor_value_input {
  author_id: String
  balance: numeric
  captureMediaId: bpchar
  codexId: String
  codex_id: String
  created_at: timestamptz
  display_uri: String
  enabled: Boolean
  flag: generative_token_flag_enum
  generative_uri: String
  id: String
  input_bytes_size: Int
  iterations_count: numeric
  labels: _int4
  lock_end: timestamptz
  lock_price_for_reserves: Boolean
  locked_seconds: Int
  metadata: json
  metadata_uri: String
  mint_opens_at: timestamptz
  moderation_reason_id: String
  name: String
  open_editions: Boolean
  open_editions_ends_at: timestamptz
  original_supply: numeric
  params_definition: json
  preview_input_bytes: String
  royalties: Int
  slug: String
  supply: numeric
  tags: _text
  thumbnail_uri: String
  updated_at: timestamptz
  version: generative_token_version
}

"""aggregate sum on columns"""
type generative_token_sum_fields {
  balance: numeric
  input_bytes_size: Int
  iterations_count: numeric
  locked_seconds: Int
  original_supply: numeric
  royalties: Int
  supply: numeric
}

"""
order by sum() on columns of table "generative_token"
"""
input generative_token_sum_order_by {
  balance: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  locked_seconds: order_by
  original_supply: order_by
  royalties: order_by
  supply: order_by
}

"""
update columns of table "generative_token"
"""
enum generative_token_update_column {
  """column name"""
  author_id

  """column name"""
  balance

  """column name"""
  captureMediaId

  """column name"""
  codexId

  """column name"""
  codex_id

  """column name"""
  created_at

  """column name"""
  display_uri

  """column name"""
  enabled

  """column name"""
  flag

  """column name"""
  generative_uri

  """column name"""
  id

  """column name"""
  input_bytes_size

  """column name"""
  iterations_count

  """column name"""
  labels

  """column name"""
  lock_end

  """column name"""
  lock_price_for_reserves

  """column name"""
  locked_seconds

  """column name"""
  metadata

  """column name"""
  metadata_uri

  """column name"""
  mint_opens_at

  """column name"""
  moderation_reason_id

  """column name"""
  name

  """column name"""
  open_editions

  """column name"""
  open_editions_ends_at

  """column name"""
  original_supply

  """column name"""
  params_definition

  """column name"""
  preview_input_bytes

  """column name"""
  royalties

  """column name"""
  slug

  """column name"""
  supply

  """column name"""
  tags

  """column name"""
  thumbnail_uri

  """column name"""
  updated_at

  """column name"""
  version
}

input generative_token_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: generative_token_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: generative_token_set_input

  """filter the rows which have to be updated"""
  where: generative_token_bool_exp!
}

"""aggregate var_pop on columns"""
type generative_token_var_pop_fields {
  balance: Float
  input_bytes_size: Float
  iterations_count: Float
  locked_seconds: Float
  original_supply: Float
  royalties: Float
  supply: Float
}

"""
order by var_pop() on columns of table "generative_token"
"""
input generative_token_var_pop_order_by {
  balance: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  locked_seconds: order_by
  original_supply: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate var_samp on columns"""
type generative_token_var_samp_fields {
  balance: Float
  input_bytes_size: Float
  iterations_count: Float
  locked_seconds: Float
  original_supply: Float
  royalties: Float
  supply: Float
}

"""
order by var_samp() on columns of table "generative_token"
"""
input generative_token_var_samp_order_by {
  balance: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  locked_seconds: order_by
  original_supply: order_by
  royalties: order_by
  supply: order_by
}

"""aggregate variance on columns"""
type generative_token_variance_fields {
  balance: Float
  input_bytes_size: Float
  iterations_count: Float
  locked_seconds: Float
  original_supply: Float
  royalties: Float
  supply: Float
}

"""
order by variance() on columns of table "generative_token"
"""
input generative_token_variance_order_by {
  balance: order_by
  input_bytes_size: order_by
  iterations_count: order_by
  locked_seconds: order_by
  original_supply: order_by
  royalties: order_by
  supply: order_by
}

scalar generative_token_version

"""
Boolean expression to compare columns of type "generative_token_version". All fields are combined with logical 'AND'.
"""
input generative_token_version_comparison_exp {
  _eq: generative_token_version
  _gt: generative_token_version
  _gte: generative_token_version
  _in: [generative_token_version!]
  _is_null: Boolean
  _lt: generative_token_version
  _lte: generative_token_version
  _neq: generative_token_version
  _nin: [generative_token_version!]
}

"""
columns and relationships of "gentk_assign"
"""
type gentk_assign {
  assigned_at: timestamptz
  attempts: Int!
  created_at: timestamptz!
  gentk_id: String!
  gentk_issuer_version: generative_token_version!

  """An object relationship"""
  objkt: objkt
  retries: Int!
  state: gentk_assign_state_enum!
}

"""
aggregated selection of "gentk_assign"
"""
type gentk_assign_aggregate {
  aggregate: gentk_assign_aggregate_fields
  nodes: [gentk_assign!]!
}

"""
aggregate fields of "gentk_assign"
"""
type gentk_assign_aggregate_fields {
  avg: gentk_assign_avg_fields
  count(columns: [gentk_assign_select_column!], distinct: Boolean): Int!
  max: gentk_assign_max_fields
  min: gentk_assign_min_fields
  stddev: gentk_assign_stddev_fields
  stddev_pop: gentk_assign_stddev_pop_fields
  stddev_samp: gentk_assign_stddev_samp_fields
  sum: gentk_assign_sum_fields
  var_pop: gentk_assign_var_pop_fields
  var_samp: gentk_assign_var_samp_fields
  variance: gentk_assign_variance_fields
}

"""aggregate avg on columns"""
type gentk_assign_avg_fields {
  attempts: Float
  retries: Float
}

"""
Boolean expression to filter rows from the table "gentk_assign". All fields are combined with a logical 'AND'.
"""
input gentk_assign_bool_exp {
  _and: [gentk_assign_bool_exp!]
  _not: gentk_assign_bool_exp
  _or: [gentk_assign_bool_exp!]
  assigned_at: timestamptz_comparison_exp
  attempts: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  gentk_id: String_comparison_exp
  gentk_issuer_version: generative_token_version_comparison_exp
  objkt: objkt_bool_exp
  retries: Int_comparison_exp
  state: gentk_assign_state_enum_comparison_exp
}

"""
unique or primary key constraints on table "gentk_assign"
"""
enum gentk_assign_constraint {
  """
  unique or primary key constraint on columns "gentk_issuer_version", "gentk_id"
  """
  PK_3d3ff4f388a5b98dda259df6ec2
}

"""
input type for incrementing numeric columns in table "gentk_assign"
"""
input gentk_assign_inc_input {
  attempts: Int
  retries: Int
}

"""
input type for inserting data into table "gentk_assign"
"""
input gentk_assign_insert_input {
  assigned_at: timestamptz
  attempts: Int
  created_at: timestamptz
  gentk_id: String
  gentk_issuer_version: generative_token_version
  objkt: objkt_obj_rel_insert_input
  retries: Int
  state: gentk_assign_state_enum
}

"""aggregate max on columns"""
type gentk_assign_max_fields {
  assigned_at: timestamptz
  attempts: Int
  created_at: timestamptz
  gentk_id: String
  gentk_issuer_version: generative_token_version
  retries: Int
  state: gentk_assign_state_enum
}

"""aggregate min on columns"""
type gentk_assign_min_fields {
  assigned_at: timestamptz
  attempts: Int
  created_at: timestamptz
  gentk_id: String
  gentk_issuer_version: generative_token_version
  retries: Int
  state: gentk_assign_state_enum
}

"""
response of any mutation on the table "gentk_assign"
"""
type gentk_assign_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [gentk_assign!]!
}

"""
input type for inserting object relation for remote table "gentk_assign"
"""
input gentk_assign_obj_rel_insert_input {
  data: gentk_assign_insert_input!

  """upsert condition"""
  on_conflict: gentk_assign_on_conflict
}

"""
on_conflict condition type for table "gentk_assign"
"""
input gentk_assign_on_conflict {
  constraint: gentk_assign_constraint!
  update_columns: [gentk_assign_update_column!]! = []
  where: gentk_assign_bool_exp
}

"""Ordering options when selecting data from "gentk_assign"."""
input gentk_assign_order_by {
  assigned_at: order_by
  attempts: order_by
  created_at: order_by
  gentk_id: order_by
  gentk_issuer_version: order_by
  objkt: objkt_order_by
  retries: order_by
  state: order_by
}

"""primary key columns input for table: gentk_assign"""
input gentk_assign_pk_columns_input {
  gentk_id: String!
  gentk_issuer_version: generative_token_version!
}

"""
select columns of table "gentk_assign"
"""
enum gentk_assign_select_column {
  """column name"""
  assigned_at

  """column name"""
  attempts

  """column name"""
  created_at

  """column name"""
  gentk_id

  """column name"""
  gentk_issuer_version

  """column name"""
  retries

  """column name"""
  state
}

"""
input type for updating data in table "gentk_assign"
"""
input gentk_assign_set_input {
  assigned_at: timestamptz
  attempts: Int
  created_at: timestamptz
  gentk_id: String
  gentk_issuer_version: generative_token_version
  retries: Int
  state: gentk_assign_state_enum
}

scalar gentk_assign_state_enum

"""
Boolean expression to compare columns of type "gentk_assign_state_enum". All fields are combined with logical 'AND'.
"""
input gentk_assign_state_enum_comparison_exp {
  _eq: gentk_assign_state_enum
  _gt: gentk_assign_state_enum
  _gte: gentk_assign_state_enum
  _in: [gentk_assign_state_enum!]
  _is_null: Boolean
  _lt: gentk_assign_state_enum
  _lte: gentk_assign_state_enum
  _neq: gentk_assign_state_enum
  _nin: [gentk_assign_state_enum!]
}

"""aggregate stddev on columns"""
type gentk_assign_stddev_fields {
  attempts: Float
  retries: Float
}

"""aggregate stddev_pop on columns"""
type gentk_assign_stddev_pop_fields {
  attempts: Float
  retries: Float
}

"""aggregate stddev_samp on columns"""
type gentk_assign_stddev_samp_fields {
  attempts: Float
  retries: Float
}

"""
Streaming cursor of the table "gentk_assign"
"""
input gentk_assign_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: gentk_assign_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input gentk_assign_stream_cursor_value_input {
  assigned_at: timestamptz
  attempts: Int
  created_at: timestamptz
  gentk_id: String
  gentk_issuer_version: generative_token_version
  retries: Int
  state: gentk_assign_state_enum
}

"""aggregate sum on columns"""
type gentk_assign_sum_fields {
  attempts: Int
  retries: Int
}

"""
update columns of table "gentk_assign"
"""
enum gentk_assign_update_column {
  """column name"""
  assigned_at

  """column name"""
  attempts

  """column name"""
  created_at

  """column name"""
  gentk_id

  """column name"""
  gentk_issuer_version

  """column name"""
  retries

  """column name"""
  state
}

input gentk_assign_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: gentk_assign_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: gentk_assign_set_input

  """filter the rows which have to be updated"""
  where: gentk_assign_bool_exp!
}

"""aggregate var_pop on columns"""
type gentk_assign_var_pop_fields {
  attempts: Float
  retries: Float
}

"""aggregate var_samp on columns"""
type gentk_assign_var_samp_fields {
  attempts: Float
  retries: Float
}

"""aggregate variance on columns"""
type gentk_assign_variance_fields {
  attempts: Float
  retries: Float
}

"""
columns and relationships of "ipfs_cid"
"""
type ipfs_cid {
  cid: String!
}

"""
aggregated selection of "ipfs_cid"
"""
type ipfs_cid_aggregate {
  aggregate: ipfs_cid_aggregate_fields
  nodes: [ipfs_cid!]!
}

"""
aggregate fields of "ipfs_cid"
"""
type ipfs_cid_aggregate_fields {
  count(columns: [ipfs_cid_select_column!], distinct: Boolean): Int!
  max: ipfs_cid_max_fields
  min: ipfs_cid_min_fields
}

"""
Boolean expression to filter rows from the table "ipfs_cid". All fields are combined with a logical 'AND'.
"""
input ipfs_cid_bool_exp {
  _and: [ipfs_cid_bool_exp!]
  _not: ipfs_cid_bool_exp
  _or: [ipfs_cid_bool_exp!]
  cid: String_comparison_exp
}

"""
unique or primary key constraints on table "ipfs_cid"
"""
enum ipfs_cid_constraint {
  """
  unique or primary key constraint on columns "cid"
  """
  PK_9f69103babd8c233ccb8e6312b8
}

"""
input type for inserting data into table "ipfs_cid"
"""
input ipfs_cid_insert_input {
  cid: String
}

"""aggregate max on columns"""
type ipfs_cid_max_fields {
  cid: String
}

"""aggregate min on columns"""
type ipfs_cid_min_fields {
  cid: String
}

"""
response of any mutation on the table "ipfs_cid"
"""
type ipfs_cid_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [ipfs_cid!]!
}

"""
on_conflict condition type for table "ipfs_cid"
"""
input ipfs_cid_on_conflict {
  constraint: ipfs_cid_constraint!
  update_columns: [ipfs_cid_update_column!]! = []
  where: ipfs_cid_bool_exp
}

"""Ordering options when selecting data from "ipfs_cid"."""
input ipfs_cid_order_by {
  cid: order_by
}

"""primary key columns input for table: ipfs_cid"""
input ipfs_cid_pk_columns_input {
  cid: String!
}

"""
select columns of table "ipfs_cid"
"""
enum ipfs_cid_select_column {
  """column name"""
  cid
}

"""
input type for updating data in table "ipfs_cid"
"""
input ipfs_cid_set_input {
  cid: String
}

"""
Streaming cursor of the table "ipfs_cid"
"""
input ipfs_cid_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: ipfs_cid_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input ipfs_cid_stream_cursor_value_input {
  cid: String
}

"""
update columns of table "ipfs_cid"
"""
enum ipfs_cid_update_column {
  """column name"""
  cid
}

input ipfs_cid_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: ipfs_cid_set_input

  """filter the rows which have to be updated"""
  where: ipfs_cid_bool_exp!
}

scalar json

"""
Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'.
"""
input json_comparison_exp {
  _eq: json
  _gt: json
  _gte: json
  _in: [json!]
  _is_null: Boolean
  _lt: json
  _lte: json
  _neq: json
  _nin: [json!]
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp

  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""
columns and relationships of "listing"
"""
type listing {
  accepted_at: timestamptz
  accepted_by_id: String
  amount: numeric!

  """An object relationship"""
  article: article
  article_id: Int
  cancelled_at: timestamptz
  created_at: timestamptz!
  id: String!
  issuer_id: String

  """An object relationship"""
  marketStatByIdVersion: market_stats

  """An object relationship"""
  marketStatByVersionId: market_stats

  """An array relationship"""
  marketStatsHistoriesByFloorlistingversionFloorlistingid(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): [market_stats_history!]!

  """An aggregate relationship"""
  marketStatsHistoriesByFloorlistingversionFloorlistingid_aggregate(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): market_stats_history_aggregate!

  """An array relationship"""
  marketStatsHistoriesByHighestsoldlistingversionHighestsoldlistingid(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): [market_stats_history!]!

  """An aggregate relationship"""
  marketStatsHistoriesByHighestsoldlistingversionHighestsoldlistingid_aggregate(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): market_stats_history_aggregate!

  """An object relationship"""
  market_stat: market_stats

  """An array relationship"""
  market_stats_histories(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): [market_stats_history!]!

  """An aggregate relationship"""
  market_stats_histories_aggregate(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): market_stats_history_aggregate!

  """An object relationship"""
  objkt: objkt
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric!
  royalties: Int!

  """An object relationship"""
  user: user

  """An object relationship"""
  userByAcceptedById: user
  version: Int!
}

"""
aggregated selection of "listing"
"""
type listing_aggregate {
  aggregate: listing_aggregate_fields
  nodes: [listing!]!
}

input listing_aggregate_bool_exp {
  count: listing_aggregate_bool_exp_count
}

input listing_aggregate_bool_exp_count {
  arguments: [listing_select_column!]
  distinct: Boolean
  filter: listing_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "listing"
"""
type listing_aggregate_fields {
  avg: listing_avg_fields
  count(columns: [listing_select_column!], distinct: Boolean): Int!
  max: listing_max_fields
  min: listing_min_fields
  stddev: listing_stddev_fields
  stddev_pop: listing_stddev_pop_fields
  stddev_samp: listing_stddev_samp_fields
  sum: listing_sum_fields
  var_pop: listing_var_pop_fields
  var_samp: listing_var_samp_fields
  variance: listing_variance_fields
}

"""
order by aggregate values of table "listing"
"""
input listing_aggregate_order_by {
  avg: listing_avg_order_by
  count: order_by
  max: listing_max_order_by
  min: listing_min_order_by
  stddev: listing_stddev_order_by
  stddev_pop: listing_stddev_pop_order_by
  stddev_samp: listing_stddev_samp_order_by
  sum: listing_sum_order_by
  var_pop: listing_var_pop_order_by
  var_samp: listing_var_samp_order_by
  variance: listing_variance_order_by
}

"""
input type for inserting array relation for remote table "listing"
"""
input listing_arr_rel_insert_input {
  data: [listing_insert_input!]!

  """upsert condition"""
  on_conflict: listing_on_conflict
}

"""aggregate avg on columns"""
type listing_avg_fields {
  amount: Float
  article_id: Float
  price: Float
  royalties: Float
  version: Float
}

"""
order by avg() on columns of table "listing"
"""
input listing_avg_order_by {
  amount: order_by
  article_id: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""
Boolean expression to filter rows from the table "listing". All fields are combined with a logical 'AND'.
"""
input listing_bool_exp {
  _and: [listing_bool_exp!]
  _not: listing_bool_exp
  _or: [listing_bool_exp!]
  accepted_at: timestamptz_comparison_exp
  accepted_by_id: String_comparison_exp
  amount: numeric_comparison_exp
  article: article_bool_exp
  article_id: Int_comparison_exp
  cancelled_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  issuer_id: String_comparison_exp
  marketStatByIdVersion: market_stats_bool_exp
  marketStatByVersionId: market_stats_bool_exp
  marketStatsHistoriesByFloorlistingversionFloorlistingid: market_stats_history_bool_exp
  marketStatsHistoriesByFloorlistingversionFloorlistingid_aggregate: market_stats_history_aggregate_bool_exp
  marketStatsHistoriesByHighestsoldlistingversionHighestsoldlistingid: market_stats_history_bool_exp
  marketStatsHistoriesByHighestsoldlistingversionHighestsoldlistingid_aggregate: market_stats_history_aggregate_bool_exp
  market_stat: market_stats_bool_exp
  market_stats_histories: market_stats_history_bool_exp
  market_stats_histories_aggregate: market_stats_history_aggregate_bool_exp
  objkt: objkt_bool_exp
  objkt_id: String_comparison_exp
  objkt_issuer_version: generative_token_version_comparison_exp
  price: numeric_comparison_exp
  royalties: Int_comparison_exp
  user: user_bool_exp
  userByAcceptedById: user_bool_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "listing"
"""
enum listing_constraint {
  """
  unique or primary key constraint on columns "id", "version"
  """
  PK_de64402045da3d719189d60f30f
}

"""
input type for incrementing numeric columns in table "listing"
"""
input listing_inc_input {
  amount: numeric
  article_id: Int
  price: numeric
  royalties: Int
  version: Int
}

"""
input type for inserting data into table "listing"
"""
input listing_insert_input {
  accepted_at: timestamptz
  accepted_by_id: String
  amount: numeric
  article: article_obj_rel_insert_input
  article_id: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  issuer_id: String
  marketStatByIdVersion: market_stats_obj_rel_insert_input
  marketStatByVersionId: market_stats_obj_rel_insert_input
  marketStatsHistoriesByFloorlistingversionFloorlistingid: market_stats_history_arr_rel_insert_input
  marketStatsHistoriesByHighestsoldlistingversionHighestsoldlistingid: market_stats_history_arr_rel_insert_input
  market_stat: market_stats_obj_rel_insert_input
  market_stats_histories: market_stats_history_arr_rel_insert_input
  objkt: objkt_obj_rel_insert_input
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  royalties: Int
  user: user_obj_rel_insert_input
  userByAcceptedById: user_obj_rel_insert_input
  version: Int
}

"""aggregate max on columns"""
type listing_max_fields {
  accepted_at: timestamptz
  accepted_by_id: String
  amount: numeric
  article_id: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  issuer_id: String
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  royalties: Int
  version: Int
}

"""
order by max() on columns of table "listing"
"""
input listing_max_order_by {
  accepted_at: order_by
  accepted_by_id: order_by
  amount: order_by
  article_id: order_by
  cancelled_at: order_by
  created_at: order_by
  id: order_by
  issuer_id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""aggregate min on columns"""
type listing_min_fields {
  accepted_at: timestamptz
  accepted_by_id: String
  amount: numeric
  article_id: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  issuer_id: String
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  royalties: Int
  version: Int
}

"""
order by min() on columns of table "listing"
"""
input listing_min_order_by {
  accepted_at: order_by
  accepted_by_id: order_by
  amount: order_by
  article_id: order_by
  cancelled_at: order_by
  created_at: order_by
  id: order_by
  issuer_id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""
response of any mutation on the table "listing"
"""
type listing_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [listing!]!
}

"""
input type for inserting object relation for remote table "listing"
"""
input listing_obj_rel_insert_input {
  data: listing_insert_input!

  """upsert condition"""
  on_conflict: listing_on_conflict
}

"""
on_conflict condition type for table "listing"
"""
input listing_on_conflict {
  constraint: listing_constraint!
  update_columns: [listing_update_column!]! = []
  where: listing_bool_exp
}

"""Ordering options when selecting data from "listing"."""
input listing_order_by {
  accepted_at: order_by
  accepted_by_id: order_by
  amount: order_by
  article: article_order_by
  article_id: order_by
  cancelled_at: order_by
  created_at: order_by
  id: order_by
  issuer_id: order_by
  marketStatByIdVersion: market_stats_order_by
  marketStatByVersionId: market_stats_order_by
  marketStatsHistoriesByFloorlistingversionFloorlistingid_aggregate: market_stats_history_aggregate_order_by
  marketStatsHistoriesByHighestsoldlistingversionHighestsoldlistingid_aggregate: market_stats_history_aggregate_order_by
  market_stat: market_stats_order_by
  market_stats_histories_aggregate: market_stats_history_aggregate_order_by
  objkt: objkt_order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  price: order_by
  royalties: order_by
  user: user_order_by
  userByAcceptedById: user_order_by
  version: order_by
}

"""primary key columns input for table: listing"""
input listing_pk_columns_input {
  id: String!
  version: Int!
}

"""
select columns of table "listing"
"""
enum listing_select_column {
  """column name"""
  accepted_at

  """column name"""
  accepted_by_id

  """column name"""
  amount

  """column name"""
  article_id

  """column name"""
  cancelled_at

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  issuer_id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  price

  """column name"""
  royalties

  """column name"""
  version
}

"""
input type for updating data in table "listing"
"""
input listing_set_input {
  accepted_at: timestamptz
  accepted_by_id: String
  amount: numeric
  article_id: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  issuer_id: String
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  royalties: Int
  version: Int
}

"""aggregate stddev on columns"""
type listing_stddev_fields {
  amount: Float
  article_id: Float
  price: Float
  royalties: Float
  version: Float
}

"""
order by stddev() on columns of table "listing"
"""
input listing_stddev_order_by {
  amount: order_by
  article_id: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""aggregate stddev_pop on columns"""
type listing_stddev_pop_fields {
  amount: Float
  article_id: Float
  price: Float
  royalties: Float
  version: Float
}

"""
order by stddev_pop() on columns of table "listing"
"""
input listing_stddev_pop_order_by {
  amount: order_by
  article_id: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""aggregate stddev_samp on columns"""
type listing_stddev_samp_fields {
  amount: Float
  article_id: Float
  price: Float
  royalties: Float
  version: Float
}

"""
order by stddev_samp() on columns of table "listing"
"""
input listing_stddev_samp_order_by {
  amount: order_by
  article_id: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""
Streaming cursor of the table "listing"
"""
input listing_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: listing_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input listing_stream_cursor_value_input {
  accepted_at: timestamptz
  accepted_by_id: String
  amount: numeric
  article_id: Int
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  issuer_id: String
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  royalties: Int
  version: Int
}

"""aggregate sum on columns"""
type listing_sum_fields {
  amount: numeric
  article_id: Int
  price: numeric
  royalties: Int
  version: Int
}

"""
order by sum() on columns of table "listing"
"""
input listing_sum_order_by {
  amount: order_by
  article_id: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""
update columns of table "listing"
"""
enum listing_update_column {
  """column name"""
  accepted_at

  """column name"""
  accepted_by_id

  """column name"""
  amount

  """column name"""
  article_id

  """column name"""
  cancelled_at

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  issuer_id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  price

  """column name"""
  royalties

  """column name"""
  version
}

input listing_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: listing_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: listing_set_input

  """filter the rows which have to be updated"""
  where: listing_bool_exp!
}

"""aggregate var_pop on columns"""
type listing_var_pop_fields {
  amount: Float
  article_id: Float
  price: Float
  royalties: Float
  version: Float
}

"""
order by var_pop() on columns of table "listing"
"""
input listing_var_pop_order_by {
  amount: order_by
  article_id: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""aggregate var_samp on columns"""
type listing_var_samp_fields {
  amount: Float
  article_id: Float
  price: Float
  royalties: Float
  version: Float
}

"""
order by var_samp() on columns of table "listing"
"""
input listing_var_samp_order_by {
  amount: order_by
  article_id: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""aggregate variance on columns"""
type listing_variance_fields {
  amount: Float
  article_id: Float
  price: Float
  royalties: Float
  version: Float
}

"""
order by variance() on columns of table "listing"
"""
input listing_variance_order_by {
  amount: order_by
  article_id: order_by
  price: order_by
  royalties: order_by
  version: order_by
}

"""
columns and relationships of "market_stats"
"""
type market_stats {
  average_sale_price: numeric
  floor: numeric
  floor7d: numeric
  floor24: numeric
  floor30d: numeric
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz

  """An object relationship"""
  generative_token: generative_token!
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: numeric
  highest_sold: numeric
  highest_sold7d: numeric
  highest_sold24: numeric
  highest_sold30d: numeric
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  listed: Int

  """An object relationship"""
  listing: listing

  """An object relationship"""
  listingByFloorlistingversionFloorlistingid: listing

  """An object relationship"""
  listingByLowestsoldlistingidLowestsoldlistingversion: listing
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: numeric
  lowest_sold7d: numeric
  lowest_sold24: numeric
  lowest_sold30d: numeric
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: numeric
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: numeric
  prim_volume_tz: numeric
  sec_volume_nb: numeric
  sec_volume_nb7d: numeric
  sec_volume_nb24: numeric
  sec_volume_nb30d: numeric
  sec_volume_tz: numeric
  sec_volume_tz7d: numeric
  sec_volume_tz24: numeric
  sec_volume_tz30d: numeric
  to: timestamptz
  token_id: String!
}

"""
aggregated selection of "market_stats"
"""
type market_stats_aggregate {
  aggregate: market_stats_aggregate_fields
  nodes: [market_stats!]!
}

"""
aggregate fields of "market_stats"
"""
type market_stats_aggregate_fields {
  avg: market_stats_avg_fields
  count(columns: [market_stats_select_column!], distinct: Boolean): Int!
  max: market_stats_max_fields
  min: market_stats_min_fields
  stddev: market_stats_stddev_fields
  stddev_pop: market_stats_stddev_pop_fields
  stddev_samp: market_stats_stddev_samp_fields
  sum: market_stats_sum_fields
  var_pop: market_stats_var_pop_fields
  var_samp: market_stats_var_samp_fields
  variance: market_stats_variance_fields
}

"""aggregate avg on columns"""
type market_stats_avg_fields {
  average_sale_price: Float
  floor: Float
  floor7d: Float
  floor24: Float
  floor30d: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold7d: Float
  highest_sold24: Float
  highest_sold30d: Float
  highest_sold_listing_version: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold7d: Float
  lowest_sold24: Float
  lowest_sold30d: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""
Boolean expression to filter rows from the table "market_stats". All fields are combined with a logical 'AND'.
"""
input market_stats_bool_exp {
  _and: [market_stats_bool_exp!]
  _not: market_stats_bool_exp
  _or: [market_stats_bool_exp!]
  average_sale_price: numeric_comparison_exp
  floor: numeric_comparison_exp
  floor7d: numeric_comparison_exp
  floor24: numeric_comparison_exp
  floor30d: numeric_comparison_exp
  floorListingId: String_comparison_exp
  floorListingVersion: Int_comparison_exp
  floor_listing_id: String_comparison_exp
  floor_listing_version: Int_comparison_exp
  from: timestamptz_comparison_exp
  generative_token: generative_token_bool_exp
  highestSoldListingId: String_comparison_exp
  highestSoldListingVersion: Int_comparison_exp
  highest_collection_offer: numeric_comparison_exp
  highest_sold: numeric_comparison_exp
  highest_sold7d: numeric_comparison_exp
  highest_sold24: numeric_comparison_exp
  highest_sold30d: numeric_comparison_exp
  highest_sold_listing_id: String_comparison_exp
  highest_sold_listing_version: Int_comparison_exp
  listed: Int_comparison_exp
  listing: listing_bool_exp
  listingByFloorlistingversionFloorlistingid: listing_bool_exp
  listingByLowestsoldlistingidLowestsoldlistingversion: listing_bool_exp
  longest_average_held_in_seconds: bigint_comparison_exp
  lowestSoldListingId: String_comparison_exp
  lowestSoldListingVersion: Int_comparison_exp
  lowest_sold: numeric_comparison_exp
  lowest_sold7d: numeric_comparison_exp
  lowest_sold24: numeric_comparison_exp
  lowest_sold30d: numeric_comparison_exp
  lowest_sold_listing_id: String_comparison_exp
  lowest_sold_listing_version: Int_comparison_exp
  median: numeric_comparison_exp
  percent_listed: Float_comparison_exp
  percent_never_listed: Float_comparison_exp
  prim_volume_nb: numeric_comparison_exp
  prim_volume_tz: numeric_comparison_exp
  sec_volume_nb: numeric_comparison_exp
  sec_volume_nb7d: numeric_comparison_exp
  sec_volume_nb24: numeric_comparison_exp
  sec_volume_nb30d: numeric_comparison_exp
  sec_volume_tz: numeric_comparison_exp
  sec_volume_tz7d: numeric_comparison_exp
  sec_volume_tz24: numeric_comparison_exp
  sec_volume_tz30d: numeric_comparison_exp
  to: timestamptz_comparison_exp
  token_id: String_comparison_exp
}

"""
unique or primary key constraints on table "market_stats"
"""
enum market_stats_constraint {
  """
  unique or primary key constraint on columns "token_id"
  """
  PK_2e35254ba977f93838b8ac9e9ab

  """
  unique or primary key constraint on columns "highestSoldListingVersion", "highestSoldListingId"
  """
  REL_281e5d025f8c10bbd96377a560

  """
  unique or primary key constraint on columns "floorListingVersion", "floorListingId"
  """
  REL_b47f2fd7c124043ee7765bef61

  """
  unique or primary key constraint on columns "lowestSoldListingId", "lowestSoldListingVersion"
  """
  REL_d1cbd8177ef70881960f87474d
}

"""
columns and relationships of "market_stats_history"
"""
type market_stats_history {
  average_sale_price: bigint
  floor: bigint
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz!

  """An object relationship"""
  generative_token: generative_token!
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: bigint
  highest_sold: bigint
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  id: Int!
  listed: Int

  """An object relationship"""
  listing: listing

  """An object relationship"""
  listingByFloorlistingversionFloorlistingid: listing

  """An object relationship"""
  listingByHighestsoldlistingversionHighestsoldlistingid: listing
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: bigint
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: bigint
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: bigint
  prim_volume_tz: bigint
  sec_volume_nb: bigint
  sec_volume_tz: bigint
  to: timestamptz!
  token_id: String!
}

"""
aggregated selection of "market_stats_history"
"""
type market_stats_history_aggregate {
  aggregate: market_stats_history_aggregate_fields
  nodes: [market_stats_history!]!
}

input market_stats_history_aggregate_bool_exp {
  count: market_stats_history_aggregate_bool_exp_count
}

input market_stats_history_aggregate_bool_exp_count {
  arguments: [market_stats_history_select_column!]
  distinct: Boolean
  filter: market_stats_history_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "market_stats_history"
"""
type market_stats_history_aggregate_fields {
  avg: market_stats_history_avg_fields
  count(columns: [market_stats_history_select_column!], distinct: Boolean): Int!
  max: market_stats_history_max_fields
  min: market_stats_history_min_fields
  stddev: market_stats_history_stddev_fields
  stddev_pop: market_stats_history_stddev_pop_fields
  stddev_samp: market_stats_history_stddev_samp_fields
  sum: market_stats_history_sum_fields
  var_pop: market_stats_history_var_pop_fields
  var_samp: market_stats_history_var_samp_fields
  variance: market_stats_history_variance_fields
}

"""
order by aggregate values of table "market_stats_history"
"""
input market_stats_history_aggregate_order_by {
  avg: market_stats_history_avg_order_by
  count: order_by
  max: market_stats_history_max_order_by
  min: market_stats_history_min_order_by
  stddev: market_stats_history_stddev_order_by
  stddev_pop: market_stats_history_stddev_pop_order_by
  stddev_samp: market_stats_history_stddev_samp_order_by
  sum: market_stats_history_sum_order_by
  var_pop: market_stats_history_var_pop_order_by
  var_samp: market_stats_history_var_samp_order_by
  variance: market_stats_history_variance_order_by
}

"""
input type for inserting array relation for remote table "market_stats_history"
"""
input market_stats_history_arr_rel_insert_input {
  data: [market_stats_history_insert_input!]!

  """upsert condition"""
  on_conflict: market_stats_history_on_conflict
}

"""aggregate avg on columns"""
type market_stats_history_avg_fields {
  average_sale_price: Float
  floor: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold_listing_version: Float
  id: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_tz: Float
}

"""
order by avg() on columns of table "market_stats_history"
"""
input market_stats_history_avg_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingVersion: order_by
  floor_listing_version: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
}

"""
Boolean expression to filter rows from the table "market_stats_history". All fields are combined with a logical 'AND'.
"""
input market_stats_history_bool_exp {
  _and: [market_stats_history_bool_exp!]
  _not: market_stats_history_bool_exp
  _or: [market_stats_history_bool_exp!]
  average_sale_price: bigint_comparison_exp
  floor: bigint_comparison_exp
  floorListingId: String_comparison_exp
  floorListingVersion: Int_comparison_exp
  floor_listing_id: String_comparison_exp
  floor_listing_version: Int_comparison_exp
  from: timestamptz_comparison_exp
  generative_token: generative_token_bool_exp
  highestSoldListingId: String_comparison_exp
  highestSoldListingVersion: Int_comparison_exp
  highest_collection_offer: bigint_comparison_exp
  highest_sold: bigint_comparison_exp
  highest_sold_listing_id: String_comparison_exp
  highest_sold_listing_version: Int_comparison_exp
  id: Int_comparison_exp
  listed: Int_comparison_exp
  listing: listing_bool_exp
  listingByFloorlistingversionFloorlistingid: listing_bool_exp
  listingByHighestsoldlistingversionHighestsoldlistingid: listing_bool_exp
  longest_average_held_in_seconds: bigint_comparison_exp
  lowestSoldListingId: String_comparison_exp
  lowestSoldListingVersion: Int_comparison_exp
  lowest_sold: bigint_comparison_exp
  lowest_sold_listing_id: String_comparison_exp
  lowest_sold_listing_version: Int_comparison_exp
  median: bigint_comparison_exp
  percent_listed: Float_comparison_exp
  percent_never_listed: Float_comparison_exp
  prim_volume_nb: bigint_comparison_exp
  prim_volume_tz: bigint_comparison_exp
  sec_volume_nb: bigint_comparison_exp
  sec_volume_tz: bigint_comparison_exp
  to: timestamptz_comparison_exp
  token_id: String_comparison_exp
}

"""
unique or primary key constraints on table "market_stats_history"
"""
enum market_stats_history_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_aa12f7e0ffa2992946087c870f9
}

"""
input type for incrementing numeric columns in table "market_stats_history"
"""
input market_stats_history_inc_input {
  average_sale_price: bigint
  floor: bigint
  floorListingVersion: Int
  floor_listing_version: Int
  highestSoldListingVersion: Int
  highest_collection_offer: bigint
  highest_sold: bigint
  highest_sold_listing_version: Int
  id: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingVersion: Int
  lowest_sold: bigint
  lowest_sold_listing_version: Int
  median: bigint
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: bigint
  prim_volume_tz: bigint
  sec_volume_nb: bigint
  sec_volume_tz: bigint
}

"""
input type for inserting data into table "market_stats_history"
"""
input market_stats_history_insert_input {
  average_sale_price: bigint
  floor: bigint
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  generative_token: generative_token_obj_rel_insert_input
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: bigint
  highest_sold: bigint
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  id: Int
  listed: Int
  listing: listing_obj_rel_insert_input
  listingByFloorlistingversionFloorlistingid: listing_obj_rel_insert_input
  listingByHighestsoldlistingversionHighestsoldlistingid: listing_obj_rel_insert_input
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: bigint
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: bigint
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: bigint
  prim_volume_tz: bigint
  sec_volume_nb: bigint
  sec_volume_tz: bigint
  to: timestamptz
  token_id: String
}

"""aggregate max on columns"""
type market_stats_history_max_fields {
  average_sale_price: bigint
  floor: bigint
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: bigint
  highest_sold: bigint
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  id: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: bigint
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: bigint
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: bigint
  prim_volume_tz: bigint
  sec_volume_nb: bigint
  sec_volume_tz: bigint
  to: timestamptz
  token_id: String
}

"""
order by max() on columns of table "market_stats_history"
"""
input market_stats_history_max_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingId: order_by
  floorListingVersion: order_by
  floor_listing_id: order_by
  floor_listing_version: order_by
  from: order_by
  highestSoldListingId: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_id: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingId: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_id: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
  to: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type market_stats_history_min_fields {
  average_sale_price: bigint
  floor: bigint
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: bigint
  highest_sold: bigint
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  id: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: bigint
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: bigint
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: bigint
  prim_volume_tz: bigint
  sec_volume_nb: bigint
  sec_volume_tz: bigint
  to: timestamptz
  token_id: String
}

"""
order by min() on columns of table "market_stats_history"
"""
input market_stats_history_min_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingId: order_by
  floorListingVersion: order_by
  floor_listing_id: order_by
  floor_listing_version: order_by
  from: order_by
  highestSoldListingId: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_id: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingId: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_id: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
  to: order_by
  token_id: order_by
}

"""
response of any mutation on the table "market_stats_history"
"""
type market_stats_history_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [market_stats_history!]!
}

"""
on_conflict condition type for table "market_stats_history"
"""
input market_stats_history_on_conflict {
  constraint: market_stats_history_constraint!
  update_columns: [market_stats_history_update_column!]! = []
  where: market_stats_history_bool_exp
}

"""Ordering options when selecting data from "market_stats_history"."""
input market_stats_history_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingId: order_by
  floorListingVersion: order_by
  floor_listing_id: order_by
  floor_listing_version: order_by
  from: order_by
  generative_token: generative_token_order_by
  highestSoldListingId: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_id: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  listing: listing_order_by
  listingByFloorlistingversionFloorlistingid: listing_order_by
  listingByHighestsoldlistingversionHighestsoldlistingid: listing_order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingId: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_id: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
  to: order_by
  token_id: order_by
}

"""primary key columns input for table: market_stats_history"""
input market_stats_history_pk_columns_input {
  id: Int!
}

"""
select columns of table "market_stats_history"
"""
enum market_stats_history_select_column {
  """column name"""
  average_sale_price

  """column name"""
  floor

  """column name"""
  floorListingId

  """column name"""
  floorListingVersion

  """column name"""
  floor_listing_id

  """column name"""
  floor_listing_version

  """column name"""
  from

  """column name"""
  highestSoldListingId

  """column name"""
  highestSoldListingVersion

  """column name"""
  highest_collection_offer

  """column name"""
  highest_sold

  """column name"""
  highest_sold_listing_id

  """column name"""
  highest_sold_listing_version

  """column name"""
  id

  """column name"""
  listed

  """column name"""
  longest_average_held_in_seconds

  """column name"""
  lowestSoldListingId

  """column name"""
  lowestSoldListingVersion

  """column name"""
  lowest_sold

  """column name"""
  lowest_sold_listing_id

  """column name"""
  lowest_sold_listing_version

  """column name"""
  median

  """column name"""
  percent_listed

  """column name"""
  percent_never_listed

  """column name"""
  prim_volume_nb

  """column name"""
  prim_volume_tz

  """column name"""
  sec_volume_nb

  """column name"""
  sec_volume_tz

  """column name"""
  to

  """column name"""
  token_id
}

"""
input type for updating data in table "market_stats_history"
"""
input market_stats_history_set_input {
  average_sale_price: bigint
  floor: bigint
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: bigint
  highest_sold: bigint
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  id: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: bigint
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: bigint
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: bigint
  prim_volume_tz: bigint
  sec_volume_nb: bigint
  sec_volume_tz: bigint
  to: timestamptz
  token_id: String
}

"""aggregate stddev on columns"""
type market_stats_history_stddev_fields {
  average_sale_price: Float
  floor: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold_listing_version: Float
  id: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_tz: Float
}

"""
order by stddev() on columns of table "market_stats_history"
"""
input market_stats_history_stddev_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingVersion: order_by
  floor_listing_version: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
}

"""aggregate stddev_pop on columns"""
type market_stats_history_stddev_pop_fields {
  average_sale_price: Float
  floor: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold_listing_version: Float
  id: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_tz: Float
}

"""
order by stddev_pop() on columns of table "market_stats_history"
"""
input market_stats_history_stddev_pop_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingVersion: order_by
  floor_listing_version: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
}

"""aggregate stddev_samp on columns"""
type market_stats_history_stddev_samp_fields {
  average_sale_price: Float
  floor: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold_listing_version: Float
  id: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_tz: Float
}

"""
order by stddev_samp() on columns of table "market_stats_history"
"""
input market_stats_history_stddev_samp_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingVersion: order_by
  floor_listing_version: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
}

"""
Streaming cursor of the table "market_stats_history"
"""
input market_stats_history_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: market_stats_history_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input market_stats_history_stream_cursor_value_input {
  average_sale_price: bigint
  floor: bigint
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: bigint
  highest_sold: bigint
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  id: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: bigint
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: bigint
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: bigint
  prim_volume_tz: bigint
  sec_volume_nb: bigint
  sec_volume_tz: bigint
  to: timestamptz
  token_id: String
}

"""aggregate sum on columns"""
type market_stats_history_sum_fields {
  average_sale_price: bigint
  floor: bigint
  floorListingVersion: Int
  floor_listing_version: Int
  highestSoldListingVersion: Int
  highest_collection_offer: bigint
  highest_sold: bigint
  highest_sold_listing_version: Int
  id: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingVersion: Int
  lowest_sold: bigint
  lowest_sold_listing_version: Int
  median: bigint
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: bigint
  prim_volume_tz: bigint
  sec_volume_nb: bigint
  sec_volume_tz: bigint
}

"""
order by sum() on columns of table "market_stats_history"
"""
input market_stats_history_sum_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingVersion: order_by
  floor_listing_version: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
}

"""
update columns of table "market_stats_history"
"""
enum market_stats_history_update_column {
  """column name"""
  average_sale_price

  """column name"""
  floor

  """column name"""
  floorListingId

  """column name"""
  floorListingVersion

  """column name"""
  floor_listing_id

  """column name"""
  floor_listing_version

  """column name"""
  from

  """column name"""
  highestSoldListingId

  """column name"""
  highestSoldListingVersion

  """column name"""
  highest_collection_offer

  """column name"""
  highest_sold

  """column name"""
  highest_sold_listing_id

  """column name"""
  highest_sold_listing_version

  """column name"""
  id

  """column name"""
  listed

  """column name"""
  longest_average_held_in_seconds

  """column name"""
  lowestSoldListingId

  """column name"""
  lowestSoldListingVersion

  """column name"""
  lowest_sold

  """column name"""
  lowest_sold_listing_id

  """column name"""
  lowest_sold_listing_version

  """column name"""
  median

  """column name"""
  percent_listed

  """column name"""
  percent_never_listed

  """column name"""
  prim_volume_nb

  """column name"""
  prim_volume_tz

  """column name"""
  sec_volume_nb

  """column name"""
  sec_volume_tz

  """column name"""
  to

  """column name"""
  token_id
}

input market_stats_history_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: market_stats_history_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: market_stats_history_set_input

  """filter the rows which have to be updated"""
  where: market_stats_history_bool_exp!
}

"""aggregate var_pop on columns"""
type market_stats_history_var_pop_fields {
  average_sale_price: Float
  floor: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold_listing_version: Float
  id: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_tz: Float
}

"""
order by var_pop() on columns of table "market_stats_history"
"""
input market_stats_history_var_pop_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingVersion: order_by
  floor_listing_version: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
}

"""aggregate var_samp on columns"""
type market_stats_history_var_samp_fields {
  average_sale_price: Float
  floor: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold_listing_version: Float
  id: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_tz: Float
}

"""
order by var_samp() on columns of table "market_stats_history"
"""
input market_stats_history_var_samp_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingVersion: order_by
  floor_listing_version: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
}

"""aggregate variance on columns"""
type market_stats_history_variance_fields {
  average_sale_price: Float
  floor: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold_listing_version: Float
  id: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_tz: Float
}

"""
order by variance() on columns of table "market_stats_history"
"""
input market_stats_history_variance_order_by {
  average_sale_price: order_by
  floor: order_by
  floorListingVersion: order_by
  floor_listing_version: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold_listing_version: order_by
  id: order_by
  listed: order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_tz: order_by
}

"""
input type for incrementing numeric columns in table "market_stats"
"""
input market_stats_inc_input {
  average_sale_price: numeric
  floor: numeric
  floor7d: numeric
  floor24: numeric
  floor30d: numeric
  floorListingVersion: Int
  floor_listing_version: Int
  highestSoldListingVersion: Int
  highest_collection_offer: numeric
  highest_sold: numeric
  highest_sold7d: numeric
  highest_sold24: numeric
  highest_sold30d: numeric
  highest_sold_listing_version: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingVersion: Int
  lowest_sold: numeric
  lowest_sold7d: numeric
  lowest_sold24: numeric
  lowest_sold30d: numeric
  lowest_sold_listing_version: Int
  median: numeric
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: numeric
  prim_volume_tz: numeric
  sec_volume_nb: numeric
  sec_volume_nb7d: numeric
  sec_volume_nb24: numeric
  sec_volume_nb30d: numeric
  sec_volume_tz: numeric
  sec_volume_tz7d: numeric
  sec_volume_tz24: numeric
  sec_volume_tz30d: numeric
}

"""
input type for inserting data into table "market_stats"
"""
input market_stats_insert_input {
  average_sale_price: numeric
  floor: numeric
  floor7d: numeric
  floor24: numeric
  floor30d: numeric
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  generative_token: generative_token_obj_rel_insert_input
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: numeric
  highest_sold: numeric
  highest_sold7d: numeric
  highest_sold24: numeric
  highest_sold30d: numeric
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  listed: Int
  listing: listing_obj_rel_insert_input
  listingByFloorlistingversionFloorlistingid: listing_obj_rel_insert_input
  listingByLowestsoldlistingidLowestsoldlistingversion: listing_obj_rel_insert_input
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: numeric
  lowest_sold7d: numeric
  lowest_sold24: numeric
  lowest_sold30d: numeric
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: numeric
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: numeric
  prim_volume_tz: numeric
  sec_volume_nb: numeric
  sec_volume_nb7d: numeric
  sec_volume_nb24: numeric
  sec_volume_nb30d: numeric
  sec_volume_tz: numeric
  sec_volume_tz7d: numeric
  sec_volume_tz24: numeric
  sec_volume_tz30d: numeric
  to: timestamptz
  token_id: String
}

"""aggregate max on columns"""
type market_stats_max_fields {
  average_sale_price: numeric
  floor: numeric
  floor7d: numeric
  floor24: numeric
  floor30d: numeric
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: numeric
  highest_sold: numeric
  highest_sold7d: numeric
  highest_sold24: numeric
  highest_sold30d: numeric
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: numeric
  lowest_sold7d: numeric
  lowest_sold24: numeric
  lowest_sold30d: numeric
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: numeric
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: numeric
  prim_volume_tz: numeric
  sec_volume_nb: numeric
  sec_volume_nb7d: numeric
  sec_volume_nb24: numeric
  sec_volume_nb30d: numeric
  sec_volume_tz: numeric
  sec_volume_tz7d: numeric
  sec_volume_tz24: numeric
  sec_volume_tz30d: numeric
  to: timestamptz
  token_id: String
}

"""aggregate min on columns"""
type market_stats_min_fields {
  average_sale_price: numeric
  floor: numeric
  floor7d: numeric
  floor24: numeric
  floor30d: numeric
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: numeric
  highest_sold: numeric
  highest_sold7d: numeric
  highest_sold24: numeric
  highest_sold30d: numeric
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: numeric
  lowest_sold7d: numeric
  lowest_sold24: numeric
  lowest_sold30d: numeric
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: numeric
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: numeric
  prim_volume_tz: numeric
  sec_volume_nb: numeric
  sec_volume_nb7d: numeric
  sec_volume_nb24: numeric
  sec_volume_nb30d: numeric
  sec_volume_tz: numeric
  sec_volume_tz7d: numeric
  sec_volume_tz24: numeric
  sec_volume_tz30d: numeric
  to: timestamptz
  token_id: String
}

"""
response of any mutation on the table "market_stats"
"""
type market_stats_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [market_stats!]!
}

"""
input type for inserting object relation for remote table "market_stats"
"""
input market_stats_obj_rel_insert_input {
  data: market_stats_insert_input!

  """upsert condition"""
  on_conflict: market_stats_on_conflict
}

"""
on_conflict condition type for table "market_stats"
"""
input market_stats_on_conflict {
  constraint: market_stats_constraint!
  update_columns: [market_stats_update_column!]! = []
  where: market_stats_bool_exp
}

"""Ordering options when selecting data from "market_stats"."""
input market_stats_order_by {
  average_sale_price: order_by
  floor: order_by
  floor7d: order_by
  floor24: order_by
  floor30d: order_by
  floorListingId: order_by
  floorListingVersion: order_by
  floor_listing_id: order_by
  floor_listing_version: order_by
  from: order_by
  generative_token: generative_token_order_by
  highestSoldListingId: order_by
  highestSoldListingVersion: order_by
  highest_collection_offer: order_by
  highest_sold: order_by
  highest_sold7d: order_by
  highest_sold24: order_by
  highest_sold30d: order_by
  highest_sold_listing_id: order_by
  highest_sold_listing_version: order_by
  listed: order_by
  listing: listing_order_by
  listingByFloorlistingversionFloorlistingid: listing_order_by
  listingByLowestsoldlistingidLowestsoldlistingversion: listing_order_by
  longest_average_held_in_seconds: order_by
  lowestSoldListingId: order_by
  lowestSoldListingVersion: order_by
  lowest_sold: order_by
  lowest_sold7d: order_by
  lowest_sold24: order_by
  lowest_sold30d: order_by
  lowest_sold_listing_id: order_by
  lowest_sold_listing_version: order_by
  median: order_by
  percent_listed: order_by
  percent_never_listed: order_by
  prim_volume_nb: order_by
  prim_volume_tz: order_by
  sec_volume_nb: order_by
  sec_volume_nb7d: order_by
  sec_volume_nb24: order_by
  sec_volume_nb30d: order_by
  sec_volume_tz: order_by
  sec_volume_tz7d: order_by
  sec_volume_tz24: order_by
  sec_volume_tz30d: order_by
  to: order_by
  token_id: order_by
}

"""primary key columns input for table: market_stats"""
input market_stats_pk_columns_input {
  token_id: String!
}

"""
select columns of table "market_stats"
"""
enum market_stats_select_column {
  """column name"""
  average_sale_price

  """column name"""
  floor

  """column name"""
  floor7d

  """column name"""
  floor24

  """column name"""
  floor30d

  """column name"""
  floorListingId

  """column name"""
  floorListingVersion

  """column name"""
  floor_listing_id

  """column name"""
  floor_listing_version

  """column name"""
  from

  """column name"""
  highestSoldListingId

  """column name"""
  highestSoldListingVersion

  """column name"""
  highest_collection_offer

  """column name"""
  highest_sold

  """column name"""
  highest_sold7d

  """column name"""
  highest_sold24

  """column name"""
  highest_sold30d

  """column name"""
  highest_sold_listing_id

  """column name"""
  highest_sold_listing_version

  """column name"""
  listed

  """column name"""
  longest_average_held_in_seconds

  """column name"""
  lowestSoldListingId

  """column name"""
  lowestSoldListingVersion

  """column name"""
  lowest_sold

  """column name"""
  lowest_sold7d

  """column name"""
  lowest_sold24

  """column name"""
  lowest_sold30d

  """column name"""
  lowest_sold_listing_id

  """column name"""
  lowest_sold_listing_version

  """column name"""
  median

  """column name"""
  percent_listed

  """column name"""
  percent_never_listed

  """column name"""
  prim_volume_nb

  """column name"""
  prim_volume_tz

  """column name"""
  sec_volume_nb

  """column name"""
  sec_volume_nb7d

  """column name"""
  sec_volume_nb24

  """column name"""
  sec_volume_nb30d

  """column name"""
  sec_volume_tz

  """column name"""
  sec_volume_tz7d

  """column name"""
  sec_volume_tz24

  """column name"""
  sec_volume_tz30d

  """column name"""
  to

  """column name"""
  token_id
}

"""
input type for updating data in table "market_stats"
"""
input market_stats_set_input {
  average_sale_price: numeric
  floor: numeric
  floor7d: numeric
  floor24: numeric
  floor30d: numeric
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: numeric
  highest_sold: numeric
  highest_sold7d: numeric
  highest_sold24: numeric
  highest_sold30d: numeric
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: numeric
  lowest_sold7d: numeric
  lowest_sold24: numeric
  lowest_sold30d: numeric
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: numeric
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: numeric
  prim_volume_tz: numeric
  sec_volume_nb: numeric
  sec_volume_nb7d: numeric
  sec_volume_nb24: numeric
  sec_volume_nb30d: numeric
  sec_volume_tz: numeric
  sec_volume_tz7d: numeric
  sec_volume_tz24: numeric
  sec_volume_tz30d: numeric
  to: timestamptz
  token_id: String
}

"""aggregate stddev on columns"""
type market_stats_stddev_fields {
  average_sale_price: Float
  floor: Float
  floor7d: Float
  floor24: Float
  floor30d: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold7d: Float
  highest_sold24: Float
  highest_sold30d: Float
  highest_sold_listing_version: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold7d: Float
  lowest_sold24: Float
  lowest_sold30d: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""aggregate stddev_pop on columns"""
type market_stats_stddev_pop_fields {
  average_sale_price: Float
  floor: Float
  floor7d: Float
  floor24: Float
  floor30d: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold7d: Float
  highest_sold24: Float
  highest_sold30d: Float
  highest_sold_listing_version: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold7d: Float
  lowest_sold24: Float
  lowest_sold30d: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""aggregate stddev_samp on columns"""
type market_stats_stddev_samp_fields {
  average_sale_price: Float
  floor: Float
  floor7d: Float
  floor24: Float
  floor30d: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold7d: Float
  highest_sold24: Float
  highest_sold30d: Float
  highest_sold_listing_version: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold7d: Float
  lowest_sold24: Float
  lowest_sold30d: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""
Streaming cursor of the table "market_stats"
"""
input market_stats_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: market_stats_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input market_stats_stream_cursor_value_input {
  average_sale_price: numeric
  floor: numeric
  floor7d: numeric
  floor24: numeric
  floor30d: numeric
  floorListingId: String
  floorListingVersion: Int
  floor_listing_id: String
  floor_listing_version: Int
  from: timestamptz
  highestSoldListingId: String
  highestSoldListingVersion: Int
  highest_collection_offer: numeric
  highest_sold: numeric
  highest_sold7d: numeric
  highest_sold24: numeric
  highest_sold30d: numeric
  highest_sold_listing_id: String
  highest_sold_listing_version: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingId: String
  lowestSoldListingVersion: Int
  lowest_sold: numeric
  lowest_sold7d: numeric
  lowest_sold24: numeric
  lowest_sold30d: numeric
  lowest_sold_listing_id: String
  lowest_sold_listing_version: Int
  median: numeric
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: numeric
  prim_volume_tz: numeric
  sec_volume_nb: numeric
  sec_volume_nb7d: numeric
  sec_volume_nb24: numeric
  sec_volume_nb30d: numeric
  sec_volume_tz: numeric
  sec_volume_tz7d: numeric
  sec_volume_tz24: numeric
  sec_volume_tz30d: numeric
  to: timestamptz
  token_id: String
}

"""aggregate sum on columns"""
type market_stats_sum_fields {
  average_sale_price: numeric
  floor: numeric
  floor7d: numeric
  floor24: numeric
  floor30d: numeric
  floorListingVersion: Int
  floor_listing_version: Int
  highestSoldListingVersion: Int
  highest_collection_offer: numeric
  highest_sold: numeric
  highest_sold7d: numeric
  highest_sold24: numeric
  highest_sold30d: numeric
  highest_sold_listing_version: Int
  listed: Int
  longest_average_held_in_seconds: bigint
  lowestSoldListingVersion: Int
  lowest_sold: numeric
  lowest_sold7d: numeric
  lowest_sold24: numeric
  lowest_sold30d: numeric
  lowest_sold_listing_version: Int
  median: numeric
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: numeric
  prim_volume_tz: numeric
  sec_volume_nb: numeric
  sec_volume_nb7d: numeric
  sec_volume_nb24: numeric
  sec_volume_nb30d: numeric
  sec_volume_tz: numeric
  sec_volume_tz7d: numeric
  sec_volume_tz24: numeric
  sec_volume_tz30d: numeric
}

"""
update columns of table "market_stats"
"""
enum market_stats_update_column {
  """column name"""
  average_sale_price

  """column name"""
  floor

  """column name"""
  floor7d

  """column name"""
  floor24

  """column name"""
  floor30d

  """column name"""
  floorListingId

  """column name"""
  floorListingVersion

  """column name"""
  floor_listing_id

  """column name"""
  floor_listing_version

  """column name"""
  from

  """column name"""
  highestSoldListingId

  """column name"""
  highestSoldListingVersion

  """column name"""
  highest_collection_offer

  """column name"""
  highest_sold

  """column name"""
  highest_sold7d

  """column name"""
  highest_sold24

  """column name"""
  highest_sold30d

  """column name"""
  highest_sold_listing_id

  """column name"""
  highest_sold_listing_version

  """column name"""
  listed

  """column name"""
  longest_average_held_in_seconds

  """column name"""
  lowestSoldListingId

  """column name"""
  lowestSoldListingVersion

  """column name"""
  lowest_sold

  """column name"""
  lowest_sold7d

  """column name"""
  lowest_sold24

  """column name"""
  lowest_sold30d

  """column name"""
  lowest_sold_listing_id

  """column name"""
  lowest_sold_listing_version

  """column name"""
  median

  """column name"""
  percent_listed

  """column name"""
  percent_never_listed

  """column name"""
  prim_volume_nb

  """column name"""
  prim_volume_tz

  """column name"""
  sec_volume_nb

  """column name"""
  sec_volume_nb7d

  """column name"""
  sec_volume_nb24

  """column name"""
  sec_volume_nb30d

  """column name"""
  sec_volume_tz

  """column name"""
  sec_volume_tz7d

  """column name"""
  sec_volume_tz24

  """column name"""
  sec_volume_tz30d

  """column name"""
  to

  """column name"""
  token_id
}

input market_stats_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: market_stats_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: market_stats_set_input

  """filter the rows which have to be updated"""
  where: market_stats_bool_exp!
}

"""aggregate var_pop on columns"""
type market_stats_var_pop_fields {
  average_sale_price: Float
  floor: Float
  floor7d: Float
  floor24: Float
  floor30d: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold7d: Float
  highest_sold24: Float
  highest_sold30d: Float
  highest_sold_listing_version: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold7d: Float
  lowest_sold24: Float
  lowest_sold30d: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""aggregate var_samp on columns"""
type market_stats_var_samp_fields {
  average_sale_price: Float
  floor: Float
  floor7d: Float
  floor24: Float
  floor30d: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold7d: Float
  highest_sold24: Float
  highest_sold30d: Float
  highest_sold_listing_version: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold7d: Float
  lowest_sold24: Float
  lowest_sold30d: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""aggregate variance on columns"""
type market_stats_variance_fields {
  average_sale_price: Float
  floor: Float
  floor7d: Float
  floor24: Float
  floor30d: Float
  floorListingVersion: Float
  floor_listing_version: Float
  highestSoldListingVersion: Float
  highest_collection_offer: Float
  highest_sold: Float
  highest_sold7d: Float
  highest_sold24: Float
  highest_sold30d: Float
  highest_sold_listing_version: Float
  listed: Float
  longest_average_held_in_seconds: Float
  lowestSoldListingVersion: Float
  lowest_sold: Float
  lowest_sold7d: Float
  lowest_sold24: Float
  lowest_sold30d: Float
  lowest_sold_listing_version: Float
  median: Float
  percent_listed: Float
  percent_never_listed: Float
  prim_volume_nb: Float
  prim_volume_tz: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""
columns and relationships of "media_image"
"""
type media_image {
  """An array relationship"""
  articles(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): [article!]!

  """An aggregate relationship"""
  articles_aggregate(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): article_aggregate!
  cid: bpchar!

  """An array relationship"""
  generative_tokens(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): [generative_token!]!

  """An aggregate relationship"""
  generative_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): generative_token_aggregate!
  height: Int
  metadata(
    """JSON select path"""
    path: String
  ): json
  mime_type: String

  """An array relationship"""
  mint_ticket_settings(
    """distinct select on columns"""
    distinct_on: [mint_ticket_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_settings_order_by!]

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): [mint_ticket_settings!]!

  """An aggregate relationship"""
  mint_ticket_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_ticket_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_settings_order_by!]

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): mint_ticket_settings_aggregate!

  """An array relationship"""
  objkts(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): [objkt!]!

  """An aggregate relationship"""
  objkts_aggregate(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): objkt_aggregate!
  placeholder: String
  process_counters: smallint!
  processed: Boolean!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!
  width: Int
}

"""
aggregated selection of "media_image"
"""
type media_image_aggregate {
  aggregate: media_image_aggregate_fields
  nodes: [media_image!]!
}

"""
aggregate fields of "media_image"
"""
type media_image_aggregate_fields {
  avg: media_image_avg_fields
  count(columns: [media_image_select_column!], distinct: Boolean): Int!
  max: media_image_max_fields
  min: media_image_min_fields
  stddev: media_image_stddev_fields
  stddev_pop: media_image_stddev_pop_fields
  stddev_samp: media_image_stddev_samp_fields
  sum: media_image_sum_fields
  var_pop: media_image_var_pop_fields
  var_samp: media_image_var_samp_fields
  variance: media_image_variance_fields
}

"""aggregate avg on columns"""
type media_image_avg_fields {
  height: Float
  process_counters: Float
  width: Float
}

"""
Boolean expression to filter rows from the table "media_image". All fields are combined with a logical 'AND'.
"""
input media_image_bool_exp {
  _and: [media_image_bool_exp!]
  _not: media_image_bool_exp
  _or: [media_image_bool_exp!]
  articles: article_bool_exp
  articles_aggregate: article_aggregate_bool_exp
  cid: bpchar_comparison_exp
  generative_tokens: generative_token_bool_exp
  generative_tokens_aggregate: generative_token_aggregate_bool_exp
  height: Int_comparison_exp
  metadata: json_comparison_exp
  mime_type: String_comparison_exp
  mint_ticket_settings: mint_ticket_settings_bool_exp
  mint_ticket_settings_aggregate: mint_ticket_settings_aggregate_bool_exp
  objkts: objkt_bool_exp
  objkts_aggregate: objkt_aggregate_bool_exp
  placeholder: String_comparison_exp
  process_counters: smallint_comparison_exp
  processed: Boolean_comparison_exp
  users: user_bool_exp
  users_aggregate: user_aggregate_bool_exp
  width: Int_comparison_exp
}

"""
unique or primary key constraints on table "media_image"
"""
enum media_image_constraint {
  """
  unique or primary key constraint on columns "cid"
  """
  PK_6b20376a151c97894a44a572715
}

"""
input type for incrementing numeric columns in table "media_image"
"""
input media_image_inc_input {
  height: Int
  process_counters: smallint
  width: Int
}

"""
input type for inserting data into table "media_image"
"""
input media_image_insert_input {
  articles: article_arr_rel_insert_input
  cid: bpchar
  generative_tokens: generative_token_arr_rel_insert_input
  height: Int
  metadata: json
  mime_type: String
  mint_ticket_settings: mint_ticket_settings_arr_rel_insert_input
  objkts: objkt_arr_rel_insert_input
  placeholder: String
  process_counters: smallint
  processed: Boolean
  users: user_arr_rel_insert_input
  width: Int
}

"""aggregate max on columns"""
type media_image_max_fields {
  cid: bpchar
  height: Int
  mime_type: String
  placeholder: String
  process_counters: smallint
  width: Int
}

"""aggregate min on columns"""
type media_image_min_fields {
  cid: bpchar
  height: Int
  mime_type: String
  placeholder: String
  process_counters: smallint
  width: Int
}

"""
response of any mutation on the table "media_image"
"""
type media_image_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [media_image!]!
}

"""
input type for inserting object relation for remote table "media_image"
"""
input media_image_obj_rel_insert_input {
  data: media_image_insert_input!

  """upsert condition"""
  on_conflict: media_image_on_conflict
}

"""
on_conflict condition type for table "media_image"
"""
input media_image_on_conflict {
  constraint: media_image_constraint!
  update_columns: [media_image_update_column!]! = []
  where: media_image_bool_exp
}

"""Ordering options when selecting data from "media_image"."""
input media_image_order_by {
  articles_aggregate: article_aggregate_order_by
  cid: order_by
  generative_tokens_aggregate: generative_token_aggregate_order_by
  height: order_by
  metadata: order_by
  mime_type: order_by
  mint_ticket_settings_aggregate: mint_ticket_settings_aggregate_order_by
  objkts_aggregate: objkt_aggregate_order_by
  placeholder: order_by
  process_counters: order_by
  processed: order_by
  users_aggregate: user_aggregate_order_by
  width: order_by
}

"""primary key columns input for table: media_image"""
input media_image_pk_columns_input {
  cid: bpchar!
}

"""
select columns of table "media_image"
"""
enum media_image_select_column {
  """column name"""
  cid

  """column name"""
  height

  """column name"""
  metadata

  """column name"""
  mime_type

  """column name"""
  placeholder

  """column name"""
  process_counters

  """column name"""
  processed

  """column name"""
  width
}

"""
input type for updating data in table "media_image"
"""
input media_image_set_input {
  cid: bpchar
  height: Int
  metadata: json
  mime_type: String
  placeholder: String
  process_counters: smallint
  processed: Boolean
  width: Int
}

"""aggregate stddev on columns"""
type media_image_stddev_fields {
  height: Float
  process_counters: Float
  width: Float
}

"""aggregate stddev_pop on columns"""
type media_image_stddev_pop_fields {
  height: Float
  process_counters: Float
  width: Float
}

"""aggregate stddev_samp on columns"""
type media_image_stddev_samp_fields {
  height: Float
  process_counters: Float
  width: Float
}

"""
Streaming cursor of the table "media_image"
"""
input media_image_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: media_image_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input media_image_stream_cursor_value_input {
  cid: bpchar
  height: Int
  metadata: json
  mime_type: String
  placeholder: String
  process_counters: smallint
  processed: Boolean
  width: Int
}

"""aggregate sum on columns"""
type media_image_sum_fields {
  height: Int
  process_counters: smallint
  width: Int
}

"""
update columns of table "media_image"
"""
enum media_image_update_column {
  """column name"""
  cid

  """column name"""
  height

  """column name"""
  metadata

  """column name"""
  mime_type

  """column name"""
  placeholder

  """column name"""
  process_counters

  """column name"""
  processed

  """column name"""
  width
}

input media_image_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: media_image_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: media_image_set_input

  """filter the rows which have to be updated"""
  where: media_image_bool_exp!
}

"""aggregate var_pop on columns"""
type media_image_var_pop_fields {
  height: Float
  process_counters: Float
  width: Float
}

"""aggregate var_samp on columns"""
type media_image_var_samp_fields {
  height: Float
  process_counters: Float
  width: Float
}

"""aggregate variance on columns"""
type media_image_variance_fields {
  height: Float
  process_counters: Float
  width: Float
}

"""
columns and relationships of "mint_ticket"
"""
type mint_ticket {
  created_at: timestamptz!

  """An object relationship"""
  generative_token: generative_token
  id: String!
  owner_id: String!
  price: numeric!
  taxation_locked: numeric!
  taxation_paid_until: timestamptz!
  taxation_start: timestamptz!
  token_id: String

  """An object relationship"""
  user: user!
}

"""
aggregated selection of "mint_ticket"
"""
type mint_ticket_aggregate {
  aggregate: mint_ticket_aggregate_fields
  nodes: [mint_ticket!]!
}

input mint_ticket_aggregate_bool_exp {
  count: mint_ticket_aggregate_bool_exp_count
}

input mint_ticket_aggregate_bool_exp_count {
  arguments: [mint_ticket_select_column!]
  distinct: Boolean
  filter: mint_ticket_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "mint_ticket"
"""
type mint_ticket_aggregate_fields {
  avg: mint_ticket_avg_fields
  count(columns: [mint_ticket_select_column!], distinct: Boolean): Int!
  max: mint_ticket_max_fields
  min: mint_ticket_min_fields
  stddev: mint_ticket_stddev_fields
  stddev_pop: mint_ticket_stddev_pop_fields
  stddev_samp: mint_ticket_stddev_samp_fields
  sum: mint_ticket_sum_fields
  var_pop: mint_ticket_var_pop_fields
  var_samp: mint_ticket_var_samp_fields
  variance: mint_ticket_variance_fields
}

"""
order by aggregate values of table "mint_ticket"
"""
input mint_ticket_aggregate_order_by {
  avg: mint_ticket_avg_order_by
  count: order_by
  max: mint_ticket_max_order_by
  min: mint_ticket_min_order_by
  stddev: mint_ticket_stddev_order_by
  stddev_pop: mint_ticket_stddev_pop_order_by
  stddev_samp: mint_ticket_stddev_samp_order_by
  sum: mint_ticket_sum_order_by
  var_pop: mint_ticket_var_pop_order_by
  var_samp: mint_ticket_var_samp_order_by
  variance: mint_ticket_variance_order_by
}

"""
input type for inserting array relation for remote table "mint_ticket"
"""
input mint_ticket_arr_rel_insert_input {
  data: [mint_ticket_insert_input!]!

  """upsert condition"""
  on_conflict: mint_ticket_on_conflict
}

"""aggregate avg on columns"""
type mint_ticket_avg_fields {
  price: Float
  taxation_locked: Float
}

"""
order by avg() on columns of table "mint_ticket"
"""
input mint_ticket_avg_order_by {
  price: order_by
  taxation_locked: order_by
}

"""
Boolean expression to filter rows from the table "mint_ticket". All fields are combined with a logical 'AND'.
"""
input mint_ticket_bool_exp {
  _and: [mint_ticket_bool_exp!]
  _not: mint_ticket_bool_exp
  _or: [mint_ticket_bool_exp!]
  created_at: timestamptz_comparison_exp
  generative_token: generative_token_bool_exp
  id: String_comparison_exp
  owner_id: String_comparison_exp
  price: numeric_comparison_exp
  taxation_locked: numeric_comparison_exp
  taxation_paid_until: timestamptz_comparison_exp
  taxation_start: timestamptz_comparison_exp
  token_id: String_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "mint_ticket"
"""
enum mint_ticket_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_703bfcfef7f2257bf4815fb59d1
}

"""
input type for incrementing numeric columns in table "mint_ticket"
"""
input mint_ticket_inc_input {
  price: numeric
  taxation_locked: numeric
}

"""
input type for inserting data into table "mint_ticket"
"""
input mint_ticket_insert_input {
  created_at: timestamptz
  generative_token: generative_token_obj_rel_insert_input
  id: String
  owner_id: String
  price: numeric
  taxation_locked: numeric
  taxation_paid_until: timestamptz
  taxation_start: timestamptz
  token_id: String
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type mint_ticket_max_fields {
  created_at: timestamptz
  id: String
  owner_id: String
  price: numeric
  taxation_locked: numeric
  taxation_paid_until: timestamptz
  taxation_start: timestamptz
  token_id: String
}

"""
order by max() on columns of table "mint_ticket"
"""
input mint_ticket_max_order_by {
  created_at: order_by
  id: order_by
  owner_id: order_by
  price: order_by
  taxation_locked: order_by
  taxation_paid_until: order_by
  taxation_start: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type mint_ticket_min_fields {
  created_at: timestamptz
  id: String
  owner_id: String
  price: numeric
  taxation_locked: numeric
  taxation_paid_until: timestamptz
  taxation_start: timestamptz
  token_id: String
}

"""
order by min() on columns of table "mint_ticket"
"""
input mint_ticket_min_order_by {
  created_at: order_by
  id: order_by
  owner_id: order_by
  price: order_by
  taxation_locked: order_by
  taxation_paid_until: order_by
  taxation_start: order_by
  token_id: order_by
}

"""
response of any mutation on the table "mint_ticket"
"""
type mint_ticket_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mint_ticket!]!
}

"""
on_conflict condition type for table "mint_ticket"
"""
input mint_ticket_on_conflict {
  constraint: mint_ticket_constraint!
  update_columns: [mint_ticket_update_column!]! = []
  where: mint_ticket_bool_exp
}

"""Ordering options when selecting data from "mint_ticket"."""
input mint_ticket_order_by {
  created_at: order_by
  generative_token: generative_token_order_by
  id: order_by
  owner_id: order_by
  price: order_by
  taxation_locked: order_by
  taxation_paid_until: order_by
  taxation_start: order_by
  token_id: order_by
  user: user_order_by
}

"""primary key columns input for table: mint_ticket"""
input mint_ticket_pk_columns_input {
  id: String!
}

"""
select columns of table "mint_ticket"
"""
enum mint_ticket_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  owner_id

  """column name"""
  price

  """column name"""
  taxation_locked

  """column name"""
  taxation_paid_until

  """column name"""
  taxation_start

  """column name"""
  token_id
}

"""
input type for updating data in table "mint_ticket"
"""
input mint_ticket_set_input {
  created_at: timestamptz
  id: String
  owner_id: String
  price: numeric
  taxation_locked: numeric
  taxation_paid_until: timestamptz
  taxation_start: timestamptz
  token_id: String
}

"""
columns and relationships of "mint_ticket_settings"
"""
type mint_ticket_settings {
  captureMediaId: bpchar

  """An object relationship"""
  generative_token: generative_token
  gracing_period: Int!
  id: String!

  """An object relationship"""
  media_image: media_image
  metadata(
    """JSON select path"""
    path: String
  ): json!
  metadata_uri: String
  token_id: String
}

"""
aggregated selection of "mint_ticket_settings"
"""
type mint_ticket_settings_aggregate {
  aggregate: mint_ticket_settings_aggregate_fields
  nodes: [mint_ticket_settings!]!
}

input mint_ticket_settings_aggregate_bool_exp {
  count: mint_ticket_settings_aggregate_bool_exp_count
}

input mint_ticket_settings_aggregate_bool_exp_count {
  arguments: [mint_ticket_settings_select_column!]
  distinct: Boolean
  filter: mint_ticket_settings_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "mint_ticket_settings"
"""
type mint_ticket_settings_aggregate_fields {
  avg: mint_ticket_settings_avg_fields
  count(columns: [mint_ticket_settings_select_column!], distinct: Boolean): Int!
  max: mint_ticket_settings_max_fields
  min: mint_ticket_settings_min_fields
  stddev: mint_ticket_settings_stddev_fields
  stddev_pop: mint_ticket_settings_stddev_pop_fields
  stddev_samp: mint_ticket_settings_stddev_samp_fields
  sum: mint_ticket_settings_sum_fields
  var_pop: mint_ticket_settings_var_pop_fields
  var_samp: mint_ticket_settings_var_samp_fields
  variance: mint_ticket_settings_variance_fields
}

"""
order by aggregate values of table "mint_ticket_settings"
"""
input mint_ticket_settings_aggregate_order_by {
  avg: mint_ticket_settings_avg_order_by
  count: order_by
  max: mint_ticket_settings_max_order_by
  min: mint_ticket_settings_min_order_by
  stddev: mint_ticket_settings_stddev_order_by
  stddev_pop: mint_ticket_settings_stddev_pop_order_by
  stddev_samp: mint_ticket_settings_stddev_samp_order_by
  sum: mint_ticket_settings_sum_order_by
  var_pop: mint_ticket_settings_var_pop_order_by
  var_samp: mint_ticket_settings_var_samp_order_by
  variance: mint_ticket_settings_variance_order_by
}

"""
input type for inserting array relation for remote table "mint_ticket_settings"
"""
input mint_ticket_settings_arr_rel_insert_input {
  data: [mint_ticket_settings_insert_input!]!

  """upsert condition"""
  on_conflict: mint_ticket_settings_on_conflict
}

"""aggregate avg on columns"""
type mint_ticket_settings_avg_fields {
  gracing_period: Float
}

"""
order by avg() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_avg_order_by {
  gracing_period: order_by
}

"""
Boolean expression to filter rows from the table "mint_ticket_settings". All fields are combined with a logical 'AND'.
"""
input mint_ticket_settings_bool_exp {
  _and: [mint_ticket_settings_bool_exp!]
  _not: mint_ticket_settings_bool_exp
  _or: [mint_ticket_settings_bool_exp!]
  captureMediaId: bpchar_comparison_exp
  generative_token: generative_token_bool_exp
  gracing_period: Int_comparison_exp
  id: String_comparison_exp
  media_image: media_image_bool_exp
  metadata: json_comparison_exp
  metadata_uri: String_comparison_exp
  token_id: String_comparison_exp
}

"""
unique or primary key constraints on table "mint_ticket_settings"
"""
enum mint_ticket_settings_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_3d9d47cf1717a7d63bdd4d0c6ab
}

"""
input type for incrementing numeric columns in table "mint_ticket_settings"
"""
input mint_ticket_settings_inc_input {
  gracing_period: Int
}

"""
input type for inserting data into table "mint_ticket_settings"
"""
input mint_ticket_settings_insert_input {
  captureMediaId: bpchar
  generative_token: generative_token_obj_rel_insert_input
  gracing_period: Int
  id: String
  media_image: media_image_obj_rel_insert_input
  metadata: json
  metadata_uri: String
  token_id: String
}

"""aggregate max on columns"""
type mint_ticket_settings_max_fields {
  captureMediaId: bpchar
  gracing_period: Int
  id: String
  metadata_uri: String
  token_id: String
}

"""
order by max() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_max_order_by {
  captureMediaId: order_by
  gracing_period: order_by
  id: order_by
  metadata_uri: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type mint_ticket_settings_min_fields {
  captureMediaId: bpchar
  gracing_period: Int
  id: String
  metadata_uri: String
  token_id: String
}

"""
order by min() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_min_order_by {
  captureMediaId: order_by
  gracing_period: order_by
  id: order_by
  metadata_uri: order_by
  token_id: order_by
}

"""
response of any mutation on the table "mint_ticket_settings"
"""
type mint_ticket_settings_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [mint_ticket_settings!]!
}

"""
on_conflict condition type for table "mint_ticket_settings"
"""
input mint_ticket_settings_on_conflict {
  constraint: mint_ticket_settings_constraint!
  update_columns: [mint_ticket_settings_update_column!]! = []
  where: mint_ticket_settings_bool_exp
}

"""Ordering options when selecting data from "mint_ticket_settings"."""
input mint_ticket_settings_order_by {
  captureMediaId: order_by
  generative_token: generative_token_order_by
  gracing_period: order_by
  id: order_by
  media_image: media_image_order_by
  metadata: order_by
  metadata_uri: order_by
  token_id: order_by
}

"""primary key columns input for table: mint_ticket_settings"""
input mint_ticket_settings_pk_columns_input {
  id: String!
}

"""
select columns of table "mint_ticket_settings"
"""
enum mint_ticket_settings_select_column {
  """column name"""
  captureMediaId

  """column name"""
  gracing_period

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  metadata_uri

  """column name"""
  token_id
}

"""
input type for updating data in table "mint_ticket_settings"
"""
input mint_ticket_settings_set_input {
  captureMediaId: bpchar
  gracing_period: Int
  id: String
  metadata: json
  metadata_uri: String
  token_id: String
}

"""aggregate stddev on columns"""
type mint_ticket_settings_stddev_fields {
  gracing_period: Float
}

"""
order by stddev() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_stddev_order_by {
  gracing_period: order_by
}

"""aggregate stddev_pop on columns"""
type mint_ticket_settings_stddev_pop_fields {
  gracing_period: Float
}

"""
order by stddev_pop() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_stddev_pop_order_by {
  gracing_period: order_by
}

"""aggregate stddev_samp on columns"""
type mint_ticket_settings_stddev_samp_fields {
  gracing_period: Float
}

"""
order by stddev_samp() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_stddev_samp_order_by {
  gracing_period: order_by
}

"""
Streaming cursor of the table "mint_ticket_settings"
"""
input mint_ticket_settings_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mint_ticket_settings_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mint_ticket_settings_stream_cursor_value_input {
  captureMediaId: bpchar
  gracing_period: Int
  id: String
  metadata: json
  metadata_uri: String
  token_id: String
}

"""aggregate sum on columns"""
type mint_ticket_settings_sum_fields {
  gracing_period: Int
}

"""
order by sum() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_sum_order_by {
  gracing_period: order_by
}

"""
update columns of table "mint_ticket_settings"
"""
enum mint_ticket_settings_update_column {
  """column name"""
  captureMediaId

  """column name"""
  gracing_period

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  metadata_uri

  """column name"""
  token_id
}

input mint_ticket_settings_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: mint_ticket_settings_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: mint_ticket_settings_set_input

  """filter the rows which have to be updated"""
  where: mint_ticket_settings_bool_exp!
}

"""aggregate var_pop on columns"""
type mint_ticket_settings_var_pop_fields {
  gracing_period: Float
}

"""
order by var_pop() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_var_pop_order_by {
  gracing_period: order_by
}

"""aggregate var_samp on columns"""
type mint_ticket_settings_var_samp_fields {
  gracing_period: Float
}

"""
order by var_samp() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_var_samp_order_by {
  gracing_period: order_by
}

"""aggregate variance on columns"""
type mint_ticket_settings_variance_fields {
  gracing_period: Float
}

"""
order by variance() on columns of table "mint_ticket_settings"
"""
input mint_ticket_settings_variance_order_by {
  gracing_period: order_by
}

"""aggregate stddev on columns"""
type mint_ticket_stddev_fields {
  price: Float
  taxation_locked: Float
}

"""
order by stddev() on columns of table "mint_ticket"
"""
input mint_ticket_stddev_order_by {
  price: order_by
  taxation_locked: order_by
}

"""aggregate stddev_pop on columns"""
type mint_ticket_stddev_pop_fields {
  price: Float
  taxation_locked: Float
}

"""
order by stddev_pop() on columns of table "mint_ticket"
"""
input mint_ticket_stddev_pop_order_by {
  price: order_by
  taxation_locked: order_by
}

"""aggregate stddev_samp on columns"""
type mint_ticket_stddev_samp_fields {
  price: Float
  taxation_locked: Float
}

"""
order by stddev_samp() on columns of table "mint_ticket"
"""
input mint_ticket_stddev_samp_order_by {
  price: order_by
  taxation_locked: order_by
}

"""
Streaming cursor of the table "mint_ticket"
"""
input mint_ticket_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: mint_ticket_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input mint_ticket_stream_cursor_value_input {
  created_at: timestamptz
  id: String
  owner_id: String
  price: numeric
  taxation_locked: numeric
  taxation_paid_until: timestamptz
  taxation_start: timestamptz
  token_id: String
}

"""aggregate sum on columns"""
type mint_ticket_sum_fields {
  price: numeric
  taxation_locked: numeric
}

"""
order by sum() on columns of table "mint_ticket"
"""
input mint_ticket_sum_order_by {
  price: order_by
  taxation_locked: order_by
}

"""
update columns of table "mint_ticket"
"""
enum mint_ticket_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  owner_id

  """column name"""
  price

  """column name"""
  taxation_locked

  """column name"""
  taxation_paid_until

  """column name"""
  taxation_start

  """column name"""
  token_id
}

input mint_ticket_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: mint_ticket_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: mint_ticket_set_input

  """filter the rows which have to be updated"""
  where: mint_ticket_bool_exp!
}

"""aggregate var_pop on columns"""
type mint_ticket_var_pop_fields {
  price: Float
  taxation_locked: Float
}

"""
order by var_pop() on columns of table "mint_ticket"
"""
input mint_ticket_var_pop_order_by {
  price: order_by
  taxation_locked: order_by
}

"""aggregate var_samp on columns"""
type mint_ticket_var_samp_fields {
  price: Float
  taxation_locked: Float
}

"""
order by var_samp() on columns of table "mint_ticket"
"""
input mint_ticket_var_samp_order_by {
  price: order_by
  taxation_locked: order_by
}

"""aggregate variance on columns"""
type mint_ticket_variance_fields {
  price: Float
  taxation_locked: Float
}

"""
order by variance() on columns of table "mint_ticket"
"""
input mint_ticket_variance_order_by {
  price: order_by
  taxation_locked: order_by
}

"""
columns and relationships of "moderation_reason"
"""
type moderation_reason {
  """An array relationship"""
  articles(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): [article!]!

  """An aggregate relationship"""
  articles_aggregate(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): article_aggregate!

  """An array relationship"""
  generative_tokens(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): [generative_token!]!

  """An aggregate relationship"""
  generative_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): generative_token_aggregate!
  id: String!
  reason: String!

  """An array relationship"""
  reports(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!

  """An aggregate relationship"""
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): report_aggregate!

  """An array relationship"""
  users(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """An aggregate relationship"""
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!
}

"""
aggregated selection of "moderation_reason"
"""
type moderation_reason_aggregate {
  aggregate: moderation_reason_aggregate_fields
  nodes: [moderation_reason!]!
}

"""
aggregate fields of "moderation_reason"
"""
type moderation_reason_aggregate_fields {
  count(columns: [moderation_reason_select_column!], distinct: Boolean): Int!
  max: moderation_reason_max_fields
  min: moderation_reason_min_fields
}

"""
Boolean expression to filter rows from the table "moderation_reason". All fields are combined with a logical 'AND'.
"""
input moderation_reason_bool_exp {
  _and: [moderation_reason_bool_exp!]
  _not: moderation_reason_bool_exp
  _or: [moderation_reason_bool_exp!]
  articles: article_bool_exp
  articles_aggregate: article_aggregate_bool_exp
  generative_tokens: generative_token_bool_exp
  generative_tokens_aggregate: generative_token_aggregate_bool_exp
  id: String_comparison_exp
  reason: String_comparison_exp
  reports: report_bool_exp
  reports_aggregate: report_aggregate_bool_exp
  users: user_bool_exp
  users_aggregate: user_aggregate_bool_exp
}

"""
unique or primary key constraints on table "moderation_reason"
"""
enum moderation_reason_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_fdcfcb2db6d8f8d793f0a26a87b
}

"""
input type for inserting data into table "moderation_reason"
"""
input moderation_reason_insert_input {
  articles: article_arr_rel_insert_input
  generative_tokens: generative_token_arr_rel_insert_input
  id: String
  reason: String
  reports: report_arr_rel_insert_input
  users: user_arr_rel_insert_input
}

"""aggregate max on columns"""
type moderation_reason_max_fields {
  id: String
  reason: String
}

"""aggregate min on columns"""
type moderation_reason_min_fields {
  id: String
  reason: String
}

"""
response of any mutation on the table "moderation_reason"
"""
type moderation_reason_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [moderation_reason!]!
}

"""
input type for inserting object relation for remote table "moderation_reason"
"""
input moderation_reason_obj_rel_insert_input {
  data: moderation_reason_insert_input!

  """upsert condition"""
  on_conflict: moderation_reason_on_conflict
}

"""
on_conflict condition type for table "moderation_reason"
"""
input moderation_reason_on_conflict {
  constraint: moderation_reason_constraint!
  update_columns: [moderation_reason_update_column!]! = []
  where: moderation_reason_bool_exp
}

"""Ordering options when selecting data from "moderation_reason"."""
input moderation_reason_order_by {
  articles_aggregate: article_aggregate_order_by
  generative_tokens_aggregate: generative_token_aggregate_order_by
  id: order_by
  reason: order_by
  reports_aggregate: report_aggregate_order_by
  users_aggregate: user_aggregate_order_by
}

"""primary key columns input for table: moderation_reason"""
input moderation_reason_pk_columns_input {
  id: String!
}

"""
select columns of table "moderation_reason"
"""
enum moderation_reason_select_column {
  """column name"""
  id

  """column name"""
  reason
}

"""
input type for updating data in table "moderation_reason"
"""
input moderation_reason_set_input {
  id: String
  reason: String
}

"""
Streaming cursor of the table "moderation_reason"
"""
input moderation_reason_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: moderation_reason_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input moderation_reason_stream_cursor_value_input {
  id: String
  reason: String
}

"""
update columns of table "moderation_reason"
"""
enum moderation_reason_update_column {
  """column name"""
  id

  """column name"""
  reason
}

input moderation_reason_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: moderation_reason_set_input

  """filter the rows which have to be updated"""
  where: moderation_reason_bool_exp!
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "Account"
  """
  delete_Account(
    """filter the rows which have to be deleted"""
    where: Account_bool_exp!
  ): Account_mutation_response

  """
  delete single row from the table: "Account"
  """
  delete_Account_by_pk(id: uuid!): Account

  """
  delete data from the table: "Profile"
  """
  delete_Profile(
    """filter the rows which have to be deleted"""
    where: Profile_bool_exp!
  ): Profile_mutation_response

  """
  delete single row from the table: "Profile"
  """
  delete_Profile_by_pk(accountId: uuid!): Profile

  """
  delete data from the table: "Wallet"
  """
  delete_Wallet(
    """filter the rows which have to be deleted"""
    where: Wallet_bool_exp!
  ): Wallet_mutation_response

  """
  delete single row from the table: "Wallet"
  """
  delete_Wallet_by_pk(address: String!): Wallet

  """
  delete data from the table: "Whitelist"
  """
  delete_Whitelist(
    """filter the rows which have to be deleted"""
    where: Whitelist_bool_exp!
  ): Whitelist_mutation_response

  """
  delete data from the table: "WhitelistEntries"
  """
  delete_WhitelistEntries(
    """filter the rows which have to be deleted"""
    where: WhitelistEntries_bool_exp!
  ): WhitelistEntries_mutation_response

  """
  delete single row from the table: "WhitelistEntries"
  """
  delete_WhitelistEntries_by_pk(merkleRoot: String!, whitelistIndex: Int!): WhitelistEntries

  """
  delete single row from the table: "Whitelist"
  """
  delete_Whitelist_by_pk(merkleRoot: String!): Whitelist

  """
  delete data from the table: "action"
  """
  delete_action(
    """filter the rows which have to be deleted"""
    where: action_bool_exp!
  ): action_mutation_response

  """
  delete single row from the table: "action"
  """
  delete_action_by_pk(id: uuid!): action

  """
  delete data from the table: "article"
  """
  delete_article(
    """filter the rows which have to be deleted"""
    where: article_bool_exp!
  ): article_mutation_response

  """
  delete single row from the table: "article"
  """
  delete_article_by_pk(id: Int!): article

  """
  delete data from the table: "article_generative_token"
  """
  delete_article_generative_token(
    """filter the rows which have to be deleted"""
    where: article_generative_token_bool_exp!
  ): article_generative_token_mutation_response

  """
  delete single row from the table: "article_generative_token"
  """
  delete_article_generative_token_by_pk(article_id: Int!, generative_token_id: String!): article_generative_token

  """
  delete data from the table: "article_ledger"
  """
  delete_article_ledger(
    """filter the rows which have to be deleted"""
    where: article_ledger_bool_exp!
  ): article_ledger_mutation_response

  """
  delete single row from the table: "article_ledger"
  """
  delete_article_ledger_by_pk(article_id: Int!, owner_id: String!): article_ledger

  """
  delete data from the table: "article_revision"
  """
  delete_article_revision(
    """filter the rows which have to be deleted"""
    where: article_revision_bool_exp!
  ): article_revision_mutation_response

  """
  delete single row from the table: "article_revision"
  """
  delete_article_revision_by_pk(article_id: Int!, iteration: smallint!): article_revision

  """
  delete data from the table: "auction"
  """
  delete_auction(
    """filter the rows which have to be deleted"""
    where: auction_bool_exp!
  ): auction_mutation_response

  """
  delete data from the table: "auction_bid"
  """
  delete_auction_bid(
    """filter the rows which have to be deleted"""
    where: auction_bid_bool_exp!
  ): auction_bid_mutation_response

  """
  delete single row from the table: "auction_bid"
  """
  delete_auction_bid_by_pk(id: uuid!): auction_bid

  """
  delete data from the table: "auction_bid_table"
  """
  delete_auction_bid_table(
    """filter the rows which have to be deleted"""
    where: auction_bid_table_bool_exp!
  ): auction_bid_table_mutation_response

  """
  delete single row from the table: "auction_bid_table"
  """
  delete_auction_bid_table_by_pk(id: Int!): auction_bid_table

  """
  delete single row from the table: "auction"
  """
  delete_auction_by_pk(id: Int!, version: Int!): auction

  """
  delete data from the table: "codex"
  """
  delete_codex(
    """filter the rows which have to be deleted"""
    where: codex_bool_exp!
  ): codex_mutation_response

  """
  delete single row from the table: "codex"
  """
  delete_codex_by_pk(id: String!, token_version: generative_token_version!): codex

  """
  delete data from the table: "codex_update_request"
  """
  delete_codex_update_request(
    """filter the rows which have to be deleted"""
    where: codex_update_request_bool_exp!
  ): codex_update_request_mutation_response

  """
  delete single row from the table: "codex_update_request"
  """
  delete_codex_update_request_by_pk(codex_id: String!, token_id: String!, token_version: generative_token_version!): codex_update_request

  """
  delete data from the table: "collaboration"
  """
  delete_collaboration(
    """filter the rows which have to be deleted"""
    where: collaboration_bool_exp!
  ): collaboration_mutation_response

  """
  delete single row from the table: "collaboration"
  """
  delete_collaboration_by_pk(collaboration_contract_id: String!, collaborator_id: String!): collaboration

  """
  delete data from the table: "collection_offer"
  """
  delete_collection_offer(
    """filter the rows which have to be deleted"""
    where: collection_offer_bool_exp!
  ): collection_offer_mutation_response

  """
  delete single row from the table: "collection_offer"
  """
  delete_collection_offer_by_pk(id: String!, version: Int!): collection_offer

  """
  delete data from the table: "generative_token"
  """
  delete_generative_token(
    """filter the rows which have to be deleted"""
    where: generative_token_bool_exp!
  ): generative_token_mutation_response

  """
  delete single row from the table: "generative_token"
  """
  delete_generative_token_by_pk(id: String!): generative_token

  """
  delete data from the table: "gentk_assign"
  """
  delete_gentk_assign(
    """filter the rows which have to be deleted"""
    where: gentk_assign_bool_exp!
  ): gentk_assign_mutation_response

  """
  delete single row from the table: "gentk_assign"
  """
  delete_gentk_assign_by_pk(gentk_id: String!, gentk_issuer_version: generative_token_version!): gentk_assign

  """
  delete data from the table: "ipfs_cid"
  """
  delete_ipfs_cid(
    """filter the rows which have to be deleted"""
    where: ipfs_cid_bool_exp!
  ): ipfs_cid_mutation_response

  """
  delete single row from the table: "ipfs_cid"
  """
  delete_ipfs_cid_by_pk(cid: String!): ipfs_cid

  """
  delete data from the table: "listing"
  """
  delete_listing(
    """filter the rows which have to be deleted"""
    where: listing_bool_exp!
  ): listing_mutation_response

  """
  delete single row from the table: "listing"
  """
  delete_listing_by_pk(id: String!, version: Int!): listing

  """
  delete data from the table: "market_stats"
  """
  delete_market_stats(
    """filter the rows which have to be deleted"""
    where: market_stats_bool_exp!
  ): market_stats_mutation_response

  """
  delete single row from the table: "market_stats"
  """
  delete_market_stats_by_pk(token_id: String!): market_stats

  """
  delete data from the table: "market_stats_history"
  """
  delete_market_stats_history(
    """filter the rows which have to be deleted"""
    where: market_stats_history_bool_exp!
  ): market_stats_history_mutation_response

  """
  delete single row from the table: "market_stats_history"
  """
  delete_market_stats_history_by_pk(id: Int!): market_stats_history

  """
  delete data from the table: "media_image"
  """
  delete_media_image(
    """filter the rows which have to be deleted"""
    where: media_image_bool_exp!
  ): media_image_mutation_response

  """
  delete single row from the table: "media_image"
  """
  delete_media_image_by_pk(cid: bpchar!): media_image

  """
  delete data from the table: "mint_ticket"
  """
  delete_mint_ticket(
    """filter the rows which have to be deleted"""
    where: mint_ticket_bool_exp!
  ): mint_ticket_mutation_response

  """
  delete single row from the table: "mint_ticket"
  """
  delete_mint_ticket_by_pk(id: String!): mint_ticket

  """
  delete data from the table: "mint_ticket_settings"
  """
  delete_mint_ticket_settings(
    """filter the rows which have to be deleted"""
    where: mint_ticket_settings_bool_exp!
  ): mint_ticket_settings_mutation_response

  """
  delete single row from the table: "mint_ticket_settings"
  """
  delete_mint_ticket_settings_by_pk(id: String!): mint_ticket_settings

  """
  delete data from the table: "moderation_reason"
  """
  delete_moderation_reason(
    """filter the rows which have to be deleted"""
    where: moderation_reason_bool_exp!
  ): moderation_reason_mutation_response

  """
  delete single row from the table: "moderation_reason"
  """
  delete_moderation_reason_by_pk(id: String!): moderation_reason

  """
  delete data from the table: "objkt"
  """
  delete_objkt(
    """filter the rows which have to be deleted"""
    where: objkt_bool_exp!
  ): objkt_mutation_response

  """
  delete single row from the table: "objkt"
  """
  delete_objkt_by_pk(id: String!, issuer_version: generative_token_version!): objkt

  """
  delete data from the table: "offer"
  """
  delete_offer(
    """filter the rows which have to be deleted"""
    where: offer_bool_exp!
  ): offer_mutation_response

  """
  delete single row from the table: "offer"
  """
  delete_offer_by_pk(id: String!, version: Int!): offer

  """
  delete data from the table: "pricing_dutch_auction"
  """
  delete_pricing_dutch_auction(
    """filter the rows which have to be deleted"""
    where: pricing_dutch_auction_bool_exp!
  ): pricing_dutch_auction_mutation_response

  """
  delete single row from the table: "pricing_dutch_auction"
  """
  delete_pricing_dutch_auction_by_pk(id: String!): pricing_dutch_auction

  """
  delete data from the table: "pricing_fixed"
  """
  delete_pricing_fixed(
    """filter the rows which have to be deleted"""
    where: pricing_fixed_bool_exp!
  ): pricing_fixed_mutation_response

  """
  delete single row from the table: "pricing_fixed"
  """
  delete_pricing_fixed_by_pk(id: String!): pricing_fixed

  """
  delete data from the table: "redeemable"
  """
  delete_redeemable(
    """filter the rows which have to be deleted"""
    where: redeemable_bool_exp!
  ): redeemable_mutation_response

  """
  delete single row from the table: "redeemable"
  """
  delete_redeemable_by_pk(address: String!): redeemable

  """
  delete data from the table: "redemption"
  """
  delete_redemption(
    """filter the rows which have to be deleted"""
    where: redemption_bool_exp!
  ): redemption_mutation_response

  """
  delete single row from the table: "redemption"
  """
  delete_redemption_by_pk(id: Int!): redemption

  """
  delete data from the table: "report"
  """
  delete_report(
    """filter the rows which have to be deleted"""
    where: report_bool_exp!
  ): report_mutation_response

  """
  delete single row from the table: "report"
  """
  delete_report_by_pk(id: uuid!): report

  """
  delete data from the table: "reserve"
  """
  delete_reserve(
    """filter the rows which have to be deleted"""
    where: reserve_bool_exp!
  ): reserve_mutation_response

  """
  delete single row from the table: "reserve"
  """
  delete_reserve_by_pk(id: Int!): reserve

  """
  delete data from the table: "split"
  """
  delete_split(
    """filter the rows which have to be deleted"""
    where: split_bool_exp!
  ): split_mutation_response

  """
  delete single row from the table: "split"
  """
  delete_split_by_pk(id: Int!): split

  """
  delete data from the table: "transaction"
  """
  delete_transaction(
    """filter the rows which have to be deleted"""
    where: transaction_bool_exp!
  ): transaction_mutation_response

  """
  delete single row from the table: "transaction"
  """
  delete_transaction_by_pk(id: Int!): transaction

  """
  delete data from the table: "user"
  """
  delete_user(
    """filter the rows which have to be deleted"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  delete single row from the table: "user"
  """
  delete_user_by_pk(id: String!): user

  """
  delete data from the table: "user_stats"
  """
  delete_user_stats(
    """filter the rows which have to be deleted"""
    where: user_stats_bool_exp!
  ): user_stats_mutation_response

  """
  delete single row from the table: "user_stats"
  """
  delete_user_stats_by_pk(user_id: String!): user_stats

  """
  insert data into the table: "Account"
  """
  insert_Account(
    """the rows to be inserted"""
    objects: [Account_insert_input!]!

    """upsert condition"""
    on_conflict: Account_on_conflict
  ): Account_mutation_response

  """
  insert a single row into the table: "Account"
  """
  insert_Account_one(
    """the row to be inserted"""
    object: Account_insert_input!

    """upsert condition"""
    on_conflict: Account_on_conflict
  ): Account

  """
  insert data into the table: "Profile"
  """
  insert_Profile(
    """the rows to be inserted"""
    objects: [Profile_insert_input!]!

    """upsert condition"""
    on_conflict: Profile_on_conflict
  ): Profile_mutation_response

  """
  insert a single row into the table: "Profile"
  """
  insert_Profile_one(
    """the row to be inserted"""
    object: Profile_insert_input!

    """upsert condition"""
    on_conflict: Profile_on_conflict
  ): Profile

  """
  insert data into the table: "Wallet"
  """
  insert_Wallet(
    """the rows to be inserted"""
    objects: [Wallet_insert_input!]!

    """upsert condition"""
    on_conflict: Wallet_on_conflict
  ): Wallet_mutation_response

  """
  insert a single row into the table: "Wallet"
  """
  insert_Wallet_one(
    """the row to be inserted"""
    object: Wallet_insert_input!

    """upsert condition"""
    on_conflict: Wallet_on_conflict
  ): Wallet

  """
  insert data into the table: "Whitelist"
  """
  insert_Whitelist(
    """the rows to be inserted"""
    objects: [Whitelist_insert_input!]!

    """upsert condition"""
    on_conflict: Whitelist_on_conflict
  ): Whitelist_mutation_response

  """
  insert data into the table: "WhitelistEntries"
  """
  insert_WhitelistEntries(
    """the rows to be inserted"""
    objects: [WhitelistEntries_insert_input!]!

    """upsert condition"""
    on_conflict: WhitelistEntries_on_conflict
  ): WhitelistEntries_mutation_response

  """
  insert a single row into the table: "WhitelistEntries"
  """
  insert_WhitelistEntries_one(
    """the row to be inserted"""
    object: WhitelistEntries_insert_input!

    """upsert condition"""
    on_conflict: WhitelistEntries_on_conflict
  ): WhitelistEntries

  """
  insert a single row into the table: "Whitelist"
  """
  insert_Whitelist_one(
    """the row to be inserted"""
    object: Whitelist_insert_input!

    """upsert condition"""
    on_conflict: Whitelist_on_conflict
  ): Whitelist

  """
  insert data into the table: "action"
  """
  insert_action(
    """the rows to be inserted"""
    objects: [action_insert_input!]!

    """upsert condition"""
    on_conflict: action_on_conflict
  ): action_mutation_response

  """
  insert a single row into the table: "action"
  """
  insert_action_one(
    """the row to be inserted"""
    object: action_insert_input!

    """upsert condition"""
    on_conflict: action_on_conflict
  ): action

  """
  insert data into the table: "article"
  """
  insert_article(
    """the rows to be inserted"""
    objects: [article_insert_input!]!

    """upsert condition"""
    on_conflict: article_on_conflict
  ): article_mutation_response

  """
  insert data into the table: "article_generative_token"
  """
  insert_article_generative_token(
    """the rows to be inserted"""
    objects: [article_generative_token_insert_input!]!

    """upsert condition"""
    on_conflict: article_generative_token_on_conflict
  ): article_generative_token_mutation_response

  """
  insert a single row into the table: "article_generative_token"
  """
  insert_article_generative_token_one(
    """the row to be inserted"""
    object: article_generative_token_insert_input!

    """upsert condition"""
    on_conflict: article_generative_token_on_conflict
  ): article_generative_token

  """
  insert data into the table: "article_ledger"
  """
  insert_article_ledger(
    """the rows to be inserted"""
    objects: [article_ledger_insert_input!]!

    """upsert condition"""
    on_conflict: article_ledger_on_conflict
  ): article_ledger_mutation_response

  """
  insert a single row into the table: "article_ledger"
  """
  insert_article_ledger_one(
    """the row to be inserted"""
    object: article_ledger_insert_input!

    """upsert condition"""
    on_conflict: article_ledger_on_conflict
  ): article_ledger

  """
  insert a single row into the table: "article"
  """
  insert_article_one(
    """the row to be inserted"""
    object: article_insert_input!

    """upsert condition"""
    on_conflict: article_on_conflict
  ): article

  """
  insert data into the table: "article_revision"
  """
  insert_article_revision(
    """the rows to be inserted"""
    objects: [article_revision_insert_input!]!

    """upsert condition"""
    on_conflict: article_revision_on_conflict
  ): article_revision_mutation_response

  """
  insert a single row into the table: "article_revision"
  """
  insert_article_revision_one(
    """the row to be inserted"""
    object: article_revision_insert_input!

    """upsert condition"""
    on_conflict: article_revision_on_conflict
  ): article_revision

  """
  insert data into the table: "auction"
  """
  insert_auction(
    """the rows to be inserted"""
    objects: [auction_insert_input!]!

    """upsert condition"""
    on_conflict: auction_on_conflict
  ): auction_mutation_response

  """
  insert data into the table: "auction_bid"
  """
  insert_auction_bid(
    """the rows to be inserted"""
    objects: [auction_bid_insert_input!]!

    """upsert condition"""
    on_conflict: auction_bid_on_conflict
  ): auction_bid_mutation_response

  """
  insert a single row into the table: "auction_bid"
  """
  insert_auction_bid_one(
    """the row to be inserted"""
    object: auction_bid_insert_input!

    """upsert condition"""
    on_conflict: auction_bid_on_conflict
  ): auction_bid

  """
  insert data into the table: "auction_bid_table"
  """
  insert_auction_bid_table(
    """the rows to be inserted"""
    objects: [auction_bid_table_insert_input!]!

    """upsert condition"""
    on_conflict: auction_bid_table_on_conflict
  ): auction_bid_table_mutation_response

  """
  insert a single row into the table: "auction_bid_table"
  """
  insert_auction_bid_table_one(
    """the row to be inserted"""
    object: auction_bid_table_insert_input!

    """upsert condition"""
    on_conflict: auction_bid_table_on_conflict
  ): auction_bid_table

  """
  insert a single row into the table: "auction"
  """
  insert_auction_one(
    """the row to be inserted"""
    object: auction_insert_input!

    """upsert condition"""
    on_conflict: auction_on_conflict
  ): auction

  """
  insert data into the table: "codex"
  """
  insert_codex(
    """the rows to be inserted"""
    objects: [codex_insert_input!]!

    """upsert condition"""
    on_conflict: codex_on_conflict
  ): codex_mutation_response

  """
  insert a single row into the table: "codex"
  """
  insert_codex_one(
    """the row to be inserted"""
    object: codex_insert_input!

    """upsert condition"""
    on_conflict: codex_on_conflict
  ): codex

  """
  insert data into the table: "codex_update_request"
  """
  insert_codex_update_request(
    """the rows to be inserted"""
    objects: [codex_update_request_insert_input!]!

    """upsert condition"""
    on_conflict: codex_update_request_on_conflict
  ): codex_update_request_mutation_response

  """
  insert a single row into the table: "codex_update_request"
  """
  insert_codex_update_request_one(
    """the row to be inserted"""
    object: codex_update_request_insert_input!

    """upsert condition"""
    on_conflict: codex_update_request_on_conflict
  ): codex_update_request

  """
  insert data into the table: "collaboration"
  """
  insert_collaboration(
    """the rows to be inserted"""
    objects: [collaboration_insert_input!]!

    """upsert condition"""
    on_conflict: collaboration_on_conflict
  ): collaboration_mutation_response

  """
  insert a single row into the table: "collaboration"
  """
  insert_collaboration_one(
    """the row to be inserted"""
    object: collaboration_insert_input!

    """upsert condition"""
    on_conflict: collaboration_on_conflict
  ): collaboration

  """
  insert data into the table: "collection_offer"
  """
  insert_collection_offer(
    """the rows to be inserted"""
    objects: [collection_offer_insert_input!]!

    """upsert condition"""
    on_conflict: collection_offer_on_conflict
  ): collection_offer_mutation_response

  """
  insert a single row into the table: "collection_offer"
  """
  insert_collection_offer_one(
    """the row to be inserted"""
    object: collection_offer_insert_input!

    """upsert condition"""
    on_conflict: collection_offer_on_conflict
  ): collection_offer

  """
  insert data into the table: "generative_token"
  """
  insert_generative_token(
    """the rows to be inserted"""
    objects: [generative_token_insert_input!]!

    """upsert condition"""
    on_conflict: generative_token_on_conflict
  ): generative_token_mutation_response

  """
  insert a single row into the table: "generative_token"
  """
  insert_generative_token_one(
    """the row to be inserted"""
    object: generative_token_insert_input!

    """upsert condition"""
    on_conflict: generative_token_on_conflict
  ): generative_token

  """
  insert data into the table: "gentk_assign"
  """
  insert_gentk_assign(
    """the rows to be inserted"""
    objects: [gentk_assign_insert_input!]!

    """upsert condition"""
    on_conflict: gentk_assign_on_conflict
  ): gentk_assign_mutation_response

  """
  insert a single row into the table: "gentk_assign"
  """
  insert_gentk_assign_one(
    """the row to be inserted"""
    object: gentk_assign_insert_input!

    """upsert condition"""
    on_conflict: gentk_assign_on_conflict
  ): gentk_assign

  """
  insert data into the table: "ipfs_cid"
  """
  insert_ipfs_cid(
    """the rows to be inserted"""
    objects: [ipfs_cid_insert_input!]!

    """upsert condition"""
    on_conflict: ipfs_cid_on_conflict
  ): ipfs_cid_mutation_response

  """
  insert a single row into the table: "ipfs_cid"
  """
  insert_ipfs_cid_one(
    """the row to be inserted"""
    object: ipfs_cid_insert_input!

    """upsert condition"""
    on_conflict: ipfs_cid_on_conflict
  ): ipfs_cid

  """
  insert data into the table: "listing"
  """
  insert_listing(
    """the rows to be inserted"""
    objects: [listing_insert_input!]!

    """upsert condition"""
    on_conflict: listing_on_conflict
  ): listing_mutation_response

  """
  insert a single row into the table: "listing"
  """
  insert_listing_one(
    """the row to be inserted"""
    object: listing_insert_input!

    """upsert condition"""
    on_conflict: listing_on_conflict
  ): listing

  """
  insert data into the table: "market_stats"
  """
  insert_market_stats(
    """the rows to be inserted"""
    objects: [market_stats_insert_input!]!

    """upsert condition"""
    on_conflict: market_stats_on_conflict
  ): market_stats_mutation_response

  """
  insert data into the table: "market_stats_history"
  """
  insert_market_stats_history(
    """the rows to be inserted"""
    objects: [market_stats_history_insert_input!]!

    """upsert condition"""
    on_conflict: market_stats_history_on_conflict
  ): market_stats_history_mutation_response

  """
  insert a single row into the table: "market_stats_history"
  """
  insert_market_stats_history_one(
    """the row to be inserted"""
    object: market_stats_history_insert_input!

    """upsert condition"""
    on_conflict: market_stats_history_on_conflict
  ): market_stats_history

  """
  insert a single row into the table: "market_stats"
  """
  insert_market_stats_one(
    """the row to be inserted"""
    object: market_stats_insert_input!

    """upsert condition"""
    on_conflict: market_stats_on_conflict
  ): market_stats

  """
  insert data into the table: "media_image"
  """
  insert_media_image(
    """the rows to be inserted"""
    objects: [media_image_insert_input!]!

    """upsert condition"""
    on_conflict: media_image_on_conflict
  ): media_image_mutation_response

  """
  insert a single row into the table: "media_image"
  """
  insert_media_image_one(
    """the row to be inserted"""
    object: media_image_insert_input!

    """upsert condition"""
    on_conflict: media_image_on_conflict
  ): media_image

  """
  insert data into the table: "mint_ticket"
  """
  insert_mint_ticket(
    """the rows to be inserted"""
    objects: [mint_ticket_insert_input!]!

    """upsert condition"""
    on_conflict: mint_ticket_on_conflict
  ): mint_ticket_mutation_response

  """
  insert a single row into the table: "mint_ticket"
  """
  insert_mint_ticket_one(
    """the row to be inserted"""
    object: mint_ticket_insert_input!

    """upsert condition"""
    on_conflict: mint_ticket_on_conflict
  ): mint_ticket

  """
  insert data into the table: "mint_ticket_settings"
  """
  insert_mint_ticket_settings(
    """the rows to be inserted"""
    objects: [mint_ticket_settings_insert_input!]!

    """upsert condition"""
    on_conflict: mint_ticket_settings_on_conflict
  ): mint_ticket_settings_mutation_response

  """
  insert a single row into the table: "mint_ticket_settings"
  """
  insert_mint_ticket_settings_one(
    """the row to be inserted"""
    object: mint_ticket_settings_insert_input!

    """upsert condition"""
    on_conflict: mint_ticket_settings_on_conflict
  ): mint_ticket_settings

  """
  insert data into the table: "moderation_reason"
  """
  insert_moderation_reason(
    """the rows to be inserted"""
    objects: [moderation_reason_insert_input!]!

    """upsert condition"""
    on_conflict: moderation_reason_on_conflict
  ): moderation_reason_mutation_response

  """
  insert a single row into the table: "moderation_reason"
  """
  insert_moderation_reason_one(
    """the row to be inserted"""
    object: moderation_reason_insert_input!

    """upsert condition"""
    on_conflict: moderation_reason_on_conflict
  ): moderation_reason

  """
  insert data into the table: "objkt"
  """
  insert_objkt(
    """the rows to be inserted"""
    objects: [objkt_insert_input!]!

    """upsert condition"""
    on_conflict: objkt_on_conflict
  ): objkt_mutation_response

  """
  insert a single row into the table: "objkt"
  """
  insert_objkt_one(
    """the row to be inserted"""
    object: objkt_insert_input!

    """upsert condition"""
    on_conflict: objkt_on_conflict
  ): objkt

  """
  insert data into the table: "offer"
  """
  insert_offer(
    """the rows to be inserted"""
    objects: [offer_insert_input!]!

    """upsert condition"""
    on_conflict: offer_on_conflict
  ): offer_mutation_response

  """
  insert a single row into the table: "offer"
  """
  insert_offer_one(
    """the row to be inserted"""
    object: offer_insert_input!

    """upsert condition"""
    on_conflict: offer_on_conflict
  ): offer

  """
  insert data into the table: "pricing_dutch_auction"
  """
  insert_pricing_dutch_auction(
    """the rows to be inserted"""
    objects: [pricing_dutch_auction_insert_input!]!

    """upsert condition"""
    on_conflict: pricing_dutch_auction_on_conflict
  ): pricing_dutch_auction_mutation_response

  """
  insert a single row into the table: "pricing_dutch_auction"
  """
  insert_pricing_dutch_auction_one(
    """the row to be inserted"""
    object: pricing_dutch_auction_insert_input!

    """upsert condition"""
    on_conflict: pricing_dutch_auction_on_conflict
  ): pricing_dutch_auction

  """
  insert data into the table: "pricing_fixed"
  """
  insert_pricing_fixed(
    """the rows to be inserted"""
    objects: [pricing_fixed_insert_input!]!

    """upsert condition"""
    on_conflict: pricing_fixed_on_conflict
  ): pricing_fixed_mutation_response

  """
  insert a single row into the table: "pricing_fixed"
  """
  insert_pricing_fixed_one(
    """the row to be inserted"""
    object: pricing_fixed_insert_input!

    """upsert condition"""
    on_conflict: pricing_fixed_on_conflict
  ): pricing_fixed

  """
  insert data into the table: "redeemable"
  """
  insert_redeemable(
    """the rows to be inserted"""
    objects: [redeemable_insert_input!]!

    """upsert condition"""
    on_conflict: redeemable_on_conflict
  ): redeemable_mutation_response

  """
  insert a single row into the table: "redeemable"
  """
  insert_redeemable_one(
    """the row to be inserted"""
    object: redeemable_insert_input!

    """upsert condition"""
    on_conflict: redeemable_on_conflict
  ): redeemable

  """
  insert data into the table: "redemption"
  """
  insert_redemption(
    """the rows to be inserted"""
    objects: [redemption_insert_input!]!

    """upsert condition"""
    on_conflict: redemption_on_conflict
  ): redemption_mutation_response

  """
  insert a single row into the table: "redemption"
  """
  insert_redemption_one(
    """the row to be inserted"""
    object: redemption_insert_input!

    """upsert condition"""
    on_conflict: redemption_on_conflict
  ): redemption

  """
  insert data into the table: "report"
  """
  insert_report(
    """the rows to be inserted"""
    objects: [report_insert_input!]!

    """upsert condition"""
    on_conflict: report_on_conflict
  ): report_mutation_response

  """
  insert a single row into the table: "report"
  """
  insert_report_one(
    """the row to be inserted"""
    object: report_insert_input!

    """upsert condition"""
    on_conflict: report_on_conflict
  ): report

  """
  insert data into the table: "reserve"
  """
  insert_reserve(
    """the rows to be inserted"""
    objects: [reserve_insert_input!]!

    """upsert condition"""
    on_conflict: reserve_on_conflict
  ): reserve_mutation_response

  """
  insert a single row into the table: "reserve"
  """
  insert_reserve_one(
    """the row to be inserted"""
    object: reserve_insert_input!

    """upsert condition"""
    on_conflict: reserve_on_conflict
  ): reserve

  """
  insert data into the table: "split"
  """
  insert_split(
    """the rows to be inserted"""
    objects: [split_insert_input!]!

    """upsert condition"""
    on_conflict: split_on_conflict
  ): split_mutation_response

  """
  insert a single row into the table: "split"
  """
  insert_split_one(
    """the row to be inserted"""
    object: split_insert_input!

    """upsert condition"""
    on_conflict: split_on_conflict
  ): split

  """
  insert data into the table: "transaction"
  """
  insert_transaction(
    """the rows to be inserted"""
    objects: [transaction_insert_input!]!

    """upsert condition"""
    on_conflict: transaction_on_conflict
  ): transaction_mutation_response

  """
  insert a single row into the table: "transaction"
  """
  insert_transaction_one(
    """the row to be inserted"""
    object: transaction_insert_input!

    """upsert condition"""
    on_conflict: transaction_on_conflict
  ): transaction

  """
  insert data into the table: "user"
  """
  insert_user(
    """the rows to be inserted"""
    objects: [user_insert_input!]!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user_mutation_response

  """
  insert a single row into the table: "user"
  """
  insert_user_one(
    """the row to be inserted"""
    object: user_insert_input!

    """upsert condition"""
    on_conflict: user_on_conflict
  ): user

  """
  insert data into the table: "user_stats"
  """
  insert_user_stats(
    """the rows to be inserted"""
    objects: [user_stats_insert_input!]!

    """upsert condition"""
    on_conflict: user_stats_on_conflict
  ): user_stats_mutation_response

  """
  insert a single row into the table: "user_stats"
  """
  insert_user_stats_one(
    """the row to be inserted"""
    object: user_stats_insert_input!

    """upsert condition"""
    on_conflict: user_stats_on_conflict
  ): user_stats
  set_whitelist(whitelist: jsonb!): SetWhitelistOutput

  """
  update data of the table: "Account"
  """
  update_Account(
    """sets the columns of the filtered rows to the given values"""
    _set: Account_set_input

    """filter the rows which have to be updated"""
    where: Account_bool_exp!
  ): Account_mutation_response

  """
  update single row of the table: "Account"
  """
  update_Account_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Account_set_input
    pk_columns: Account_pk_columns_input!
  ): Account

  """
  update multiples rows of table: "Account"
  """
  update_Account_many(
    """updates to execute, in order"""
    updates: [Account_updates!]!
  ): [Account_mutation_response]

  """
  update data of the table: "Profile"
  """
  update_Profile(
    """sets the columns of the filtered rows to the given values"""
    _set: Profile_set_input

    """filter the rows which have to be updated"""
    where: Profile_bool_exp!
  ): Profile_mutation_response

  """
  update single row of the table: "Profile"
  """
  update_Profile_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Profile_set_input
    pk_columns: Profile_pk_columns_input!
  ): Profile

  """
  update multiples rows of table: "Profile"
  """
  update_Profile_many(
    """updates to execute, in order"""
    updates: [Profile_updates!]!
  ): [Profile_mutation_response]

  """
  update data of the table: "Wallet"
  """
  update_Wallet(
    """sets the columns of the filtered rows to the given values"""
    _set: Wallet_set_input

    """filter the rows which have to be updated"""
    where: Wallet_bool_exp!
  ): Wallet_mutation_response

  """
  update single row of the table: "Wallet"
  """
  update_Wallet_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Wallet_set_input
    pk_columns: Wallet_pk_columns_input!
  ): Wallet

  """
  update multiples rows of table: "Wallet"
  """
  update_Wallet_many(
    """updates to execute, in order"""
    updates: [Wallet_updates!]!
  ): [Wallet_mutation_response]

  """
  update data of the table: "Whitelist"
  """
  update_Whitelist(
    """sets the columns of the filtered rows to the given values"""
    _set: Whitelist_set_input

    """filter the rows which have to be updated"""
    where: Whitelist_bool_exp!
  ): Whitelist_mutation_response

  """
  update data of the table: "WhitelistEntries"
  """
  update_WhitelistEntries(
    """increments the numeric columns with given value of the filtered values"""
    _inc: WhitelistEntries_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: WhitelistEntries_set_input

    """filter the rows which have to be updated"""
    where: WhitelistEntries_bool_exp!
  ): WhitelistEntries_mutation_response

  """
  update single row of the table: "WhitelistEntries"
  """
  update_WhitelistEntries_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: WhitelistEntries_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: WhitelistEntries_set_input
    pk_columns: WhitelistEntries_pk_columns_input!
  ): WhitelistEntries

  """
  update multiples rows of table: "WhitelistEntries"
  """
  update_WhitelistEntries_many(
    """updates to execute, in order"""
    updates: [WhitelistEntries_updates!]!
  ): [WhitelistEntries_mutation_response]

  """
  update single row of the table: "Whitelist"
  """
  update_Whitelist_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: Whitelist_set_input
    pk_columns: Whitelist_pk_columns_input!
  ): Whitelist

  """
  update multiples rows of table: "Whitelist"
  """
  update_Whitelist_many(
    """updates to execute, in order"""
    updates: [Whitelist_updates!]!
  ): [Whitelist_mutation_response]

  """
  update data of the table: "action"
  """
  update_action(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: action_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: action_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: action_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: action_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: action_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: action_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: action_set_input

    """filter the rows which have to be updated"""
    where: action_bool_exp!
  ): action_mutation_response

  """
  update single row of the table: "action"
  """
  update_action_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: action_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: action_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: action_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: action_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: action_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: action_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: action_set_input
    pk_columns: action_pk_columns_input!
  ): action

  """
  update multiples rows of table: "action"
  """
  update_action_many(
    """updates to execute, in order"""
    updates: [action_updates!]!
  ): [action_mutation_response]

  """
  update data of the table: "article"
  """
  update_article(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_set_input

    """filter the rows which have to be updated"""
    where: article_bool_exp!
  ): article_mutation_response

  """
  update single row of the table: "article"
  """
  update_article_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_set_input
    pk_columns: article_pk_columns_input!
  ): article

  """
  update data of the table: "article_generative_token"
  """
  update_article_generative_token(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_generative_token_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_generative_token_set_input

    """filter the rows which have to be updated"""
    where: article_generative_token_bool_exp!
  ): article_generative_token_mutation_response

  """
  update single row of the table: "article_generative_token"
  """
  update_article_generative_token_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_generative_token_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_generative_token_set_input
    pk_columns: article_generative_token_pk_columns_input!
  ): article_generative_token

  """
  update multiples rows of table: "article_generative_token"
  """
  update_article_generative_token_many(
    """updates to execute, in order"""
    updates: [article_generative_token_updates!]!
  ): [article_generative_token_mutation_response]

  """
  update data of the table: "article_ledger"
  """
  update_article_ledger(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_ledger_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_ledger_set_input

    """filter the rows which have to be updated"""
    where: article_ledger_bool_exp!
  ): article_ledger_mutation_response

  """
  update single row of the table: "article_ledger"
  """
  update_article_ledger_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_ledger_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_ledger_set_input
    pk_columns: article_ledger_pk_columns_input!
  ): article_ledger

  """
  update multiples rows of table: "article_ledger"
  """
  update_article_ledger_many(
    """updates to execute, in order"""
    updates: [article_ledger_updates!]!
  ): [article_ledger_mutation_response]

  """
  update multiples rows of table: "article"
  """
  update_article_many(
    """updates to execute, in order"""
    updates: [article_updates!]!
  ): [article_mutation_response]

  """
  update data of the table: "article_revision"
  """
  update_article_revision(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_revision_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_revision_set_input

    """filter the rows which have to be updated"""
    where: article_revision_bool_exp!
  ): article_revision_mutation_response

  """
  update single row of the table: "article_revision"
  """
  update_article_revision_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: article_revision_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: article_revision_set_input
    pk_columns: article_revision_pk_columns_input!
  ): article_revision

  """
  update multiples rows of table: "article_revision"
  """
  update_article_revision_many(
    """updates to execute, in order"""
    updates: [article_revision_updates!]!
  ): [article_revision_mutation_response]

  """
  update data of the table: "auction"
  """
  update_auction(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auction_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auction_set_input

    """filter the rows which have to be updated"""
    where: auction_bool_exp!
  ): auction_mutation_response

  """
  update data of the table: "auction_bid"
  """
  update_auction_bid(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auction_bid_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auction_bid_set_input

    """filter the rows which have to be updated"""
    where: auction_bid_bool_exp!
  ): auction_bid_mutation_response

  """
  update single row of the table: "auction_bid"
  """
  update_auction_bid_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auction_bid_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auction_bid_set_input
    pk_columns: auction_bid_pk_columns_input!
  ): auction_bid

  """
  update multiples rows of table: "auction_bid"
  """
  update_auction_bid_many(
    """updates to execute, in order"""
    updates: [auction_bid_updates!]!
  ): [auction_bid_mutation_response]

  """
  update data of the table: "auction_bid_table"
  """
  update_auction_bid_table(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auction_bid_table_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auction_bid_table_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auction_bid_table_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auction_bid_table_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: auction_bid_table_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auction_bid_table_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auction_bid_table_set_input

    """filter the rows which have to be updated"""
    where: auction_bid_table_bool_exp!
  ): auction_bid_table_mutation_response

  """
  update single row of the table: "auction_bid_table"
  """
  update_auction_bid_table_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auction_bid_table_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auction_bid_table_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auction_bid_table_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auction_bid_table_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: auction_bid_table_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auction_bid_table_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auction_bid_table_set_input
    pk_columns: auction_bid_table_pk_columns_input!
  ): auction_bid_table

  """
  update multiples rows of table: "auction_bid_table"
  """
  update_auction_bid_table_many(
    """updates to execute, in order"""
    updates: [auction_bid_table_updates!]!
  ): [auction_bid_table_mutation_response]

  """
  update single row of the table: "auction"
  """
  update_auction_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: auction_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: auction_set_input
    pk_columns: auction_pk_columns_input!
  ): auction

  """
  update multiples rows of table: "auction"
  """
  update_auction_many(
    """updates to execute, in order"""
    updates: [auction_updates!]!
  ): [auction_mutation_response]

  """
  update data of the table: "codex"
  """
  update_codex(
    """sets the columns of the filtered rows to the given values"""
    _set: codex_set_input

    """filter the rows which have to be updated"""
    where: codex_bool_exp!
  ): codex_mutation_response

  """
  update single row of the table: "codex"
  """
  update_codex_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: codex_set_input
    pk_columns: codex_pk_columns_input!
  ): codex

  """
  update multiples rows of table: "codex"
  """
  update_codex_many(
    """updates to execute, in order"""
    updates: [codex_updates!]!
  ): [codex_mutation_response]

  """
  update data of the table: "codex_update_request"
  """
  update_codex_update_request(
    """sets the columns of the filtered rows to the given values"""
    _set: codex_update_request_set_input

    """filter the rows which have to be updated"""
    where: codex_update_request_bool_exp!
  ): codex_update_request_mutation_response

  """
  update single row of the table: "codex_update_request"
  """
  update_codex_update_request_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: codex_update_request_set_input
    pk_columns: codex_update_request_pk_columns_input!
  ): codex_update_request

  """
  update multiples rows of table: "codex_update_request"
  """
  update_codex_update_request_many(
    """updates to execute, in order"""
    updates: [codex_update_request_updates!]!
  ): [codex_update_request_mutation_response]

  """
  update data of the table: "collaboration"
  """
  update_collaboration(
    """sets the columns of the filtered rows to the given values"""
    _set: collaboration_set_input

    """filter the rows which have to be updated"""
    where: collaboration_bool_exp!
  ): collaboration_mutation_response

  """
  update single row of the table: "collaboration"
  """
  update_collaboration_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: collaboration_set_input
    pk_columns: collaboration_pk_columns_input!
  ): collaboration

  """
  update multiples rows of table: "collaboration"
  """
  update_collaboration_many(
    """updates to execute, in order"""
    updates: [collaboration_updates!]!
  ): [collaboration_mutation_response]

  """
  update data of the table: "collection_offer"
  """
  update_collection_offer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: collection_offer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: collection_offer_set_input

    """filter the rows which have to be updated"""
    where: collection_offer_bool_exp!
  ): collection_offer_mutation_response

  """
  update single row of the table: "collection_offer"
  """
  update_collection_offer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: collection_offer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: collection_offer_set_input
    pk_columns: collection_offer_pk_columns_input!
  ): collection_offer

  """
  update multiples rows of table: "collection_offer"
  """
  update_collection_offer_many(
    """updates to execute, in order"""
    updates: [collection_offer_updates!]!
  ): [collection_offer_mutation_response]

  """
  update data of the table: "generative_token"
  """
  update_generative_token(
    """increments the numeric columns with given value of the filtered values"""
    _inc: generative_token_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: generative_token_set_input

    """filter the rows which have to be updated"""
    where: generative_token_bool_exp!
  ): generative_token_mutation_response

  """
  update single row of the table: "generative_token"
  """
  update_generative_token_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: generative_token_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: generative_token_set_input
    pk_columns: generative_token_pk_columns_input!
  ): generative_token

  """
  update multiples rows of table: "generative_token"
  """
  update_generative_token_many(
    """updates to execute, in order"""
    updates: [generative_token_updates!]!
  ): [generative_token_mutation_response]

  """
  update data of the table: "gentk_assign"
  """
  update_gentk_assign(
    """increments the numeric columns with given value of the filtered values"""
    _inc: gentk_assign_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: gentk_assign_set_input

    """filter the rows which have to be updated"""
    where: gentk_assign_bool_exp!
  ): gentk_assign_mutation_response

  """
  update single row of the table: "gentk_assign"
  """
  update_gentk_assign_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: gentk_assign_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: gentk_assign_set_input
    pk_columns: gentk_assign_pk_columns_input!
  ): gentk_assign

  """
  update multiples rows of table: "gentk_assign"
  """
  update_gentk_assign_many(
    """updates to execute, in order"""
    updates: [gentk_assign_updates!]!
  ): [gentk_assign_mutation_response]

  """
  update data of the table: "ipfs_cid"
  """
  update_ipfs_cid(
    """sets the columns of the filtered rows to the given values"""
    _set: ipfs_cid_set_input

    """filter the rows which have to be updated"""
    where: ipfs_cid_bool_exp!
  ): ipfs_cid_mutation_response

  """
  update single row of the table: "ipfs_cid"
  """
  update_ipfs_cid_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: ipfs_cid_set_input
    pk_columns: ipfs_cid_pk_columns_input!
  ): ipfs_cid

  """
  update multiples rows of table: "ipfs_cid"
  """
  update_ipfs_cid_many(
    """updates to execute, in order"""
    updates: [ipfs_cid_updates!]!
  ): [ipfs_cid_mutation_response]

  """
  update data of the table: "listing"
  """
  update_listing(
    """increments the numeric columns with given value of the filtered values"""
    _inc: listing_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: listing_set_input

    """filter the rows which have to be updated"""
    where: listing_bool_exp!
  ): listing_mutation_response

  """
  update single row of the table: "listing"
  """
  update_listing_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: listing_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: listing_set_input
    pk_columns: listing_pk_columns_input!
  ): listing

  """
  update multiples rows of table: "listing"
  """
  update_listing_many(
    """updates to execute, in order"""
    updates: [listing_updates!]!
  ): [listing_mutation_response]

  """
  update data of the table: "market_stats"
  """
  update_market_stats(
    """increments the numeric columns with given value of the filtered values"""
    _inc: market_stats_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: market_stats_set_input

    """filter the rows which have to be updated"""
    where: market_stats_bool_exp!
  ): market_stats_mutation_response

  """
  update single row of the table: "market_stats"
  """
  update_market_stats_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: market_stats_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: market_stats_set_input
    pk_columns: market_stats_pk_columns_input!
  ): market_stats

  """
  update data of the table: "market_stats_history"
  """
  update_market_stats_history(
    """increments the numeric columns with given value of the filtered values"""
    _inc: market_stats_history_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: market_stats_history_set_input

    """filter the rows which have to be updated"""
    where: market_stats_history_bool_exp!
  ): market_stats_history_mutation_response

  """
  update single row of the table: "market_stats_history"
  """
  update_market_stats_history_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: market_stats_history_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: market_stats_history_set_input
    pk_columns: market_stats_history_pk_columns_input!
  ): market_stats_history

  """
  update multiples rows of table: "market_stats_history"
  """
  update_market_stats_history_many(
    """updates to execute, in order"""
    updates: [market_stats_history_updates!]!
  ): [market_stats_history_mutation_response]

  """
  update multiples rows of table: "market_stats"
  """
  update_market_stats_many(
    """updates to execute, in order"""
    updates: [market_stats_updates!]!
  ): [market_stats_mutation_response]

  """
  update data of the table: "media_image"
  """
  update_media_image(
    """increments the numeric columns with given value of the filtered values"""
    _inc: media_image_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: media_image_set_input

    """filter the rows which have to be updated"""
    where: media_image_bool_exp!
  ): media_image_mutation_response

  """
  update single row of the table: "media_image"
  """
  update_media_image_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: media_image_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: media_image_set_input
    pk_columns: media_image_pk_columns_input!
  ): media_image

  """
  update multiples rows of table: "media_image"
  """
  update_media_image_many(
    """updates to execute, in order"""
    updates: [media_image_updates!]!
  ): [media_image_mutation_response]

  """
  update data of the table: "mint_ticket"
  """
  update_mint_ticket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mint_ticket_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mint_ticket_set_input

    """filter the rows which have to be updated"""
    where: mint_ticket_bool_exp!
  ): mint_ticket_mutation_response

  """
  update single row of the table: "mint_ticket"
  """
  update_mint_ticket_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mint_ticket_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mint_ticket_set_input
    pk_columns: mint_ticket_pk_columns_input!
  ): mint_ticket

  """
  update multiples rows of table: "mint_ticket"
  """
  update_mint_ticket_many(
    """updates to execute, in order"""
    updates: [mint_ticket_updates!]!
  ): [mint_ticket_mutation_response]

  """
  update data of the table: "mint_ticket_settings"
  """
  update_mint_ticket_settings(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mint_ticket_settings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mint_ticket_settings_set_input

    """filter the rows which have to be updated"""
    where: mint_ticket_settings_bool_exp!
  ): mint_ticket_settings_mutation_response

  """
  update single row of the table: "mint_ticket_settings"
  """
  update_mint_ticket_settings_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: mint_ticket_settings_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: mint_ticket_settings_set_input
    pk_columns: mint_ticket_settings_pk_columns_input!
  ): mint_ticket_settings

  """
  update multiples rows of table: "mint_ticket_settings"
  """
  update_mint_ticket_settings_many(
    """updates to execute, in order"""
    updates: [mint_ticket_settings_updates!]!
  ): [mint_ticket_settings_mutation_response]

  """
  update data of the table: "moderation_reason"
  """
  update_moderation_reason(
    """sets the columns of the filtered rows to the given values"""
    _set: moderation_reason_set_input

    """filter the rows which have to be updated"""
    where: moderation_reason_bool_exp!
  ): moderation_reason_mutation_response

  """
  update single row of the table: "moderation_reason"
  """
  update_moderation_reason_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: moderation_reason_set_input
    pk_columns: moderation_reason_pk_columns_input!
  ): moderation_reason

  """
  update multiples rows of table: "moderation_reason"
  """
  update_moderation_reason_many(
    """updates to execute, in order"""
    updates: [moderation_reason_updates!]!
  ): [moderation_reason_mutation_response]

  """
  update data of the table: "objkt"
  """
  update_objkt(
    """increments the numeric columns with given value of the filtered values"""
    _inc: objkt_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: objkt_set_input

    """filter the rows which have to be updated"""
    where: objkt_bool_exp!
  ): objkt_mutation_response

  """
  update single row of the table: "objkt"
  """
  update_objkt_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: objkt_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: objkt_set_input
    pk_columns: objkt_pk_columns_input!
  ): objkt

  """
  update multiples rows of table: "objkt"
  """
  update_objkt_many(
    """updates to execute, in order"""
    updates: [objkt_updates!]!
  ): [objkt_mutation_response]

  """
  update data of the table: "offer"
  """
  update_offer(
    """increments the numeric columns with given value of the filtered values"""
    _inc: offer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: offer_set_input

    """filter the rows which have to be updated"""
    where: offer_bool_exp!
  ): offer_mutation_response

  """
  update single row of the table: "offer"
  """
  update_offer_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: offer_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: offer_set_input
    pk_columns: offer_pk_columns_input!
  ): offer

  """
  update multiples rows of table: "offer"
  """
  update_offer_many(
    """updates to execute, in order"""
    updates: [offer_updates!]!
  ): [offer_mutation_response]

  """
  update data of the table: "pricing_dutch_auction"
  """
  update_pricing_dutch_auction(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pricing_dutch_auction_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pricing_dutch_auction_set_input

    """filter the rows which have to be updated"""
    where: pricing_dutch_auction_bool_exp!
  ): pricing_dutch_auction_mutation_response

  """
  update single row of the table: "pricing_dutch_auction"
  """
  update_pricing_dutch_auction_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pricing_dutch_auction_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pricing_dutch_auction_set_input
    pk_columns: pricing_dutch_auction_pk_columns_input!
  ): pricing_dutch_auction

  """
  update multiples rows of table: "pricing_dutch_auction"
  """
  update_pricing_dutch_auction_many(
    """updates to execute, in order"""
    updates: [pricing_dutch_auction_updates!]!
  ): [pricing_dutch_auction_mutation_response]

  """
  update data of the table: "pricing_fixed"
  """
  update_pricing_fixed(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pricing_fixed_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pricing_fixed_set_input

    """filter the rows which have to be updated"""
    where: pricing_fixed_bool_exp!
  ): pricing_fixed_mutation_response

  """
  update single row of the table: "pricing_fixed"
  """
  update_pricing_fixed_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: pricing_fixed_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: pricing_fixed_set_input
    pk_columns: pricing_fixed_pk_columns_input!
  ): pricing_fixed

  """
  update multiples rows of table: "pricing_fixed"
  """
  update_pricing_fixed_many(
    """updates to execute, in order"""
    updates: [pricing_fixed_updates!]!
  ): [pricing_fixed_mutation_response]

  """
  update data of the table: "redeemable"
  """
  update_redeemable(
    """increments the numeric columns with given value of the filtered values"""
    _inc: redeemable_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: redeemable_set_input

    """filter the rows which have to be updated"""
    where: redeemable_bool_exp!
  ): redeemable_mutation_response

  """
  update single row of the table: "redeemable"
  """
  update_redeemable_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: redeemable_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: redeemable_set_input
    pk_columns: redeemable_pk_columns_input!
  ): redeemable

  """
  update multiples rows of table: "redeemable"
  """
  update_redeemable_many(
    """updates to execute, in order"""
    updates: [redeemable_updates!]!
  ): [redeemable_mutation_response]

  """
  update data of the table: "redemption"
  """
  update_redemption(
    """increments the numeric columns with given value of the filtered values"""
    _inc: redemption_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: redemption_set_input

    """filter the rows which have to be updated"""
    where: redemption_bool_exp!
  ): redemption_mutation_response

  """
  update single row of the table: "redemption"
  """
  update_redemption_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: redemption_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: redemption_set_input
    pk_columns: redemption_pk_columns_input!
  ): redemption

  """
  update multiples rows of table: "redemption"
  """
  update_redemption_many(
    """updates to execute, in order"""
    updates: [redemption_updates!]!
  ): [redemption_mutation_response]

  """
  update data of the table: "report"
  """
  update_report(
    """sets the columns of the filtered rows to the given values"""
    _set: report_set_input

    """filter the rows which have to be updated"""
    where: report_bool_exp!
  ): report_mutation_response

  """
  update single row of the table: "report"
  """
  update_report_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: report_set_input
    pk_columns: report_pk_columns_input!
  ): report

  """
  update multiples rows of table: "report"
  """
  update_report_many(
    """updates to execute, in order"""
    updates: [report_updates!]!
  ): [report_mutation_response]

  """
  update data of the table: "reserve"
  """
  update_reserve(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: reserve_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: reserve_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: reserve_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: reserve_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: reserve_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: reserve_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: reserve_set_input

    """filter the rows which have to be updated"""
    where: reserve_bool_exp!
  ): reserve_mutation_response

  """
  update single row of the table: "reserve"
  """
  update_reserve_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: reserve_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: reserve_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: reserve_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: reserve_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: reserve_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: reserve_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: reserve_set_input
    pk_columns: reserve_pk_columns_input!
  ): reserve

  """
  update multiples rows of table: "reserve"
  """
  update_reserve_many(
    """updates to execute, in order"""
    updates: [reserve_updates!]!
  ): [reserve_mutation_response]

  """
  update data of the table: "split"
  """
  update_split(
    """increments the numeric columns with given value of the filtered values"""
    _inc: split_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: split_set_input

    """filter the rows which have to be updated"""
    where: split_bool_exp!
  ): split_mutation_response

  """
  update single row of the table: "split"
  """
  update_split_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: split_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: split_set_input
    pk_columns: split_pk_columns_input!
  ): split

  """
  update multiples rows of table: "split"
  """
  update_split_many(
    """updates to execute, in order"""
    updates: [split_updates!]!
  ): [split_mutation_response]

  """
  update data of the table: "transaction"
  """
  update_transaction(
    """increments the numeric columns with given value of the filtered values"""
    _inc: transaction_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: transaction_set_input

    """filter the rows which have to be updated"""
    where: transaction_bool_exp!
  ): transaction_mutation_response

  """
  update single row of the table: "transaction"
  """
  update_transaction_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: transaction_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: transaction_set_input
    pk_columns: transaction_pk_columns_input!
  ): transaction

  """
  update multiples rows of table: "transaction"
  """
  update_transaction_many(
    """updates to execute, in order"""
    updates: [transaction_updates!]!
  ): [transaction_mutation_response]

  """
  update data of the table: "user"
  """
  update_user(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input

    """filter the rows which have to be updated"""
    where: user_bool_exp!
  ): user_mutation_response

  """
  update single row of the table: "user"
  """
  update_user_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_set_input
    pk_columns: user_pk_columns_input!
  ): user

  """
  update multiples rows of table: "user"
  """
  update_user_many(
    """updates to execute, in order"""
    updates: [user_updates!]!
  ): [user_mutation_response]

  """
  update data of the table: "user_stats"
  """
  update_user_stats(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_stats_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_stats_set_input

    """filter the rows which have to be updated"""
    where: user_stats_bool_exp!
  ): user_stats_mutation_response

  """
  update single row of the table: "user_stats"
  """
  update_user_stats_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_stats_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_stats_set_input
    pk_columns: user_stats_pk_columns_input!
  ): user_stats

  """
  update multiples rows of table: "user_stats"
  """
  update_user_stats_many(
    """updates to execute, in order"""
    updates: [user_stats_updates!]!
  ): [user_stats_mutation_response]
}

scalar numeric

"""
Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'.
"""
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"""
columns and relationships of "objkt"
"""
type objkt {
  """An array relationship"""
  actions(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """An aggregate relationship"""
  actions_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!
  assigned: Boolean
  assigned_at: timestamptz

  """An array relationship"""
  auctions(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): [auction!]!

  """An aggregate relationship"""
  auctions_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): auction_aggregate!
  captureMediaId: bpchar
  created_at: timestamptz!
  display_uri: bpchar
  duplicate: Boolean
  features(
    """JSON select path"""
    path: String
  ): json
  generation_hash: String

  """An object relationship"""
  generative_token: generative_token!

  """An object relationship"""
  gentk_assign: gentk_assign
  id: String!
  input_bytes: String
  issuer_id: String!
  issuer_version: generative_token_version!
  iteration: numeric

  """An array relationship"""
  listings(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): [listing!]!

  """An aggregate relationship"""
  listings_aggregate(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): listing_aggregate!

  """An object relationship"""
  media_image: media_image
  metadata(
    """JSON select path"""
    path: String
  ): json
  metadata_uri: String
  minter_id: String
  name: String

  """An array relationship"""
  offers(
    """distinct select on columns"""
    distinct_on: [offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_order_by!]

    """filter the rows returned"""
    where: offer_bool_exp
  ): [offer!]!

  """An aggregate relationship"""
  offers_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_order_by!]

    """filter the rows returned"""
    where: offer_bool_exp
  ): offer_aggregate!
  owner_id: String
  rarity: float8

  """An array relationship"""
  redemptions(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): [redemption!]!

  """An aggregate relationship"""
  redemptions_aggregate(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): redemption_aggregate!
  royalties: Int!
  slug: String

  """An array relationship"""
  splits(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """An aggregate relationship"""
  splits_aggregate(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): split_aggregate!
  tags: _text
  thumbnail_uri: bpchar

  """An array relationship"""
  transactions(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """An aggregate relationship"""
  transactions_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!
  updated_at: timestamptz

  """An object relationship"""
  user: user

  """An object relationship"""
  userByOwnerId: user
  version: Int!
}

"""
aggregated selection of "objkt"
"""
type objkt_aggregate {
  aggregate: objkt_aggregate_fields
  nodes: [objkt!]!
}

input objkt_aggregate_bool_exp {
  avg: objkt_aggregate_bool_exp_avg
  bool_and: objkt_aggregate_bool_exp_bool_and
  bool_or: objkt_aggregate_bool_exp_bool_or
  corr: objkt_aggregate_bool_exp_corr
  count: objkt_aggregate_bool_exp_count
  covar_samp: objkt_aggregate_bool_exp_covar_samp
  max: objkt_aggregate_bool_exp_max
  min: objkt_aggregate_bool_exp_min
  stddev_samp: objkt_aggregate_bool_exp_stddev_samp
  sum: objkt_aggregate_bool_exp_sum
  var_samp: objkt_aggregate_bool_exp_var_samp
}

input objkt_aggregate_bool_exp_avg {
  arguments: objkt_select_column_objkt_aggregate_bool_exp_avg_arguments_columns!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: float8_comparison_exp!
}

input objkt_aggregate_bool_exp_bool_and {
  arguments: objkt_select_column_objkt_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: Boolean_comparison_exp!
}

input objkt_aggregate_bool_exp_bool_or {
  arguments: objkt_select_column_objkt_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: Boolean_comparison_exp!
}

input objkt_aggregate_bool_exp_corr {
  arguments: objkt_aggregate_bool_exp_corr_arguments!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: float8_comparison_exp!
}

input objkt_aggregate_bool_exp_corr_arguments {
  X: objkt_select_column_objkt_aggregate_bool_exp_corr_arguments_columns!
  Y: objkt_select_column_objkt_aggregate_bool_exp_corr_arguments_columns!
}

input objkt_aggregate_bool_exp_count {
  arguments: [objkt_select_column!]
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: Int_comparison_exp!
}

input objkt_aggregate_bool_exp_covar_samp {
  arguments: objkt_aggregate_bool_exp_covar_samp_arguments!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: float8_comparison_exp!
}

input objkt_aggregate_bool_exp_covar_samp_arguments {
  X: objkt_select_column_objkt_aggregate_bool_exp_covar_samp_arguments_columns!
  Y: objkt_select_column_objkt_aggregate_bool_exp_covar_samp_arguments_columns!
}

input objkt_aggregate_bool_exp_max {
  arguments: objkt_select_column_objkt_aggregate_bool_exp_max_arguments_columns!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: float8_comparison_exp!
}

input objkt_aggregate_bool_exp_min {
  arguments: objkt_select_column_objkt_aggregate_bool_exp_min_arguments_columns!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: float8_comparison_exp!
}

input objkt_aggregate_bool_exp_stddev_samp {
  arguments: objkt_select_column_objkt_aggregate_bool_exp_stddev_samp_arguments_columns!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: float8_comparison_exp!
}

input objkt_aggregate_bool_exp_sum {
  arguments: objkt_select_column_objkt_aggregate_bool_exp_sum_arguments_columns!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: float8_comparison_exp!
}

input objkt_aggregate_bool_exp_var_samp {
  arguments: objkt_select_column_objkt_aggregate_bool_exp_var_samp_arguments_columns!
  distinct: Boolean
  filter: objkt_bool_exp
  predicate: float8_comparison_exp!
}

"""
aggregate fields of "objkt"
"""
type objkt_aggregate_fields {
  avg: objkt_avg_fields
  count(columns: [objkt_select_column!], distinct: Boolean): Int!
  max: objkt_max_fields
  min: objkt_min_fields
  stddev: objkt_stddev_fields
  stddev_pop: objkt_stddev_pop_fields
  stddev_samp: objkt_stddev_samp_fields
  sum: objkt_sum_fields
  var_pop: objkt_var_pop_fields
  var_samp: objkt_var_samp_fields
  variance: objkt_variance_fields
}

"""
order by aggregate values of table "objkt"
"""
input objkt_aggregate_order_by {
  avg: objkt_avg_order_by
  count: order_by
  max: objkt_max_order_by
  min: objkt_min_order_by
  stddev: objkt_stddev_order_by
  stddev_pop: objkt_stddev_pop_order_by
  stddev_samp: objkt_stddev_samp_order_by
  sum: objkt_sum_order_by
  var_pop: objkt_var_pop_order_by
  var_samp: objkt_var_samp_order_by
  variance: objkt_variance_order_by
}

"""
input type for inserting array relation for remote table "objkt"
"""
input objkt_arr_rel_insert_input {
  data: [objkt_insert_input!]!

  """upsert condition"""
  on_conflict: objkt_on_conflict
}

"""aggregate avg on columns"""
type objkt_avg_fields {
  iteration: Float
  rarity: Float
  royalties: Float
  version: Float
}

"""
order by avg() on columns of table "objkt"
"""
input objkt_avg_order_by {
  iteration: order_by
  rarity: order_by
  royalties: order_by
  version: order_by
}

"""
Boolean expression to filter rows from the table "objkt". All fields are combined with a logical 'AND'.
"""
input objkt_bool_exp {
  _and: [objkt_bool_exp!]
  _not: objkt_bool_exp
  _or: [objkt_bool_exp!]
  actions: action_bool_exp
  actions_aggregate: action_aggregate_bool_exp
  assigned: Boolean_comparison_exp
  assigned_at: timestamptz_comparison_exp
  auctions: auction_bool_exp
  auctions_aggregate: auction_aggregate_bool_exp
  captureMediaId: bpchar_comparison_exp
  created_at: timestamptz_comparison_exp
  display_uri: bpchar_comparison_exp
  duplicate: Boolean_comparison_exp
  features: json_comparison_exp
  generation_hash: String_comparison_exp
  generative_token: generative_token_bool_exp
  gentk_assign: gentk_assign_bool_exp
  id: String_comparison_exp
  input_bytes: String_comparison_exp
  issuer_id: String_comparison_exp
  issuer_version: generative_token_version_comparison_exp
  iteration: numeric_comparison_exp
  listings: listing_bool_exp
  listings_aggregate: listing_aggregate_bool_exp
  media_image: media_image_bool_exp
  metadata: json_comparison_exp
  metadata_uri: String_comparison_exp
  minter_id: String_comparison_exp
  name: String_comparison_exp
  offers: offer_bool_exp
  offers_aggregate: offer_aggregate_bool_exp
  owner_id: String_comparison_exp
  rarity: float8_comparison_exp
  redemptions: redemption_bool_exp
  redemptions_aggregate: redemption_aggregate_bool_exp
  royalties: Int_comparison_exp
  slug: String_comparison_exp
  splits: split_bool_exp
  splits_aggregate: split_aggregate_bool_exp
  tags: _text_comparison_exp
  thumbnail_uri: bpchar_comparison_exp
  transactions: transaction_bool_exp
  transactions_aggregate: transaction_aggregate_bool_exp
  updated_at: timestamptz_comparison_exp
  user: user_bool_exp
  userByOwnerId: user_bool_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "objkt"
"""
enum objkt_constraint {
  """
  unique or primary key constraint on columns "slug"
  """
  IDX_75a2e34e67529e5d0c2758d4d2

  """
  unique or primary key constraint on columns "id", "issuer_version"
  """
  PK_21ce4aa2c6889add2f734e70372
}

"""
input type for incrementing numeric columns in table "objkt"
"""
input objkt_inc_input {
  iteration: numeric
  rarity: float8
  royalties: Int
  version: Int
}

"""
input type for inserting data into table "objkt"
"""
input objkt_insert_input {
  actions: action_arr_rel_insert_input
  assigned: Boolean
  assigned_at: timestamptz
  auctions: auction_arr_rel_insert_input
  captureMediaId: bpchar
  created_at: timestamptz
  display_uri: bpchar
  duplicate: Boolean
  features: json
  generation_hash: String
  generative_token: generative_token_obj_rel_insert_input
  gentk_assign: gentk_assign_obj_rel_insert_input
  id: String
  input_bytes: String
  issuer_id: String
  issuer_version: generative_token_version
  iteration: numeric
  listings: listing_arr_rel_insert_input
  media_image: media_image_obj_rel_insert_input
  metadata: json
  metadata_uri: String
  minter_id: String
  name: String
  offers: offer_arr_rel_insert_input
  owner_id: String
  rarity: float8
  redemptions: redemption_arr_rel_insert_input
  royalties: Int
  slug: String
  splits: split_arr_rel_insert_input
  tags: _text
  thumbnail_uri: bpchar
  transactions: transaction_arr_rel_insert_input
  updated_at: timestamptz
  user: user_obj_rel_insert_input
  userByOwnerId: user_obj_rel_insert_input
  version: Int
}

"""aggregate max on columns"""
type objkt_max_fields {
  assigned_at: timestamptz
  captureMediaId: bpchar
  created_at: timestamptz
  display_uri: bpchar
  generation_hash: String
  id: String
  input_bytes: String
  issuer_id: String
  issuer_version: generative_token_version
  iteration: numeric
  metadata_uri: String
  minter_id: String
  name: String
  owner_id: String
  rarity: float8
  royalties: Int
  slug: String
  thumbnail_uri: bpchar
  updated_at: timestamptz
  version: Int
}

"""
order by max() on columns of table "objkt"
"""
input objkt_max_order_by {
  assigned_at: order_by
  captureMediaId: order_by
  created_at: order_by
  display_uri: order_by
  generation_hash: order_by
  id: order_by
  input_bytes: order_by
  issuer_id: order_by
  issuer_version: order_by
  iteration: order_by
  metadata_uri: order_by
  minter_id: order_by
  name: order_by
  owner_id: order_by
  rarity: order_by
  royalties: order_by
  slug: order_by
  thumbnail_uri: order_by
  updated_at: order_by
  version: order_by
}

"""aggregate min on columns"""
type objkt_min_fields {
  assigned_at: timestamptz
  captureMediaId: bpchar
  created_at: timestamptz
  display_uri: bpchar
  generation_hash: String
  id: String
  input_bytes: String
  issuer_id: String
  issuer_version: generative_token_version
  iteration: numeric
  metadata_uri: String
  minter_id: String
  name: String
  owner_id: String
  rarity: float8
  royalties: Int
  slug: String
  thumbnail_uri: bpchar
  updated_at: timestamptz
  version: Int
}

"""
order by min() on columns of table "objkt"
"""
input objkt_min_order_by {
  assigned_at: order_by
  captureMediaId: order_by
  created_at: order_by
  display_uri: order_by
  generation_hash: order_by
  id: order_by
  input_bytes: order_by
  issuer_id: order_by
  issuer_version: order_by
  iteration: order_by
  metadata_uri: order_by
  minter_id: order_by
  name: order_by
  owner_id: order_by
  rarity: order_by
  royalties: order_by
  slug: order_by
  thumbnail_uri: order_by
  updated_at: order_by
  version: order_by
}

"""
response of any mutation on the table "objkt"
"""
type objkt_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [objkt!]!
}

"""
input type for inserting object relation for remote table "objkt"
"""
input objkt_obj_rel_insert_input {
  data: objkt_insert_input!

  """upsert condition"""
  on_conflict: objkt_on_conflict
}

"""
on_conflict condition type for table "objkt"
"""
input objkt_on_conflict {
  constraint: objkt_constraint!
  update_columns: [objkt_update_column!]! = []
  where: objkt_bool_exp
}

"""Ordering options when selecting data from "objkt"."""
input objkt_order_by {
  actions_aggregate: action_aggregate_order_by
  assigned: order_by
  assigned_at: order_by
  auctions_aggregate: auction_aggregate_order_by
  captureMediaId: order_by
  created_at: order_by
  display_uri: order_by
  duplicate: order_by
  features: order_by
  generation_hash: order_by
  generative_token: generative_token_order_by
  gentk_assign: gentk_assign_order_by
  id: order_by
  input_bytes: order_by
  issuer_id: order_by
  issuer_version: order_by
  iteration: order_by
  listings_aggregate: listing_aggregate_order_by
  media_image: media_image_order_by
  metadata: order_by
  metadata_uri: order_by
  minter_id: order_by
  name: order_by
  offers_aggregate: offer_aggregate_order_by
  owner_id: order_by
  rarity: order_by
  redemptions_aggregate: redemption_aggregate_order_by
  royalties: order_by
  slug: order_by
  splits_aggregate: split_aggregate_order_by
  tags: order_by
  thumbnail_uri: order_by
  transactions_aggregate: transaction_aggregate_order_by
  updated_at: order_by
  user: user_order_by
  userByOwnerId: user_order_by
  version: order_by
}

"""primary key columns input for table: objkt"""
input objkt_pk_columns_input {
  id: String!
  issuer_version: generative_token_version!
}

"""
select columns of table "objkt"
"""
enum objkt_select_column {
  """column name"""
  assigned

  """column name"""
  assigned_at

  """column name"""
  captureMediaId

  """column name"""
  created_at

  """column name"""
  display_uri

  """column name"""
  duplicate

  """column name"""
  features

  """column name"""
  generation_hash

  """column name"""
  id

  """column name"""
  input_bytes

  """column name"""
  issuer_id

  """column name"""
  issuer_version

  """column name"""
  iteration

  """column name"""
  metadata

  """column name"""
  metadata_uri

  """column name"""
  minter_id

  """column name"""
  name

  """column name"""
  owner_id

  """column name"""
  rarity

  """column name"""
  royalties

  """column name"""
  slug

  """column name"""
  tags

  """column name"""
  thumbnail_uri

  """column name"""
  updated_at

  """column name"""
  version
}

"""
select "objkt_aggregate_bool_exp_avg_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_avg_arguments_columns {
  """column name"""
  rarity
}

"""
select "objkt_aggregate_bool_exp_bool_and_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_bool_and_arguments_columns {
  """column name"""
  assigned

  """column name"""
  duplicate
}

"""
select "objkt_aggregate_bool_exp_bool_or_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_bool_or_arguments_columns {
  """column name"""
  assigned

  """column name"""
  duplicate
}

"""
select "objkt_aggregate_bool_exp_corr_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_corr_arguments_columns {
  """column name"""
  rarity
}

"""
select "objkt_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_covar_samp_arguments_columns {
  """column name"""
  rarity
}

"""
select "objkt_aggregate_bool_exp_max_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_max_arguments_columns {
  """column name"""
  rarity
}

"""
select "objkt_aggregate_bool_exp_min_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_min_arguments_columns {
  """column name"""
  rarity
}

"""
select "objkt_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_stddev_samp_arguments_columns {
  """column name"""
  rarity
}

"""
select "objkt_aggregate_bool_exp_sum_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_sum_arguments_columns {
  """column name"""
  rarity
}

"""
select "objkt_aggregate_bool_exp_var_samp_arguments_columns" columns of table "objkt"
"""
enum objkt_select_column_objkt_aggregate_bool_exp_var_samp_arguments_columns {
  """column name"""
  rarity
}

"""
input type for updating data in table "objkt"
"""
input objkt_set_input {
  assigned: Boolean
  assigned_at: timestamptz
  captureMediaId: bpchar
  created_at: timestamptz
  display_uri: bpchar
  duplicate: Boolean
  features: json
  generation_hash: String
  id: String
  input_bytes: String
  issuer_id: String
  issuer_version: generative_token_version
  iteration: numeric
  metadata: json
  metadata_uri: String
  minter_id: String
  name: String
  owner_id: String
  rarity: float8
  royalties: Int
  slug: String
  tags: _text
  thumbnail_uri: bpchar
  updated_at: timestamptz
  version: Int
}

"""aggregate stddev on columns"""
type objkt_stddev_fields {
  iteration: Float
  rarity: Float
  royalties: Float
  version: Float
}

"""
order by stddev() on columns of table "objkt"
"""
input objkt_stddev_order_by {
  iteration: order_by
  rarity: order_by
  royalties: order_by
  version: order_by
}

"""aggregate stddev_pop on columns"""
type objkt_stddev_pop_fields {
  iteration: Float
  rarity: Float
  royalties: Float
  version: Float
}

"""
order by stddev_pop() on columns of table "objkt"
"""
input objkt_stddev_pop_order_by {
  iteration: order_by
  rarity: order_by
  royalties: order_by
  version: order_by
}

"""aggregate stddev_samp on columns"""
type objkt_stddev_samp_fields {
  iteration: Float
  rarity: Float
  royalties: Float
  version: Float
}

"""
order by stddev_samp() on columns of table "objkt"
"""
input objkt_stddev_samp_order_by {
  iteration: order_by
  rarity: order_by
  royalties: order_by
  version: order_by
}

"""
Streaming cursor of the table "objkt"
"""
input objkt_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: objkt_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input objkt_stream_cursor_value_input {
  assigned: Boolean
  assigned_at: timestamptz
  captureMediaId: bpchar
  created_at: timestamptz
  display_uri: bpchar
  duplicate: Boolean
  features: json
  generation_hash: String
  id: String
  input_bytes: String
  issuer_id: String
  issuer_version: generative_token_version
  iteration: numeric
  metadata: json
  metadata_uri: String
  minter_id: String
  name: String
  owner_id: String
  rarity: float8
  royalties: Int
  slug: String
  tags: _text
  thumbnail_uri: bpchar
  updated_at: timestamptz
  version: Int
}

"""aggregate sum on columns"""
type objkt_sum_fields {
  iteration: numeric
  rarity: float8
  royalties: Int
  version: Int
}

"""
order by sum() on columns of table "objkt"
"""
input objkt_sum_order_by {
  iteration: order_by
  rarity: order_by
  royalties: order_by
  version: order_by
}

"""
update columns of table "objkt"
"""
enum objkt_update_column {
  """column name"""
  assigned

  """column name"""
  assigned_at

  """column name"""
  captureMediaId

  """column name"""
  created_at

  """column name"""
  display_uri

  """column name"""
  duplicate

  """column name"""
  features

  """column name"""
  generation_hash

  """column name"""
  id

  """column name"""
  input_bytes

  """column name"""
  issuer_id

  """column name"""
  issuer_version

  """column name"""
  iteration

  """column name"""
  metadata

  """column name"""
  metadata_uri

  """column name"""
  minter_id

  """column name"""
  name

  """column name"""
  owner_id

  """column name"""
  rarity

  """column name"""
  royalties

  """column name"""
  slug

  """column name"""
  tags

  """column name"""
  thumbnail_uri

  """column name"""
  updated_at

  """column name"""
  version
}

input objkt_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: objkt_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: objkt_set_input

  """filter the rows which have to be updated"""
  where: objkt_bool_exp!
}

"""aggregate var_pop on columns"""
type objkt_var_pop_fields {
  iteration: Float
  rarity: Float
  royalties: Float
  version: Float
}

"""
order by var_pop() on columns of table "objkt"
"""
input objkt_var_pop_order_by {
  iteration: order_by
  rarity: order_by
  royalties: order_by
  version: order_by
}

"""aggregate var_samp on columns"""
type objkt_var_samp_fields {
  iteration: Float
  rarity: Float
  royalties: Float
  version: Float
}

"""
order by var_samp() on columns of table "objkt"
"""
input objkt_var_samp_order_by {
  iteration: order_by
  rarity: order_by
  royalties: order_by
  version: order_by
}

"""aggregate variance on columns"""
type objkt_variance_fields {
  iteration: Float
  rarity: Float
  royalties: Float
  version: Float
}

"""
order by variance() on columns of table "objkt"
"""
input objkt_variance_order_by {
  iteration: order_by
  rarity: order_by
  royalties: order_by
  version: order_by
}

"""
columns and relationships of "offer"
"""
type offer {
  accepted_at: timestamptz
  buyer_id: String
  cancelled_at: timestamptz
  created_at: timestamptz!
  id: String!

  """An object relationship"""
  objkt: objkt
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric!

  """An object relationship"""
  user: user
  version: Int!
}

"""
aggregated selection of "offer"
"""
type offer_aggregate {
  aggregate: offer_aggregate_fields
  nodes: [offer!]!
}

input offer_aggregate_bool_exp {
  count: offer_aggregate_bool_exp_count
}

input offer_aggregate_bool_exp_count {
  arguments: [offer_select_column!]
  distinct: Boolean
  filter: offer_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "offer"
"""
type offer_aggregate_fields {
  avg: offer_avg_fields
  count(columns: [offer_select_column!], distinct: Boolean): Int!
  max: offer_max_fields
  min: offer_min_fields
  stddev: offer_stddev_fields
  stddev_pop: offer_stddev_pop_fields
  stddev_samp: offer_stddev_samp_fields
  sum: offer_sum_fields
  var_pop: offer_var_pop_fields
  var_samp: offer_var_samp_fields
  variance: offer_variance_fields
}

"""
order by aggregate values of table "offer"
"""
input offer_aggregate_order_by {
  avg: offer_avg_order_by
  count: order_by
  max: offer_max_order_by
  min: offer_min_order_by
  stddev: offer_stddev_order_by
  stddev_pop: offer_stddev_pop_order_by
  stddev_samp: offer_stddev_samp_order_by
  sum: offer_sum_order_by
  var_pop: offer_var_pop_order_by
  var_samp: offer_var_samp_order_by
  variance: offer_variance_order_by
}

"""
input type for inserting array relation for remote table "offer"
"""
input offer_arr_rel_insert_input {
  data: [offer_insert_input!]!

  """upsert condition"""
  on_conflict: offer_on_conflict
}

"""aggregate avg on columns"""
type offer_avg_fields {
  price: Float
  version: Float
}

"""
order by avg() on columns of table "offer"
"""
input offer_avg_order_by {
  price: order_by
  version: order_by
}

"""
Boolean expression to filter rows from the table "offer". All fields are combined with a logical 'AND'.
"""
input offer_bool_exp {
  _and: [offer_bool_exp!]
  _not: offer_bool_exp
  _or: [offer_bool_exp!]
  accepted_at: timestamptz_comparison_exp
  buyer_id: String_comparison_exp
  cancelled_at: timestamptz_comparison_exp
  created_at: timestamptz_comparison_exp
  id: String_comparison_exp
  objkt: objkt_bool_exp
  objkt_id: String_comparison_exp
  objkt_issuer_version: generative_token_version_comparison_exp
  price: numeric_comparison_exp
  user: user_bool_exp
  version: Int_comparison_exp
}

"""
unique or primary key constraints on table "offer"
"""
enum offer_constraint {
  """
  unique or primary key constraint on columns "id", "version"
  """
  PK_128207054b197333b6f58dd3581
}

"""
input type for incrementing numeric columns in table "offer"
"""
input offer_inc_input {
  price: numeric
  version: Int
}

"""
input type for inserting data into table "offer"
"""
input offer_insert_input {
  accepted_at: timestamptz
  buyer_id: String
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  objkt: objkt_obj_rel_insert_input
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  user: user_obj_rel_insert_input
  version: Int
}

"""aggregate max on columns"""
type offer_max_fields {
  accepted_at: timestamptz
  buyer_id: String
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  version: Int
}

"""
order by max() on columns of table "offer"
"""
input offer_max_order_by {
  accepted_at: order_by
  buyer_id: order_by
  cancelled_at: order_by
  created_at: order_by
  id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  price: order_by
  version: order_by
}

"""aggregate min on columns"""
type offer_min_fields {
  accepted_at: timestamptz
  buyer_id: String
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  version: Int
}

"""
order by min() on columns of table "offer"
"""
input offer_min_order_by {
  accepted_at: order_by
  buyer_id: order_by
  cancelled_at: order_by
  created_at: order_by
  id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  price: order_by
  version: order_by
}

"""
response of any mutation on the table "offer"
"""
type offer_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [offer!]!
}

"""
on_conflict condition type for table "offer"
"""
input offer_on_conflict {
  constraint: offer_constraint!
  update_columns: [offer_update_column!]! = []
  where: offer_bool_exp
}

"""Ordering options when selecting data from "offer"."""
input offer_order_by {
  accepted_at: order_by
  buyer_id: order_by
  cancelled_at: order_by
  created_at: order_by
  id: order_by
  objkt: objkt_order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  price: order_by
  user: user_order_by
  version: order_by
}

"""primary key columns input for table: offer"""
input offer_pk_columns_input {
  id: String!
  version: Int!
}

"""
select columns of table "offer"
"""
enum offer_select_column {
  """column name"""
  accepted_at

  """column name"""
  buyer_id

  """column name"""
  cancelled_at

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  price

  """column name"""
  version
}

"""
input type for updating data in table "offer"
"""
input offer_set_input {
  accepted_at: timestamptz
  buyer_id: String
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  version: Int
}

"""aggregate stddev on columns"""
type offer_stddev_fields {
  price: Float
  version: Float
}

"""
order by stddev() on columns of table "offer"
"""
input offer_stddev_order_by {
  price: order_by
  version: order_by
}

"""aggregate stddev_pop on columns"""
type offer_stddev_pop_fields {
  price: Float
  version: Float
}

"""
order by stddev_pop() on columns of table "offer"
"""
input offer_stddev_pop_order_by {
  price: order_by
  version: order_by
}

"""aggregate stddev_samp on columns"""
type offer_stddev_samp_fields {
  price: Float
  version: Float
}

"""
order by stddev_samp() on columns of table "offer"
"""
input offer_stddev_samp_order_by {
  price: order_by
  version: order_by
}

"""
Streaming cursor of the table "offer"
"""
input offer_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: offer_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input offer_stream_cursor_value_input {
  accepted_at: timestamptz
  buyer_id: String
  cancelled_at: timestamptz
  created_at: timestamptz
  id: String
  objkt_id: String
  objkt_issuer_version: generative_token_version
  price: numeric
  version: Int
}

"""aggregate sum on columns"""
type offer_sum_fields {
  price: numeric
  version: Int
}

"""
order by sum() on columns of table "offer"
"""
input offer_sum_order_by {
  price: order_by
  version: order_by
}

"""
update columns of table "offer"
"""
enum offer_update_column {
  """column name"""
  accepted_at

  """column name"""
  buyer_id

  """column name"""
  cancelled_at

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  price

  """column name"""
  version
}

input offer_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: offer_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: offer_set_input

  """filter the rows which have to be updated"""
  where: offer_bool_exp!
}

"""aggregate var_pop on columns"""
type offer_var_pop_fields {
  price: Float
  version: Float
}

"""
order by var_pop() on columns of table "offer"
"""
input offer_var_pop_order_by {
  price: order_by
  version: order_by
}

"""aggregate var_samp on columns"""
type offer_var_samp_fields {
  price: Float
  version: Float
}

"""
order by var_samp() on columns of table "offer"
"""
input offer_var_samp_order_by {
  price: order_by
  version: order_by
}

"""aggregate variance on columns"""
type offer_variance_fields {
  price: Float
  version: Float
}

"""
order by variance() on columns of table "offer"
"""
input offer_variance_order_by {
  price: order_by
  version: order_by
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

"""
columns and relationships of "pricing_dutch_auction"
"""
type pricing_dutch_auction {
  decrement_duration: bigint!
  final_price: bigint

  """An object relationship"""
  generative_token: generative_token
  id: String!
  levels: _int8!
  opens_at: timestamptz
  resting_price: String!
  token_id: String
}

"""
aggregated selection of "pricing_dutch_auction"
"""
type pricing_dutch_auction_aggregate {
  aggregate: pricing_dutch_auction_aggregate_fields
  nodes: [pricing_dutch_auction!]!
}

input pricing_dutch_auction_aggregate_bool_exp {
  count: pricing_dutch_auction_aggregate_bool_exp_count
}

input pricing_dutch_auction_aggregate_bool_exp_count {
  arguments: [pricing_dutch_auction_select_column!]
  distinct: Boolean
  filter: pricing_dutch_auction_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "pricing_dutch_auction"
"""
type pricing_dutch_auction_aggregate_fields {
  avg: pricing_dutch_auction_avg_fields
  count(columns: [pricing_dutch_auction_select_column!], distinct: Boolean): Int!
  max: pricing_dutch_auction_max_fields
  min: pricing_dutch_auction_min_fields
  stddev: pricing_dutch_auction_stddev_fields
  stddev_pop: pricing_dutch_auction_stddev_pop_fields
  stddev_samp: pricing_dutch_auction_stddev_samp_fields
  sum: pricing_dutch_auction_sum_fields
  var_pop: pricing_dutch_auction_var_pop_fields
  var_samp: pricing_dutch_auction_var_samp_fields
  variance: pricing_dutch_auction_variance_fields
}

"""
order by aggregate values of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_aggregate_order_by {
  avg: pricing_dutch_auction_avg_order_by
  count: order_by
  max: pricing_dutch_auction_max_order_by
  min: pricing_dutch_auction_min_order_by
  stddev: pricing_dutch_auction_stddev_order_by
  stddev_pop: pricing_dutch_auction_stddev_pop_order_by
  stddev_samp: pricing_dutch_auction_stddev_samp_order_by
  sum: pricing_dutch_auction_sum_order_by
  var_pop: pricing_dutch_auction_var_pop_order_by
  var_samp: pricing_dutch_auction_var_samp_order_by
  variance: pricing_dutch_auction_variance_order_by
}

"""
input type for inserting array relation for remote table "pricing_dutch_auction"
"""
input pricing_dutch_auction_arr_rel_insert_input {
  data: [pricing_dutch_auction_insert_input!]!

  """upsert condition"""
  on_conflict: pricing_dutch_auction_on_conflict
}

"""aggregate avg on columns"""
type pricing_dutch_auction_avg_fields {
  decrement_duration: Float
  final_price: Float
}

"""
order by avg() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_avg_order_by {
  decrement_duration: order_by
  final_price: order_by
}

"""
Boolean expression to filter rows from the table "pricing_dutch_auction". All fields are combined with a logical 'AND'.
"""
input pricing_dutch_auction_bool_exp {
  _and: [pricing_dutch_auction_bool_exp!]
  _not: pricing_dutch_auction_bool_exp
  _or: [pricing_dutch_auction_bool_exp!]
  decrement_duration: bigint_comparison_exp
  final_price: bigint_comparison_exp
  generative_token: generative_token_bool_exp
  id: String_comparison_exp
  levels: _int8_comparison_exp
  opens_at: timestamptz_comparison_exp
  resting_price: String_comparison_exp
  token_id: String_comparison_exp
}

"""
unique or primary key constraints on table "pricing_dutch_auction"
"""
enum pricing_dutch_auction_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_6c70e76261e8fb00a02d0628d12
}

"""
input type for incrementing numeric columns in table "pricing_dutch_auction"
"""
input pricing_dutch_auction_inc_input {
  decrement_duration: bigint
  final_price: bigint
}

"""
input type for inserting data into table "pricing_dutch_auction"
"""
input pricing_dutch_auction_insert_input {
  decrement_duration: bigint
  final_price: bigint
  generative_token: generative_token_obj_rel_insert_input
  id: String
  levels: _int8
  opens_at: timestamptz
  resting_price: String
  token_id: String
}

"""aggregate max on columns"""
type pricing_dutch_auction_max_fields {
  decrement_duration: bigint
  final_price: bigint
  id: String
  opens_at: timestamptz
  resting_price: String
  token_id: String
}

"""
order by max() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_max_order_by {
  decrement_duration: order_by
  final_price: order_by
  id: order_by
  opens_at: order_by
  resting_price: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type pricing_dutch_auction_min_fields {
  decrement_duration: bigint
  final_price: bigint
  id: String
  opens_at: timestamptz
  resting_price: String
  token_id: String
}

"""
order by min() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_min_order_by {
  decrement_duration: order_by
  final_price: order_by
  id: order_by
  opens_at: order_by
  resting_price: order_by
  token_id: order_by
}

"""
response of any mutation on the table "pricing_dutch_auction"
"""
type pricing_dutch_auction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pricing_dutch_auction!]!
}

"""
on_conflict condition type for table "pricing_dutch_auction"
"""
input pricing_dutch_auction_on_conflict {
  constraint: pricing_dutch_auction_constraint!
  update_columns: [pricing_dutch_auction_update_column!]! = []
  where: pricing_dutch_auction_bool_exp
}

"""Ordering options when selecting data from "pricing_dutch_auction"."""
input pricing_dutch_auction_order_by {
  decrement_duration: order_by
  final_price: order_by
  generative_token: generative_token_order_by
  id: order_by
  levels: order_by
  opens_at: order_by
  resting_price: order_by
  token_id: order_by
}

"""primary key columns input for table: pricing_dutch_auction"""
input pricing_dutch_auction_pk_columns_input {
  id: String!
}

"""
select columns of table "pricing_dutch_auction"
"""
enum pricing_dutch_auction_select_column {
  """column name"""
  decrement_duration

  """column name"""
  final_price

  """column name"""
  id

  """column name"""
  levels

  """column name"""
  opens_at

  """column name"""
  resting_price

  """column name"""
  token_id
}

"""
input type for updating data in table "pricing_dutch_auction"
"""
input pricing_dutch_auction_set_input {
  decrement_duration: bigint
  final_price: bigint
  id: String
  levels: _int8
  opens_at: timestamptz
  resting_price: String
  token_id: String
}

"""aggregate stddev on columns"""
type pricing_dutch_auction_stddev_fields {
  decrement_duration: Float
  final_price: Float
}

"""
order by stddev() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_stddev_order_by {
  decrement_duration: order_by
  final_price: order_by
}

"""aggregate stddev_pop on columns"""
type pricing_dutch_auction_stddev_pop_fields {
  decrement_duration: Float
  final_price: Float
}

"""
order by stddev_pop() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_stddev_pop_order_by {
  decrement_duration: order_by
  final_price: order_by
}

"""aggregate stddev_samp on columns"""
type pricing_dutch_auction_stddev_samp_fields {
  decrement_duration: Float
  final_price: Float
}

"""
order by stddev_samp() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_stddev_samp_order_by {
  decrement_duration: order_by
  final_price: order_by
}

"""
Streaming cursor of the table "pricing_dutch_auction"
"""
input pricing_dutch_auction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pricing_dutch_auction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pricing_dutch_auction_stream_cursor_value_input {
  decrement_duration: bigint
  final_price: bigint
  id: String
  levels: _int8
  opens_at: timestamptz
  resting_price: String
  token_id: String
}

"""aggregate sum on columns"""
type pricing_dutch_auction_sum_fields {
  decrement_duration: bigint
  final_price: bigint
}

"""
order by sum() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_sum_order_by {
  decrement_duration: order_by
  final_price: order_by
}

"""
update columns of table "pricing_dutch_auction"
"""
enum pricing_dutch_auction_update_column {
  """column name"""
  decrement_duration

  """column name"""
  final_price

  """column name"""
  id

  """column name"""
  levels

  """column name"""
  opens_at

  """column name"""
  resting_price

  """column name"""
  token_id
}

input pricing_dutch_auction_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: pricing_dutch_auction_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: pricing_dutch_auction_set_input

  """filter the rows which have to be updated"""
  where: pricing_dutch_auction_bool_exp!
}

"""aggregate var_pop on columns"""
type pricing_dutch_auction_var_pop_fields {
  decrement_duration: Float
  final_price: Float
}

"""
order by var_pop() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_var_pop_order_by {
  decrement_duration: order_by
  final_price: order_by
}

"""aggregate var_samp on columns"""
type pricing_dutch_auction_var_samp_fields {
  decrement_duration: Float
  final_price: Float
}

"""
order by var_samp() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_var_samp_order_by {
  decrement_duration: order_by
  final_price: order_by
}

"""aggregate variance on columns"""
type pricing_dutch_auction_variance_fields {
  decrement_duration: Float
  final_price: Float
}

"""
order by variance() on columns of table "pricing_dutch_auction"
"""
input pricing_dutch_auction_variance_order_by {
  decrement_duration: order_by
  final_price: order_by
}

"""
columns and relationships of "pricing_fixed"
"""
type pricing_fixed {
  """An object relationship"""
  generative_token: generative_token
  id: String!
  opens_at: timestamptz
  price: numeric!
  token_id: String
}

"""
aggregated selection of "pricing_fixed"
"""
type pricing_fixed_aggregate {
  aggregate: pricing_fixed_aggregate_fields
  nodes: [pricing_fixed!]!
}

input pricing_fixed_aggregate_bool_exp {
  count: pricing_fixed_aggregate_bool_exp_count
}

input pricing_fixed_aggregate_bool_exp_count {
  arguments: [pricing_fixed_select_column!]
  distinct: Boolean
  filter: pricing_fixed_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "pricing_fixed"
"""
type pricing_fixed_aggregate_fields {
  avg: pricing_fixed_avg_fields
  count(columns: [pricing_fixed_select_column!], distinct: Boolean): Int!
  max: pricing_fixed_max_fields
  min: pricing_fixed_min_fields
  stddev: pricing_fixed_stddev_fields
  stddev_pop: pricing_fixed_stddev_pop_fields
  stddev_samp: pricing_fixed_stddev_samp_fields
  sum: pricing_fixed_sum_fields
  var_pop: pricing_fixed_var_pop_fields
  var_samp: pricing_fixed_var_samp_fields
  variance: pricing_fixed_variance_fields
}

"""
order by aggregate values of table "pricing_fixed"
"""
input pricing_fixed_aggregate_order_by {
  avg: pricing_fixed_avg_order_by
  count: order_by
  max: pricing_fixed_max_order_by
  min: pricing_fixed_min_order_by
  stddev: pricing_fixed_stddev_order_by
  stddev_pop: pricing_fixed_stddev_pop_order_by
  stddev_samp: pricing_fixed_stddev_samp_order_by
  sum: pricing_fixed_sum_order_by
  var_pop: pricing_fixed_var_pop_order_by
  var_samp: pricing_fixed_var_samp_order_by
  variance: pricing_fixed_variance_order_by
}

"""
input type for inserting array relation for remote table "pricing_fixed"
"""
input pricing_fixed_arr_rel_insert_input {
  data: [pricing_fixed_insert_input!]!

  """upsert condition"""
  on_conflict: pricing_fixed_on_conflict
}

"""aggregate avg on columns"""
type pricing_fixed_avg_fields {
  price: Float
}

"""
order by avg() on columns of table "pricing_fixed"
"""
input pricing_fixed_avg_order_by {
  price: order_by
}

"""
Boolean expression to filter rows from the table "pricing_fixed". All fields are combined with a logical 'AND'.
"""
input pricing_fixed_bool_exp {
  _and: [pricing_fixed_bool_exp!]
  _not: pricing_fixed_bool_exp
  _or: [pricing_fixed_bool_exp!]
  generative_token: generative_token_bool_exp
  id: String_comparison_exp
  opens_at: timestamptz_comparison_exp
  price: numeric_comparison_exp
  token_id: String_comparison_exp
}

"""
unique or primary key constraints on table "pricing_fixed"
"""
enum pricing_fixed_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_ae46385ad088e6c1de1850c3d80
}

"""
input type for incrementing numeric columns in table "pricing_fixed"
"""
input pricing_fixed_inc_input {
  price: numeric
}

"""
input type for inserting data into table "pricing_fixed"
"""
input pricing_fixed_insert_input {
  generative_token: generative_token_obj_rel_insert_input
  id: String
  opens_at: timestamptz
  price: numeric
  token_id: String
}

"""aggregate max on columns"""
type pricing_fixed_max_fields {
  id: String
  opens_at: timestamptz
  price: numeric
  token_id: String
}

"""
order by max() on columns of table "pricing_fixed"
"""
input pricing_fixed_max_order_by {
  id: order_by
  opens_at: order_by
  price: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type pricing_fixed_min_fields {
  id: String
  opens_at: timestamptz
  price: numeric
  token_id: String
}

"""
order by min() on columns of table "pricing_fixed"
"""
input pricing_fixed_min_order_by {
  id: order_by
  opens_at: order_by
  price: order_by
  token_id: order_by
}

"""
response of any mutation on the table "pricing_fixed"
"""
type pricing_fixed_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [pricing_fixed!]!
}

"""
on_conflict condition type for table "pricing_fixed"
"""
input pricing_fixed_on_conflict {
  constraint: pricing_fixed_constraint!
  update_columns: [pricing_fixed_update_column!]! = []
  where: pricing_fixed_bool_exp
}

"""Ordering options when selecting data from "pricing_fixed"."""
input pricing_fixed_order_by {
  generative_token: generative_token_order_by
  id: order_by
  opens_at: order_by
  price: order_by
  token_id: order_by
}

"""primary key columns input for table: pricing_fixed"""
input pricing_fixed_pk_columns_input {
  id: String!
}

"""
select columns of table "pricing_fixed"
"""
enum pricing_fixed_select_column {
  """column name"""
  id

  """column name"""
  opens_at

  """column name"""
  price

  """column name"""
  token_id
}

"""
input type for updating data in table "pricing_fixed"
"""
input pricing_fixed_set_input {
  id: String
  opens_at: timestamptz
  price: numeric
  token_id: String
}

"""aggregate stddev on columns"""
type pricing_fixed_stddev_fields {
  price: Float
}

"""
order by stddev() on columns of table "pricing_fixed"
"""
input pricing_fixed_stddev_order_by {
  price: order_by
}

"""aggregate stddev_pop on columns"""
type pricing_fixed_stddev_pop_fields {
  price: Float
}

"""
order by stddev_pop() on columns of table "pricing_fixed"
"""
input pricing_fixed_stddev_pop_order_by {
  price: order_by
}

"""aggregate stddev_samp on columns"""
type pricing_fixed_stddev_samp_fields {
  price: Float
}

"""
order by stddev_samp() on columns of table "pricing_fixed"
"""
input pricing_fixed_stddev_samp_order_by {
  price: order_by
}

"""
Streaming cursor of the table "pricing_fixed"
"""
input pricing_fixed_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: pricing_fixed_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input pricing_fixed_stream_cursor_value_input {
  id: String
  opens_at: timestamptz
  price: numeric
  token_id: String
}

"""aggregate sum on columns"""
type pricing_fixed_sum_fields {
  price: numeric
}

"""
order by sum() on columns of table "pricing_fixed"
"""
input pricing_fixed_sum_order_by {
  price: order_by
}

"""
update columns of table "pricing_fixed"
"""
enum pricing_fixed_update_column {
  """column name"""
  id

  """column name"""
  opens_at

  """column name"""
  price

  """column name"""
  token_id
}

input pricing_fixed_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: pricing_fixed_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: pricing_fixed_set_input

  """filter the rows which have to be updated"""
  where: pricing_fixed_bool_exp!
}

"""aggregate var_pop on columns"""
type pricing_fixed_var_pop_fields {
  price: Float
}

"""
order by var_pop() on columns of table "pricing_fixed"
"""
input pricing_fixed_var_pop_order_by {
  price: order_by
}

"""aggregate var_samp on columns"""
type pricing_fixed_var_samp_fields {
  price: Float
}

"""
order by var_samp() on columns of table "pricing_fixed"
"""
input pricing_fixed_var_samp_order_by {
  price: order_by
}

"""aggregate variance on columns"""
type pricing_fixed_variance_fields {
  price: Float
}

"""
order by variance() on columns of table "pricing_fixed"
"""
input pricing_fixed_variance_order_by {
  price: order_by
}

type query_root {
  """
  fetch data from the table: "Account"
  """
  Account(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch aggregated fields from the table: "Account"
  """
  Account_aggregate(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): Account_aggregate!

  """fetch data from the table: "Account" using primary key columns"""
  Account_by_pk(id: uuid!): Account

  """
  fetch data from the table: "Profile"
  """
  Profile(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """
  fetch aggregated fields from the table: "Profile"
  """
  Profile_aggregate(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): Profile_aggregate!

  """fetch data from the table: "Profile" using primary key columns"""
  Profile_by_pk(accountId: uuid!): Profile

  """
  fetch data from the table: "Wallet"
  """
  Wallet(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  fetch aggregated fields from the table: "Wallet"
  """
  Wallet_aggregate(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): Wallet_aggregate!

  """fetch data from the table: "Wallet" using primary key columns"""
  Wallet_by_pk(address: String!): Wallet

  """
  fetch data from the table: "Whitelist"
  """
  Whitelist(
    """distinct select on columns"""
    distinct_on: [Whitelist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Whitelist_order_by!]

    """filter the rows returned"""
    where: Whitelist_bool_exp
  ): [Whitelist!]!

  """
  fetch data from the table: "WhitelistEntries"
  """
  WhitelistEntries(
    """distinct select on columns"""
    distinct_on: [WhitelistEntries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WhitelistEntries_order_by!]

    """filter the rows returned"""
    where: WhitelistEntries_bool_exp
  ): [WhitelistEntries!]!

  """
  fetch aggregated fields from the table: "WhitelistEntries"
  """
  WhitelistEntries_aggregate(
    """distinct select on columns"""
    distinct_on: [WhitelistEntries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WhitelistEntries_order_by!]

    """filter the rows returned"""
    where: WhitelistEntries_bool_exp
  ): WhitelistEntries_aggregate!

  """
  fetch data from the table: "WhitelistEntries" using primary key columns
  """
  WhitelistEntries_by_pk(merkleRoot: String!, whitelistIndex: Int!): WhitelistEntries

  """
  fetch aggregated fields from the table: "Whitelist"
  """
  Whitelist_aggregate(
    """distinct select on columns"""
    distinct_on: [Whitelist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Whitelist_order_by!]

    """filter the rows returned"""
    where: Whitelist_bool_exp
  ): Whitelist_aggregate!

  """fetch data from the table: "Whitelist" using primary key columns"""
  Whitelist_by_pk(merkleRoot: String!): Whitelist

  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch aggregated fields from the table: "action"
  """
  action_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """fetch data from the table: "action" using primary key columns"""
  action_by_pk(id: uuid!): action

  """
  fetch data from the table: "article"
  """
  article(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): [article!]!

  """
  fetch aggregated fields from the table: "article"
  """
  article_aggregate(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): article_aggregate!

  """fetch data from the table: "article" using primary key columns"""
  article_by_pk(id: Int!): article

  """
  fetch data from the table: "article_generative_token"
  """
  article_generative_token(
    """distinct select on columns"""
    distinct_on: [article_generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_generative_token_order_by!]

    """filter the rows returned"""
    where: article_generative_token_bool_exp
  ): [article_generative_token!]!

  """
  fetch aggregated fields from the table: "article_generative_token"
  """
  article_generative_token_aggregate(
    """distinct select on columns"""
    distinct_on: [article_generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_generative_token_order_by!]

    """filter the rows returned"""
    where: article_generative_token_bool_exp
  ): article_generative_token_aggregate!

  """
  fetch data from the table: "article_generative_token" using primary key columns
  """
  article_generative_token_by_pk(article_id: Int!, generative_token_id: String!): article_generative_token

  """
  fetch data from the table: "article_ledger"
  """
  article_ledger(
    """distinct select on columns"""
    distinct_on: [article_ledger_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_ledger_order_by!]

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): [article_ledger!]!

  """
  fetch aggregated fields from the table: "article_ledger"
  """
  article_ledger_aggregate(
    """distinct select on columns"""
    distinct_on: [article_ledger_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_ledger_order_by!]

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): article_ledger_aggregate!

  """fetch data from the table: "article_ledger" using primary key columns"""
  article_ledger_by_pk(article_id: Int!, owner_id: String!): article_ledger

  """
  fetch data from the table: "article_revision"
  """
  article_revision(
    """distinct select on columns"""
    distinct_on: [article_revision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_revision_order_by!]

    """filter the rows returned"""
    where: article_revision_bool_exp
  ): [article_revision!]!

  """
  fetch aggregated fields from the table: "article_revision"
  """
  article_revision_aggregate(
    """distinct select on columns"""
    distinct_on: [article_revision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_revision_order_by!]

    """filter the rows returned"""
    where: article_revision_bool_exp
  ): article_revision_aggregate!

  """
  fetch data from the table: "article_revision" using primary key columns
  """
  article_revision_by_pk(article_id: Int!, iteration: smallint!): article_revision

  """
  fetch data from the table: "auction"
  """
  auction(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): [auction!]!

  """
  fetch aggregated fields from the table: "auction"
  """
  auction_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): auction_aggregate!

  """
  fetch data from the table: "auction_bid"
  """
  auction_bid(
    """distinct select on columns"""
    distinct_on: [auction_bid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_order_by!]

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): [auction_bid!]!

  """
  fetch aggregated fields from the table: "auction_bid"
  """
  auction_bid_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_bid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_order_by!]

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): auction_bid_aggregate!

  """fetch data from the table: "auction_bid" using primary key columns"""
  auction_bid_by_pk(id: uuid!): auction_bid

  """
  fetch data from the table: "auction_bid_table"
  """
  auction_bid_table(
    """distinct select on columns"""
    distinct_on: [auction_bid_table_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_table_order_by!]

    """filter the rows returned"""
    where: auction_bid_table_bool_exp
  ): [auction_bid_table!]!

  """
  fetch aggregated fields from the table: "auction_bid_table"
  """
  auction_bid_table_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_bid_table_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_table_order_by!]

    """filter the rows returned"""
    where: auction_bid_table_bool_exp
  ): auction_bid_table_aggregate!

  """
  fetch data from the table: "auction_bid_table" using primary key columns
  """
  auction_bid_table_by_pk(id: Int!): auction_bid_table

  """fetch data from the table: "auction" using primary key columns"""
  auction_by_pk(id: Int!, version: Int!): auction

  """
  fetch data from the table: "codex"
  """
  codex(
    """distinct select on columns"""
    distinct_on: [codex_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_order_by!]

    """filter the rows returned"""
    where: codex_bool_exp
  ): [codex!]!

  """
  fetch aggregated fields from the table: "codex"
  """
  codex_aggregate(
    """distinct select on columns"""
    distinct_on: [codex_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_order_by!]

    """filter the rows returned"""
    where: codex_bool_exp
  ): codex_aggregate!

  """fetch data from the table: "codex" using primary key columns"""
  codex_by_pk(id: String!, token_version: generative_token_version!): codex

  """
  fetch data from the table: "codex_update_request"
  """
  codex_update_request(
    """distinct select on columns"""
    distinct_on: [codex_update_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_update_request_order_by!]

    """filter the rows returned"""
    where: codex_update_request_bool_exp
  ): [codex_update_request!]!

  """
  fetch aggregated fields from the table: "codex_update_request"
  """
  codex_update_request_aggregate(
    """distinct select on columns"""
    distinct_on: [codex_update_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_update_request_order_by!]

    """filter the rows returned"""
    where: codex_update_request_bool_exp
  ): codex_update_request_aggregate!

  """
  fetch data from the table: "codex_update_request" using primary key columns
  """
  codex_update_request_by_pk(codex_id: String!, token_id: String!, token_version: generative_token_version!): codex_update_request

  """
  fetch data from the table: "collaboration"
  """
  collaboration(
    """distinct select on columns"""
    distinct_on: [collaboration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collaboration_order_by!]

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): [collaboration!]!

  """
  fetch aggregated fields from the table: "collaboration"
  """
  collaboration_aggregate(
    """distinct select on columns"""
    distinct_on: [collaboration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collaboration_order_by!]

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): collaboration_aggregate!

  """fetch data from the table: "collaboration" using primary key columns"""
  collaboration_by_pk(collaboration_contract_id: String!, collaborator_id: String!): collaboration

  """
  fetch data from the table: "collection_offer"
  """
  collection_offer(
    """distinct select on columns"""
    distinct_on: [collection_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_offer_order_by!]

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): [collection_offer!]!

  """
  fetch aggregated fields from the table: "collection_offer"
  """
  collection_offer_aggregate(
    """distinct select on columns"""
    distinct_on: [collection_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_offer_order_by!]

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): collection_offer_aggregate!

  """
  fetch data from the table: "collection_offer" using primary key columns
  """
  collection_offer_by_pk(id: String!, version: Int!): collection_offer

  """
  fetch data from the table: "generative_token"
  """
  generative_token(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): [generative_token!]!

  """
  fetch aggregated fields from the table: "generative_token"
  """
  generative_token_aggregate(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): generative_token_aggregate!

  """
  fetch data from the table: "generative_token" using primary key columns
  """
  generative_token_by_pk(id: String!): generative_token

  """
  fetch data from the table: "gentk_assign"
  """
  gentk_assign(
    """distinct select on columns"""
    distinct_on: [gentk_assign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gentk_assign_order_by!]

    """filter the rows returned"""
    where: gentk_assign_bool_exp
  ): [gentk_assign!]!

  """
  fetch aggregated fields from the table: "gentk_assign"
  """
  gentk_assign_aggregate(
    """distinct select on columns"""
    distinct_on: [gentk_assign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gentk_assign_order_by!]

    """filter the rows returned"""
    where: gentk_assign_bool_exp
  ): gentk_assign_aggregate!

  """fetch data from the table: "gentk_assign" using primary key columns"""
  gentk_assign_by_pk(gentk_id: String!, gentk_issuer_version: generative_token_version!): gentk_assign

  """
  fetch data from the table: "ipfs_cid"
  """
  ipfs_cid(
    """distinct select on columns"""
    distinct_on: [ipfs_cid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ipfs_cid_order_by!]

    """filter the rows returned"""
    where: ipfs_cid_bool_exp
  ): [ipfs_cid!]!

  """
  fetch aggregated fields from the table: "ipfs_cid"
  """
  ipfs_cid_aggregate(
    """distinct select on columns"""
    distinct_on: [ipfs_cid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ipfs_cid_order_by!]

    """filter the rows returned"""
    where: ipfs_cid_bool_exp
  ): ipfs_cid_aggregate!

  """fetch data from the table: "ipfs_cid" using primary key columns"""
  ipfs_cid_by_pk(cid: String!): ipfs_cid

  """
  fetch data from the table: "listing"
  """
  listing(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): [listing!]!

  """
  fetch aggregated fields from the table: "listing"
  """
  listing_aggregate(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): listing_aggregate!

  """fetch data from the table: "listing" using primary key columns"""
  listing_by_pk(id: String!, version: Int!): listing

  """
  fetch data from the table: "market_stats"
  """
  market_stats(
    """distinct select on columns"""
    distinct_on: [market_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_order_by!]

    """filter the rows returned"""
    where: market_stats_bool_exp
  ): [market_stats!]!

  """
  fetch aggregated fields from the table: "market_stats"
  """
  market_stats_aggregate(
    """distinct select on columns"""
    distinct_on: [market_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_order_by!]

    """filter the rows returned"""
    where: market_stats_bool_exp
  ): market_stats_aggregate!

  """fetch data from the table: "market_stats" using primary key columns"""
  market_stats_by_pk(token_id: String!): market_stats

  """
  fetch data from the table: "market_stats_history"
  """
  market_stats_history(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): [market_stats_history!]!

  """
  fetch aggregated fields from the table: "market_stats_history"
  """
  market_stats_history_aggregate(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): market_stats_history_aggregate!

  """
  fetch data from the table: "market_stats_history" using primary key columns
  """
  market_stats_history_by_pk(id: Int!): market_stats_history

  """
  fetch data from the table: "media_image"
  """
  media_image(
    """distinct select on columns"""
    distinct_on: [media_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_image_order_by!]

    """filter the rows returned"""
    where: media_image_bool_exp
  ): [media_image!]!

  """
  fetch aggregated fields from the table: "media_image"
  """
  media_image_aggregate(
    """distinct select on columns"""
    distinct_on: [media_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_image_order_by!]

    """filter the rows returned"""
    where: media_image_bool_exp
  ): media_image_aggregate!

  """fetch data from the table: "media_image" using primary key columns"""
  media_image_by_pk(cid: bpchar!): media_image

  """
  fetch data from the table: "mint_ticket"
  """
  mint_ticket(
    """distinct select on columns"""
    distinct_on: [mint_ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_order_by!]

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): [mint_ticket!]!

  """
  fetch aggregated fields from the table: "mint_ticket"
  """
  mint_ticket_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_order_by!]

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): mint_ticket_aggregate!

  """fetch data from the table: "mint_ticket" using primary key columns"""
  mint_ticket_by_pk(id: String!): mint_ticket

  """An array relationship"""
  mint_ticket_settings(
    """distinct select on columns"""
    distinct_on: [mint_ticket_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_settings_order_by!]

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): [mint_ticket_settings!]!

  """An aggregate relationship"""
  mint_ticket_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_ticket_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_settings_order_by!]

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): mint_ticket_settings_aggregate!

  """
  fetch data from the table: "mint_ticket_settings" using primary key columns
  """
  mint_ticket_settings_by_pk(id: String!): mint_ticket_settings

  """
  fetch data from the table: "moderation_reason"
  """
  moderation_reason(
    """distinct select on columns"""
    distinct_on: [moderation_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [moderation_reason_order_by!]

    """filter the rows returned"""
    where: moderation_reason_bool_exp
  ): [moderation_reason!]!

  """
  fetch aggregated fields from the table: "moderation_reason"
  """
  moderation_reason_aggregate(
    """distinct select on columns"""
    distinct_on: [moderation_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [moderation_reason_order_by!]

    """filter the rows returned"""
    where: moderation_reason_bool_exp
  ): moderation_reason_aggregate!

  """
  fetch data from the table: "moderation_reason" using primary key columns
  """
  moderation_reason_by_pk(id: String!): moderation_reason

  """
  fetch data from the table: "objkt"
  """
  objkt(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): [objkt!]!

  """
  fetch aggregated fields from the table: "objkt"
  """
  objkt_aggregate(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): objkt_aggregate!

  """fetch data from the table: "objkt" using primary key columns"""
  objkt_by_pk(id: String!, issuer_version: generative_token_version!): objkt

  """
  fetch data from the table: "offer"
  """
  offer(
    """distinct select on columns"""
    distinct_on: [offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_order_by!]

    """filter the rows returned"""
    where: offer_bool_exp
  ): [offer!]!

  """
  fetch aggregated fields from the table: "offer"
  """
  offer_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_order_by!]

    """filter the rows returned"""
    where: offer_bool_exp
  ): offer_aggregate!

  """fetch data from the table: "offer" using primary key columns"""
  offer_by_pk(id: String!, version: Int!): offer

  """
  fetch data from the table: "pricing_dutch_auction"
  """
  pricing_dutch_auction(
    """distinct select on columns"""
    distinct_on: [pricing_dutch_auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_dutch_auction_order_by!]

    """filter the rows returned"""
    where: pricing_dutch_auction_bool_exp
  ): [pricing_dutch_auction!]!

  """
  fetch aggregated fields from the table: "pricing_dutch_auction"
  """
  pricing_dutch_auction_aggregate(
    """distinct select on columns"""
    distinct_on: [pricing_dutch_auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_dutch_auction_order_by!]

    """filter the rows returned"""
    where: pricing_dutch_auction_bool_exp
  ): pricing_dutch_auction_aggregate!

  """
  fetch data from the table: "pricing_dutch_auction" using primary key columns
  """
  pricing_dutch_auction_by_pk(id: String!): pricing_dutch_auction

  """
  fetch data from the table: "pricing_fixed"
  """
  pricing_fixed(
    """distinct select on columns"""
    distinct_on: [pricing_fixed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_fixed_order_by!]

    """filter the rows returned"""
    where: pricing_fixed_bool_exp
  ): [pricing_fixed!]!

  """
  fetch aggregated fields from the table: "pricing_fixed"
  """
  pricing_fixed_aggregate(
    """distinct select on columns"""
    distinct_on: [pricing_fixed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_fixed_order_by!]

    """filter the rows returned"""
    where: pricing_fixed_bool_exp
  ): pricing_fixed_aggregate!

  """fetch data from the table: "pricing_fixed" using primary key columns"""
  pricing_fixed_by_pk(id: String!): pricing_fixed

  """
  fetch data from the table: "redeemable"
  """
  redeemable(
    """distinct select on columns"""
    distinct_on: [redeemable_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redeemable_order_by!]

    """filter the rows returned"""
    where: redeemable_bool_exp
  ): [redeemable!]!

  """
  fetch aggregated fields from the table: "redeemable"
  """
  redeemable_aggregate(
    """distinct select on columns"""
    distinct_on: [redeemable_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redeemable_order_by!]

    """filter the rows returned"""
    where: redeemable_bool_exp
  ): redeemable_aggregate!

  """fetch data from the table: "redeemable" using primary key columns"""
  redeemable_by_pk(address: String!): redeemable

  """
  fetch data from the table: "redemption"
  """
  redemption(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): [redemption!]!

  """
  fetch aggregated fields from the table: "redemption"
  """
  redemption_aggregate(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): redemption_aggregate!

  """fetch data from the table: "redemption" using primary key columns"""
  redemption_by_pk(id: Int!): redemption

  """
  fetch data from the table: "report"
  """
  report(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!

  """
  fetch aggregated fields from the table: "report"
  """
  report_aggregate(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): report_aggregate!

  """fetch data from the table: "report" using primary key columns"""
  report_by_pk(id: uuid!): report

  """
  fetch data from the table: "reserve"
  """
  reserve(
    """distinct select on columns"""
    distinct_on: [reserve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reserve_order_by!]

    """filter the rows returned"""
    where: reserve_bool_exp
  ): [reserve!]!

  """
  fetch aggregated fields from the table: "reserve"
  """
  reserve_aggregate(
    """distinct select on columns"""
    distinct_on: [reserve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reserve_order_by!]

    """filter the rows returned"""
    where: reserve_bool_exp
  ): reserve_aggregate!

  """fetch data from the table: "reserve" using primary key columns"""
  reserve_by_pk(id: Int!): reserve

  """
  fetch data from the table: "split"
  """
  split(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """
  fetch aggregated fields from the table: "split"
  """
  split_aggregate(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): split_aggregate!

  """fetch data from the table: "split" using primary key columns"""
  split_by_pk(id: Int!): split

  """
  fetch data from the table: "transaction"
  """
  transaction(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch aggregated fields from the table: "transaction"
  """
  transaction_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """fetch data from the table: "transaction" using primary key columns"""
  transaction_by_pk(id: Int!): transaction

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user

  """
  fetch data from the table: "user_stats"
  """
  user_stats(
    """distinct select on columns"""
    distinct_on: [user_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_stats_order_by!]

    """filter the rows returned"""
    where: user_stats_bool_exp
  ): [user_stats!]!

  """
  fetch aggregated fields from the table: "user_stats"
  """
  user_stats_aggregate(
    """distinct select on columns"""
    distinct_on: [user_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_stats_order_by!]

    """filter the rows returned"""
    where: user_stats_bool_exp
  ): user_stats_aggregate!

  """fetch data from the table: "user_stats" using primary key columns"""
  user_stats_by_pk(user_id: String!): user_stats
}

"""
columns and relationships of "redeemable"
"""
type redeemable {
  """An array relationship"""
  actions(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """An aggregate relationship"""
  actions_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!
  address: String!
  base_amount: numeric!
  created_at: timestamptz!
  fa2: String!

  """An object relationship"""
  generative_token: generative_token!
  max_consumptions_per_token: Int!

  """An array relationship"""
  redemptions(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): [redemption!]!

  """An aggregate relationship"""
  redemptions_aggregate(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): redemption_aggregate!

  """An array relationship"""
  splits(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """An aggregate relationship"""
  splits_aggregate(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): split_aggregate!
  token_id: String!
}

"""
aggregated selection of "redeemable"
"""
type redeemable_aggregate {
  aggregate: redeemable_aggregate_fields
  nodes: [redeemable!]!
}

input redeemable_aggregate_bool_exp {
  count: redeemable_aggregate_bool_exp_count
}

input redeemable_aggregate_bool_exp_count {
  arguments: [redeemable_select_column!]
  distinct: Boolean
  filter: redeemable_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "redeemable"
"""
type redeemable_aggregate_fields {
  avg: redeemable_avg_fields
  count(columns: [redeemable_select_column!], distinct: Boolean): Int!
  max: redeemable_max_fields
  min: redeemable_min_fields
  stddev: redeemable_stddev_fields
  stddev_pop: redeemable_stddev_pop_fields
  stddev_samp: redeemable_stddev_samp_fields
  sum: redeemable_sum_fields
  var_pop: redeemable_var_pop_fields
  var_samp: redeemable_var_samp_fields
  variance: redeemable_variance_fields
}

"""
order by aggregate values of table "redeemable"
"""
input redeemable_aggregate_order_by {
  avg: redeemable_avg_order_by
  count: order_by
  max: redeemable_max_order_by
  min: redeemable_min_order_by
  stddev: redeemable_stddev_order_by
  stddev_pop: redeemable_stddev_pop_order_by
  stddev_samp: redeemable_stddev_samp_order_by
  sum: redeemable_sum_order_by
  var_pop: redeemable_var_pop_order_by
  var_samp: redeemable_var_samp_order_by
  variance: redeemable_variance_order_by
}

"""
input type for inserting array relation for remote table "redeemable"
"""
input redeemable_arr_rel_insert_input {
  data: [redeemable_insert_input!]!

  """upsert condition"""
  on_conflict: redeemable_on_conflict
}

"""aggregate avg on columns"""
type redeemable_avg_fields {
  base_amount: Float
  max_consumptions_per_token: Float
}

"""
order by avg() on columns of table "redeemable"
"""
input redeemable_avg_order_by {
  base_amount: order_by
  max_consumptions_per_token: order_by
}

"""
Boolean expression to filter rows from the table "redeemable". All fields are combined with a logical 'AND'.
"""
input redeemable_bool_exp {
  _and: [redeemable_bool_exp!]
  _not: redeemable_bool_exp
  _or: [redeemable_bool_exp!]
  actions: action_bool_exp
  actions_aggregate: action_aggregate_bool_exp
  address: String_comparison_exp
  base_amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  fa2: String_comparison_exp
  generative_token: generative_token_bool_exp
  max_consumptions_per_token: Int_comparison_exp
  redemptions: redemption_bool_exp
  redemptions_aggregate: redemption_aggregate_bool_exp
  splits: split_bool_exp
  splits_aggregate: split_aggregate_bool_exp
  token_id: String_comparison_exp
}

"""
unique or primary key constraints on table "redeemable"
"""
enum redeemable_constraint {
  """
  unique or primary key constraint on columns "address"
  """
  PK_9cdc4a659b978ba30e26444f6ff
}

"""
input type for incrementing numeric columns in table "redeemable"
"""
input redeemable_inc_input {
  base_amount: numeric
  max_consumptions_per_token: Int
}

"""
input type for inserting data into table "redeemable"
"""
input redeemable_insert_input {
  actions: action_arr_rel_insert_input
  address: String
  base_amount: numeric
  created_at: timestamptz
  fa2: String
  generative_token: generative_token_obj_rel_insert_input
  max_consumptions_per_token: Int
  redemptions: redemption_arr_rel_insert_input
  splits: split_arr_rel_insert_input
  token_id: String
}

"""aggregate max on columns"""
type redeemable_max_fields {
  address: String
  base_amount: numeric
  created_at: timestamptz
  fa2: String
  max_consumptions_per_token: Int
  token_id: String
}

"""
order by max() on columns of table "redeemable"
"""
input redeemable_max_order_by {
  address: order_by
  base_amount: order_by
  created_at: order_by
  fa2: order_by
  max_consumptions_per_token: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type redeemable_min_fields {
  address: String
  base_amount: numeric
  created_at: timestamptz
  fa2: String
  max_consumptions_per_token: Int
  token_id: String
}

"""
order by min() on columns of table "redeemable"
"""
input redeemable_min_order_by {
  address: order_by
  base_amount: order_by
  created_at: order_by
  fa2: order_by
  max_consumptions_per_token: order_by
  token_id: order_by
}

"""
response of any mutation on the table "redeemable"
"""
type redeemable_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [redeemable!]!
}

"""
input type for inserting object relation for remote table "redeemable"
"""
input redeemable_obj_rel_insert_input {
  data: redeemable_insert_input!

  """upsert condition"""
  on_conflict: redeemable_on_conflict
}

"""
on_conflict condition type for table "redeemable"
"""
input redeemable_on_conflict {
  constraint: redeemable_constraint!
  update_columns: [redeemable_update_column!]! = []
  where: redeemable_bool_exp
}

"""Ordering options when selecting data from "redeemable"."""
input redeemable_order_by {
  actions_aggregate: action_aggregate_order_by
  address: order_by
  base_amount: order_by
  created_at: order_by
  fa2: order_by
  generative_token: generative_token_order_by
  max_consumptions_per_token: order_by
  redemptions_aggregate: redemption_aggregate_order_by
  splits_aggregate: split_aggregate_order_by
  token_id: order_by
}

"""primary key columns input for table: redeemable"""
input redeemable_pk_columns_input {
  address: String!
}

"""
select columns of table "redeemable"
"""
enum redeemable_select_column {
  """column name"""
  address

  """column name"""
  base_amount

  """column name"""
  created_at

  """column name"""
  fa2

  """column name"""
  max_consumptions_per_token

  """column name"""
  token_id
}

"""
input type for updating data in table "redeemable"
"""
input redeemable_set_input {
  address: String
  base_amount: numeric
  created_at: timestamptz
  fa2: String
  max_consumptions_per_token: Int
  token_id: String
}

"""aggregate stddev on columns"""
type redeemable_stddev_fields {
  base_amount: Float
  max_consumptions_per_token: Float
}

"""
order by stddev() on columns of table "redeemable"
"""
input redeemable_stddev_order_by {
  base_amount: order_by
  max_consumptions_per_token: order_by
}

"""aggregate stddev_pop on columns"""
type redeemable_stddev_pop_fields {
  base_amount: Float
  max_consumptions_per_token: Float
}

"""
order by stddev_pop() on columns of table "redeemable"
"""
input redeemable_stddev_pop_order_by {
  base_amount: order_by
  max_consumptions_per_token: order_by
}

"""aggregate stddev_samp on columns"""
type redeemable_stddev_samp_fields {
  base_amount: Float
  max_consumptions_per_token: Float
}

"""
order by stddev_samp() on columns of table "redeemable"
"""
input redeemable_stddev_samp_order_by {
  base_amount: order_by
  max_consumptions_per_token: order_by
}

"""
Streaming cursor of the table "redeemable"
"""
input redeemable_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: redeemable_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input redeemable_stream_cursor_value_input {
  address: String
  base_amount: numeric
  created_at: timestamptz
  fa2: String
  max_consumptions_per_token: Int
  token_id: String
}

"""aggregate sum on columns"""
type redeemable_sum_fields {
  base_amount: numeric
  max_consumptions_per_token: Int
}

"""
order by sum() on columns of table "redeemable"
"""
input redeemable_sum_order_by {
  base_amount: order_by
  max_consumptions_per_token: order_by
}

"""
update columns of table "redeemable"
"""
enum redeemable_update_column {
  """column name"""
  address

  """column name"""
  base_amount

  """column name"""
  created_at

  """column name"""
  fa2

  """column name"""
  max_consumptions_per_token

  """column name"""
  token_id
}

input redeemable_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: redeemable_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: redeemable_set_input

  """filter the rows which have to be updated"""
  where: redeemable_bool_exp!
}

"""aggregate var_pop on columns"""
type redeemable_var_pop_fields {
  base_amount: Float
  max_consumptions_per_token: Float
}

"""
order by var_pop() on columns of table "redeemable"
"""
input redeemable_var_pop_order_by {
  base_amount: order_by
  max_consumptions_per_token: order_by
}

"""aggregate var_samp on columns"""
type redeemable_var_samp_fields {
  base_amount: Float
  max_consumptions_per_token: Float
}

"""
order by var_samp() on columns of table "redeemable"
"""
input redeemable_var_samp_order_by {
  base_amount: order_by
  max_consumptions_per_token: order_by
}

"""aggregate variance on columns"""
type redeemable_variance_fields {
  base_amount: Float
  max_consumptions_per_token: Float
}

"""
order by variance() on columns of table "redeemable"
"""
input redeemable_variance_order_by {
  base_amount: order_by
  max_consumptions_per_token: order_by
}

"""
columns and relationships of "redemption"
"""
type redemption {
  amount: numeric!
  created_at: timestamptz!
  id: Int!

  """An object relationship"""
  objkt: objkt
  objkt_id: String
  objkt_issuer_version: generative_token_version

  """An object relationship"""
  redeemable: redeemable
  redeemable_address: String
  redeemer_id: String

  """An object relationship"""
  user: user
}

"""
aggregated selection of "redemption"
"""
type redemption_aggregate {
  aggregate: redemption_aggregate_fields
  nodes: [redemption!]!
}

input redemption_aggregate_bool_exp {
  count: redemption_aggregate_bool_exp_count
}

input redemption_aggregate_bool_exp_count {
  arguments: [redemption_select_column!]
  distinct: Boolean
  filter: redemption_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "redemption"
"""
type redemption_aggregate_fields {
  avg: redemption_avg_fields
  count(columns: [redemption_select_column!], distinct: Boolean): Int!
  max: redemption_max_fields
  min: redemption_min_fields
  stddev: redemption_stddev_fields
  stddev_pop: redemption_stddev_pop_fields
  stddev_samp: redemption_stddev_samp_fields
  sum: redemption_sum_fields
  var_pop: redemption_var_pop_fields
  var_samp: redemption_var_samp_fields
  variance: redemption_variance_fields
}

"""
order by aggregate values of table "redemption"
"""
input redemption_aggregate_order_by {
  avg: redemption_avg_order_by
  count: order_by
  max: redemption_max_order_by
  min: redemption_min_order_by
  stddev: redemption_stddev_order_by
  stddev_pop: redemption_stddev_pop_order_by
  stddev_samp: redemption_stddev_samp_order_by
  sum: redemption_sum_order_by
  var_pop: redemption_var_pop_order_by
  var_samp: redemption_var_samp_order_by
  variance: redemption_variance_order_by
}

"""
input type for inserting array relation for remote table "redemption"
"""
input redemption_arr_rel_insert_input {
  data: [redemption_insert_input!]!

  """upsert condition"""
  on_conflict: redemption_on_conflict
}

"""aggregate avg on columns"""
type redemption_avg_fields {
  amount: Float
  id: Float
}

"""
order by avg() on columns of table "redemption"
"""
input redemption_avg_order_by {
  amount: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "redemption". All fields are combined with a logical 'AND'.
"""
input redemption_bool_exp {
  _and: [redemption_bool_exp!]
  _not: redemption_bool_exp
  _or: [redemption_bool_exp!]
  amount: numeric_comparison_exp
  created_at: timestamptz_comparison_exp
  id: Int_comparison_exp
  objkt: objkt_bool_exp
  objkt_id: String_comparison_exp
  objkt_issuer_version: generative_token_version_comparison_exp
  redeemable: redeemable_bool_exp
  redeemable_address: String_comparison_exp
  redeemer_id: String_comparison_exp
  user: user_bool_exp
}

"""
unique or primary key constraints on table "redemption"
"""
enum redemption_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_e96b16cd3061a61305951bc95a3
}

"""
input type for incrementing numeric columns in table "redemption"
"""
input redemption_inc_input {
  amount: numeric
  id: Int
}

"""
input type for inserting data into table "redemption"
"""
input redemption_insert_input {
  amount: numeric
  created_at: timestamptz
  id: Int
  objkt: objkt_obj_rel_insert_input
  objkt_id: String
  objkt_issuer_version: generative_token_version
  redeemable: redeemable_obj_rel_insert_input
  redeemable_address: String
  redeemer_id: String
  user: user_obj_rel_insert_input
}

"""aggregate max on columns"""
type redemption_max_fields {
  amount: numeric
  created_at: timestamptz
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  redeemable_address: String
  redeemer_id: String
}

"""
order by max() on columns of table "redemption"
"""
input redemption_max_order_by {
  amount: order_by
  created_at: order_by
  id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  redeemable_address: order_by
  redeemer_id: order_by
}

"""aggregate min on columns"""
type redemption_min_fields {
  amount: numeric
  created_at: timestamptz
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  redeemable_address: String
  redeemer_id: String
}

"""
order by min() on columns of table "redemption"
"""
input redemption_min_order_by {
  amount: order_by
  created_at: order_by
  id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  redeemable_address: order_by
  redeemer_id: order_by
}

"""
response of any mutation on the table "redemption"
"""
type redemption_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [redemption!]!
}

"""
on_conflict condition type for table "redemption"
"""
input redemption_on_conflict {
  constraint: redemption_constraint!
  update_columns: [redemption_update_column!]! = []
  where: redemption_bool_exp
}

"""Ordering options when selecting data from "redemption"."""
input redemption_order_by {
  amount: order_by
  created_at: order_by
  id: order_by
  objkt: objkt_order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  redeemable: redeemable_order_by
  redeemable_address: order_by
  redeemer_id: order_by
  user: user_order_by
}

"""primary key columns input for table: redemption"""
input redemption_pk_columns_input {
  id: Int!
}

"""
select columns of table "redemption"
"""
enum redemption_select_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  redeemable_address

  """column name"""
  redeemer_id
}

"""
input type for updating data in table "redemption"
"""
input redemption_set_input {
  amount: numeric
  created_at: timestamptz
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  redeemable_address: String
  redeemer_id: String
}

"""aggregate stddev on columns"""
type redemption_stddev_fields {
  amount: Float
  id: Float
}

"""
order by stddev() on columns of table "redemption"
"""
input redemption_stddev_order_by {
  amount: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type redemption_stddev_pop_fields {
  amount: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "redemption"
"""
input redemption_stddev_pop_order_by {
  amount: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type redemption_stddev_samp_fields {
  amount: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "redemption"
"""
input redemption_stddev_samp_order_by {
  amount: order_by
  id: order_by
}

"""
Streaming cursor of the table "redemption"
"""
input redemption_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: redemption_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input redemption_stream_cursor_value_input {
  amount: numeric
  created_at: timestamptz
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  redeemable_address: String
  redeemer_id: String
}

"""aggregate sum on columns"""
type redemption_sum_fields {
  amount: numeric
  id: Int
}

"""
order by sum() on columns of table "redemption"
"""
input redemption_sum_order_by {
  amount: order_by
  id: order_by
}

"""
update columns of table "redemption"
"""
enum redemption_update_column {
  """column name"""
  amount

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  redeemable_address

  """column name"""
  redeemer_id
}

input redemption_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: redemption_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: redemption_set_input

  """filter the rows which have to be updated"""
  where: redemption_bool_exp!
}

"""aggregate var_pop on columns"""
type redemption_var_pop_fields {
  amount: Float
  id: Float
}

"""
order by var_pop() on columns of table "redemption"
"""
input redemption_var_pop_order_by {
  amount: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type redemption_var_samp_fields {
  amount: Float
  id: Float
}

"""
order by var_samp() on columns of table "redemption"
"""
input redemption_var_samp_order_by {
  amount: order_by
  id: order_by
}

"""aggregate variance on columns"""
type redemption_variance_fields {
  amount: Float
  id: Float
}

"""
order by variance() on columns of table "redemption"
"""
input redemption_variance_order_by {
  amount: order_by
  id: order_by
}

"""
columns and relationships of "report"
"""
type report {
  created_at: timestamptz!

  """An object relationship"""
  generative_token: generative_token
  id: uuid!

  """An object relationship"""
  moderation_reason: moderation_reason
  reason_id: String
  token_id: String

  """An object relationship"""
  user: user
  user_id: String
}

"""
aggregated selection of "report"
"""
type report_aggregate {
  aggregate: report_aggregate_fields
  nodes: [report!]!
}

input report_aggregate_bool_exp {
  count: report_aggregate_bool_exp_count
}

input report_aggregate_bool_exp_count {
  arguments: [report_select_column!]
  distinct: Boolean
  filter: report_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "report"
"""
type report_aggregate_fields {
  count(columns: [report_select_column!], distinct: Boolean): Int!
  max: report_max_fields
  min: report_min_fields
}

"""
order by aggregate values of table "report"
"""
input report_aggregate_order_by {
  count: order_by
  max: report_max_order_by
  min: report_min_order_by
}

"""
input type for inserting array relation for remote table "report"
"""
input report_arr_rel_insert_input {
  data: [report_insert_input!]!

  """upsert condition"""
  on_conflict: report_on_conflict
}

"""
Boolean expression to filter rows from the table "report". All fields are combined with a logical 'AND'.
"""
input report_bool_exp {
  _and: [report_bool_exp!]
  _not: report_bool_exp
  _or: [report_bool_exp!]
  created_at: timestamptz_comparison_exp
  generative_token: generative_token_bool_exp
  id: uuid_comparison_exp
  moderation_reason: moderation_reason_bool_exp
  reason_id: String_comparison_exp
  token_id: String_comparison_exp
  user: user_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "report"
"""
enum report_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_99e4d0bea58cba73c57f935a546
}

"""
input type for inserting data into table "report"
"""
input report_insert_input {
  created_at: timestamptz
  generative_token: generative_token_obj_rel_insert_input
  id: uuid
  moderation_reason: moderation_reason_obj_rel_insert_input
  reason_id: String
  token_id: String
  user: user_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type report_max_fields {
  created_at: timestamptz
  id: uuid
  reason_id: String
  token_id: String
  user_id: String
}

"""
order by max() on columns of table "report"
"""
input report_max_order_by {
  created_at: order_by
  id: order_by
  reason_id: order_by
  token_id: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type report_min_fields {
  created_at: timestamptz
  id: uuid
  reason_id: String
  token_id: String
  user_id: String
}

"""
order by min() on columns of table "report"
"""
input report_min_order_by {
  created_at: order_by
  id: order_by
  reason_id: order_by
  token_id: order_by
  user_id: order_by
}

"""
response of any mutation on the table "report"
"""
type report_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [report!]!
}

"""
on_conflict condition type for table "report"
"""
input report_on_conflict {
  constraint: report_constraint!
  update_columns: [report_update_column!]! = []
  where: report_bool_exp
}

"""Ordering options when selecting data from "report"."""
input report_order_by {
  created_at: order_by
  generative_token: generative_token_order_by
  id: order_by
  moderation_reason: moderation_reason_order_by
  reason_id: order_by
  token_id: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: report"""
input report_pk_columns_input {
  id: uuid!
}

"""
select columns of table "report"
"""
enum report_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  reason_id

  """column name"""
  token_id

  """column name"""
  user_id
}

"""
input type for updating data in table "report"
"""
input report_set_input {
  created_at: timestamptz
  id: uuid
  reason_id: String
  token_id: String
  user_id: String
}

"""
Streaming cursor of the table "report"
"""
input report_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: report_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input report_stream_cursor_value_input {
  created_at: timestamptz
  id: uuid
  reason_id: String
  token_id: String
  user_id: String
}

"""
update columns of table "report"
"""
enum report_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  reason_id

  """column name"""
  token_id

  """column name"""
  user_id
}

input report_updates {
  """sets the columns of the filtered rows to the given values"""
  _set: report_set_input

  """filter the rows which have to be updated"""
  where: report_bool_exp!
}

"""
columns and relationships of "reserve"
"""
type reserve {
  amount: numeric!
  data(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  generative_token: generative_token
  id: Int!
  method: Int!
  token_id: String
}

"""
aggregated selection of "reserve"
"""
type reserve_aggregate {
  aggregate: reserve_aggregate_fields
  nodes: [reserve!]!
}

input reserve_aggregate_bool_exp {
  count: reserve_aggregate_bool_exp_count
}

input reserve_aggregate_bool_exp_count {
  arguments: [reserve_select_column!]
  distinct: Boolean
  filter: reserve_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "reserve"
"""
type reserve_aggregate_fields {
  avg: reserve_avg_fields
  count(columns: [reserve_select_column!], distinct: Boolean): Int!
  max: reserve_max_fields
  min: reserve_min_fields
  stddev: reserve_stddev_fields
  stddev_pop: reserve_stddev_pop_fields
  stddev_samp: reserve_stddev_samp_fields
  sum: reserve_sum_fields
  var_pop: reserve_var_pop_fields
  var_samp: reserve_var_samp_fields
  variance: reserve_variance_fields
}

"""
order by aggregate values of table "reserve"
"""
input reserve_aggregate_order_by {
  avg: reserve_avg_order_by
  count: order_by
  max: reserve_max_order_by
  min: reserve_min_order_by
  stddev: reserve_stddev_order_by
  stddev_pop: reserve_stddev_pop_order_by
  stddev_samp: reserve_stddev_samp_order_by
  sum: reserve_sum_order_by
  var_pop: reserve_var_pop_order_by
  var_samp: reserve_var_samp_order_by
  variance: reserve_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input reserve_append_input {
  data: jsonb
}

"""
input type for inserting array relation for remote table "reserve"
"""
input reserve_arr_rel_insert_input {
  data: [reserve_insert_input!]!

  """upsert condition"""
  on_conflict: reserve_on_conflict
}

"""aggregate avg on columns"""
type reserve_avg_fields {
  amount: Float
  id: Float
  method: Float
}

"""
order by avg() on columns of table "reserve"
"""
input reserve_avg_order_by {
  amount: order_by
  id: order_by
  method: order_by
}

"""
Boolean expression to filter rows from the table "reserve". All fields are combined with a logical 'AND'.
"""
input reserve_bool_exp {
  _and: [reserve_bool_exp!]
  _not: reserve_bool_exp
  _or: [reserve_bool_exp!]
  amount: numeric_comparison_exp
  data: jsonb_comparison_exp
  generative_token: generative_token_bool_exp
  id: Int_comparison_exp
  method: Int_comparison_exp
  token_id: String_comparison_exp
}

"""
unique or primary key constraints on table "reserve"
"""
enum reserve_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_619d1e12dbedbe126620cac8240
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input reserve_delete_at_path_input {
  data: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input reserve_delete_elem_input {
  data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input reserve_delete_key_input {
  data: String
}

"""
input type for incrementing numeric columns in table "reserve"
"""
input reserve_inc_input {
  amount: numeric
  id: Int
  method: Int
}

"""
input type for inserting data into table "reserve"
"""
input reserve_insert_input {
  amount: numeric
  data: jsonb
  generative_token: generative_token_obj_rel_insert_input
  id: Int
  method: Int
  token_id: String
}

"""aggregate max on columns"""
type reserve_max_fields {
  amount: numeric
  id: Int
  method: Int
  token_id: String
}

"""
order by max() on columns of table "reserve"
"""
input reserve_max_order_by {
  amount: order_by
  id: order_by
  method: order_by
  token_id: order_by
}

"""aggregate min on columns"""
type reserve_min_fields {
  amount: numeric
  id: Int
  method: Int
  token_id: String
}

"""
order by min() on columns of table "reserve"
"""
input reserve_min_order_by {
  amount: order_by
  id: order_by
  method: order_by
  token_id: order_by
}

"""
response of any mutation on the table "reserve"
"""
type reserve_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [reserve!]!
}

"""
on_conflict condition type for table "reserve"
"""
input reserve_on_conflict {
  constraint: reserve_constraint!
  update_columns: [reserve_update_column!]! = []
  where: reserve_bool_exp
}

"""Ordering options when selecting data from "reserve"."""
input reserve_order_by {
  amount: order_by
  data: order_by
  generative_token: generative_token_order_by
  id: order_by
  method: order_by
  token_id: order_by
}

"""primary key columns input for table: reserve"""
input reserve_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input reserve_prepend_input {
  data: jsonb
}

"""
select columns of table "reserve"
"""
enum reserve_select_column {
  """column name"""
  amount

  """column name"""
  data

  """column name"""
  id

  """column name"""
  method

  """column name"""
  token_id
}

"""
input type for updating data in table "reserve"
"""
input reserve_set_input {
  amount: numeric
  data: jsonb
  id: Int
  method: Int
  token_id: String
}

"""aggregate stddev on columns"""
type reserve_stddev_fields {
  amount: Float
  id: Float
  method: Float
}

"""
order by stddev() on columns of table "reserve"
"""
input reserve_stddev_order_by {
  amount: order_by
  id: order_by
  method: order_by
}

"""aggregate stddev_pop on columns"""
type reserve_stddev_pop_fields {
  amount: Float
  id: Float
  method: Float
}

"""
order by stddev_pop() on columns of table "reserve"
"""
input reserve_stddev_pop_order_by {
  amount: order_by
  id: order_by
  method: order_by
}

"""aggregate stddev_samp on columns"""
type reserve_stddev_samp_fields {
  amount: Float
  id: Float
  method: Float
}

"""
order by stddev_samp() on columns of table "reserve"
"""
input reserve_stddev_samp_order_by {
  amount: order_by
  id: order_by
  method: order_by
}

"""
Streaming cursor of the table "reserve"
"""
input reserve_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: reserve_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input reserve_stream_cursor_value_input {
  amount: numeric
  data: jsonb
  id: Int
  method: Int
  token_id: String
}

"""aggregate sum on columns"""
type reserve_sum_fields {
  amount: numeric
  id: Int
  method: Int
}

"""
order by sum() on columns of table "reserve"
"""
input reserve_sum_order_by {
  amount: order_by
  id: order_by
  method: order_by
}

"""
update columns of table "reserve"
"""
enum reserve_update_column {
  """column name"""
  amount

  """column name"""
  data

  """column name"""
  id

  """column name"""
  method

  """column name"""
  token_id
}

input reserve_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: reserve_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: reserve_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: reserve_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: reserve_delete_key_input

  """increments the numeric columns with given value of the filtered values"""
  _inc: reserve_inc_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: reserve_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: reserve_set_input

  """filter the rows which have to be updated"""
  where: reserve_bool_exp!
}

"""aggregate var_pop on columns"""
type reserve_var_pop_fields {
  amount: Float
  id: Float
  method: Float
}

"""
order by var_pop() on columns of table "reserve"
"""
input reserve_var_pop_order_by {
  amount: order_by
  id: order_by
  method: order_by
}

"""aggregate var_samp on columns"""
type reserve_var_samp_fields {
  amount: Float
  id: Float
  method: Float
}

"""
order by var_samp() on columns of table "reserve"
"""
input reserve_var_samp_order_by {
  amount: order_by
  id: order_by
  method: order_by
}

"""aggregate variance on columns"""
type reserve_variance_fields {
  amount: Float
  id: Float
  method: Float
}

"""
order by variance() on columns of table "reserve"
"""
input reserve_variance_order_by {
  amount: order_by
  id: order_by
  method: order_by
}

scalar smallint

"""
Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'.
"""
input smallint_comparison_exp {
  _eq: smallint
  _gt: smallint
  _gte: smallint
  _in: [smallint!]
  _is_null: Boolean
  _lt: smallint
  _lte: smallint
  _neq: smallint
  _nin: [smallint!]
}

"""
columns and relationships of "split"
"""
type split {
  """An object relationship"""
  article: article
  article_id: Int

  """An object relationship"""
  generativeTokenByGenerativeTokenPrimaryId: generative_token

  """An object relationship"""
  generative_token: generative_token
  generative_token_primary_id: String
  generative_token_secondary_id: String
  id: Int!

  """An object relationship"""
  objkt: objkt
  objkt_id: String
  objkt_issuer_version: generative_token_version
  pct: Int!

  """An object relationship"""
  redeemable: redeemable
  redeemable_address: String

  """An object relationship"""
  user: user
  user_id: String
}

"""
aggregated selection of "split"
"""
type split_aggregate {
  aggregate: split_aggregate_fields
  nodes: [split!]!
}

input split_aggregate_bool_exp {
  count: split_aggregate_bool_exp_count
}

input split_aggregate_bool_exp_count {
  arguments: [split_select_column!]
  distinct: Boolean
  filter: split_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "split"
"""
type split_aggregate_fields {
  avg: split_avg_fields
  count(columns: [split_select_column!], distinct: Boolean): Int!
  max: split_max_fields
  min: split_min_fields
  stddev: split_stddev_fields
  stddev_pop: split_stddev_pop_fields
  stddev_samp: split_stddev_samp_fields
  sum: split_sum_fields
  var_pop: split_var_pop_fields
  var_samp: split_var_samp_fields
  variance: split_variance_fields
}

"""
order by aggregate values of table "split"
"""
input split_aggregate_order_by {
  avg: split_avg_order_by
  count: order_by
  max: split_max_order_by
  min: split_min_order_by
  stddev: split_stddev_order_by
  stddev_pop: split_stddev_pop_order_by
  stddev_samp: split_stddev_samp_order_by
  sum: split_sum_order_by
  var_pop: split_var_pop_order_by
  var_samp: split_var_samp_order_by
  variance: split_variance_order_by
}

"""
input type for inserting array relation for remote table "split"
"""
input split_arr_rel_insert_input {
  data: [split_insert_input!]!

  """upsert condition"""
  on_conflict: split_on_conflict
}

"""aggregate avg on columns"""
type split_avg_fields {
  article_id: Float
  id: Float
  pct: Float
}

"""
order by avg() on columns of table "split"
"""
input split_avg_order_by {
  article_id: order_by
  id: order_by
  pct: order_by
}

"""
Boolean expression to filter rows from the table "split". All fields are combined with a logical 'AND'.
"""
input split_bool_exp {
  _and: [split_bool_exp!]
  _not: split_bool_exp
  _or: [split_bool_exp!]
  article: article_bool_exp
  article_id: Int_comparison_exp
  generativeTokenByGenerativeTokenPrimaryId: generative_token_bool_exp
  generative_token: generative_token_bool_exp
  generative_token_primary_id: String_comparison_exp
  generative_token_secondary_id: String_comparison_exp
  id: Int_comparison_exp
  objkt: objkt_bool_exp
  objkt_id: String_comparison_exp
  objkt_issuer_version: generative_token_version_comparison_exp
  pct: Int_comparison_exp
  redeemable: redeemable_bool_exp
  redeemable_address: String_comparison_exp
  user: user_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "split"
"""
enum split_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_a656ea46749d1567ca7e7d5923a
}

"""
input type for incrementing numeric columns in table "split"
"""
input split_inc_input {
  article_id: Int
  id: Int
  pct: Int
}

"""
input type for inserting data into table "split"
"""
input split_insert_input {
  article: article_obj_rel_insert_input
  article_id: Int
  generativeTokenByGenerativeTokenPrimaryId: generative_token_obj_rel_insert_input
  generative_token: generative_token_obj_rel_insert_input
  generative_token_primary_id: String
  generative_token_secondary_id: String
  id: Int
  objkt: objkt_obj_rel_insert_input
  objkt_id: String
  objkt_issuer_version: generative_token_version
  pct: Int
  redeemable: redeemable_obj_rel_insert_input
  redeemable_address: String
  user: user_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type split_max_fields {
  article_id: Int
  generative_token_primary_id: String
  generative_token_secondary_id: String
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  pct: Int
  redeemable_address: String
  user_id: String
}

"""
order by max() on columns of table "split"
"""
input split_max_order_by {
  article_id: order_by
  generative_token_primary_id: order_by
  generative_token_secondary_id: order_by
  id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  pct: order_by
  redeemable_address: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type split_min_fields {
  article_id: Int
  generative_token_primary_id: String
  generative_token_secondary_id: String
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  pct: Int
  redeemable_address: String
  user_id: String
}

"""
order by min() on columns of table "split"
"""
input split_min_order_by {
  article_id: order_by
  generative_token_primary_id: order_by
  generative_token_secondary_id: order_by
  id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  pct: order_by
  redeemable_address: order_by
  user_id: order_by
}

"""
response of any mutation on the table "split"
"""
type split_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [split!]!
}

"""
on_conflict condition type for table "split"
"""
input split_on_conflict {
  constraint: split_constraint!
  update_columns: [split_update_column!]! = []
  where: split_bool_exp
}

"""Ordering options when selecting data from "split"."""
input split_order_by {
  article: article_order_by
  article_id: order_by
  generativeTokenByGenerativeTokenPrimaryId: generative_token_order_by
  generative_token: generative_token_order_by
  generative_token_primary_id: order_by
  generative_token_secondary_id: order_by
  id: order_by
  objkt: objkt_order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  pct: order_by
  redeemable: redeemable_order_by
  redeemable_address: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: split"""
input split_pk_columns_input {
  id: Int!
}

"""
select columns of table "split"
"""
enum split_select_column {
  """column name"""
  article_id

  """column name"""
  generative_token_primary_id

  """column name"""
  generative_token_secondary_id

  """column name"""
  id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  pct

  """column name"""
  redeemable_address

  """column name"""
  user_id
}

"""
input type for updating data in table "split"
"""
input split_set_input {
  article_id: Int
  generative_token_primary_id: String
  generative_token_secondary_id: String
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  pct: Int
  redeemable_address: String
  user_id: String
}

"""aggregate stddev on columns"""
type split_stddev_fields {
  article_id: Float
  id: Float
  pct: Float
}

"""
order by stddev() on columns of table "split"
"""
input split_stddev_order_by {
  article_id: order_by
  id: order_by
  pct: order_by
}

"""aggregate stddev_pop on columns"""
type split_stddev_pop_fields {
  article_id: Float
  id: Float
  pct: Float
}

"""
order by stddev_pop() on columns of table "split"
"""
input split_stddev_pop_order_by {
  article_id: order_by
  id: order_by
  pct: order_by
}

"""aggregate stddev_samp on columns"""
type split_stddev_samp_fields {
  article_id: Float
  id: Float
  pct: Float
}

"""
order by stddev_samp() on columns of table "split"
"""
input split_stddev_samp_order_by {
  article_id: order_by
  id: order_by
  pct: order_by
}

"""
Streaming cursor of the table "split"
"""
input split_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: split_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input split_stream_cursor_value_input {
  article_id: Int
  generative_token_primary_id: String
  generative_token_secondary_id: String
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  pct: Int
  redeemable_address: String
  user_id: String
}

"""aggregate sum on columns"""
type split_sum_fields {
  article_id: Int
  id: Int
  pct: Int
}

"""
order by sum() on columns of table "split"
"""
input split_sum_order_by {
  article_id: order_by
  id: order_by
  pct: order_by
}

"""
update columns of table "split"
"""
enum split_update_column {
  """column name"""
  article_id

  """column name"""
  generative_token_primary_id

  """column name"""
  generative_token_secondary_id

  """column name"""
  id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  pct

  """column name"""
  redeemable_address

  """column name"""
  user_id
}

input split_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: split_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: split_set_input

  """filter the rows which have to be updated"""
  where: split_bool_exp!
}

"""aggregate var_pop on columns"""
type split_var_pop_fields {
  article_id: Float
  id: Float
  pct: Float
}

"""
order by var_pop() on columns of table "split"
"""
input split_var_pop_order_by {
  article_id: order_by
  id: order_by
  pct: order_by
}

"""aggregate var_samp on columns"""
type split_var_samp_fields {
  article_id: Float
  id: Float
  pct: Float
}

"""
order by var_samp() on columns of table "split"
"""
input split_var_samp_order_by {
  article_id: order_by
  id: order_by
  pct: order_by
}

"""aggregate variance on columns"""
type split_variance_fields {
  article_id: Float
  id: Float
  pct: Float
}

"""
order by variance() on columns of table "split"
"""
input split_variance_order_by {
  article_id: order_by
  id: order_by
  pct: order_by
}

type subscription_root {
  """
  fetch data from the table: "Account"
  """
  Account(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch aggregated fields from the table: "Account"
  """
  Account_aggregate(
    """distinct select on columns"""
    distinct_on: [Account_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Account_order_by!]

    """filter the rows returned"""
    where: Account_bool_exp
  ): Account_aggregate!

  """fetch data from the table: "Account" using primary key columns"""
  Account_by_pk(id: uuid!): Account

  """
  fetch data from the table in a streaming manner: "Account"
  """
  Account_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Account_stream_cursor_input]!

    """filter the rows returned"""
    where: Account_bool_exp
  ): [Account!]!

  """
  fetch data from the table: "Profile"
  """
  Profile(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """
  fetch aggregated fields from the table: "Profile"
  """
  Profile_aggregate(
    """distinct select on columns"""
    distinct_on: [Profile_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Profile_order_by!]

    """filter the rows returned"""
    where: Profile_bool_exp
  ): Profile_aggregate!

  """fetch data from the table: "Profile" using primary key columns"""
  Profile_by_pk(accountId: uuid!): Profile

  """
  fetch data from the table in a streaming manner: "Profile"
  """
  Profile_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Profile_stream_cursor_input]!

    """filter the rows returned"""
    where: Profile_bool_exp
  ): [Profile!]!

  """
  fetch data from the table: "Wallet"
  """
  Wallet(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  fetch aggregated fields from the table: "Wallet"
  """
  Wallet_aggregate(
    """distinct select on columns"""
    distinct_on: [Wallet_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Wallet_order_by!]

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): Wallet_aggregate!

  """fetch data from the table: "Wallet" using primary key columns"""
  Wallet_by_pk(address: String!): Wallet

  """
  fetch data from the table in a streaming manner: "Wallet"
  """
  Wallet_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Wallet_stream_cursor_input]!

    """filter the rows returned"""
    where: Wallet_bool_exp
  ): [Wallet!]!

  """
  fetch data from the table: "Whitelist"
  """
  Whitelist(
    """distinct select on columns"""
    distinct_on: [Whitelist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Whitelist_order_by!]

    """filter the rows returned"""
    where: Whitelist_bool_exp
  ): [Whitelist!]!

  """
  fetch data from the table: "WhitelistEntries"
  """
  WhitelistEntries(
    """distinct select on columns"""
    distinct_on: [WhitelistEntries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WhitelistEntries_order_by!]

    """filter the rows returned"""
    where: WhitelistEntries_bool_exp
  ): [WhitelistEntries!]!

  """
  fetch aggregated fields from the table: "WhitelistEntries"
  """
  WhitelistEntries_aggregate(
    """distinct select on columns"""
    distinct_on: [WhitelistEntries_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [WhitelistEntries_order_by!]

    """filter the rows returned"""
    where: WhitelistEntries_bool_exp
  ): WhitelistEntries_aggregate!

  """
  fetch data from the table: "WhitelistEntries" using primary key columns
  """
  WhitelistEntries_by_pk(merkleRoot: String!, whitelistIndex: Int!): WhitelistEntries

  """
  fetch data from the table in a streaming manner: "WhitelistEntries"
  """
  WhitelistEntries_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [WhitelistEntries_stream_cursor_input]!

    """filter the rows returned"""
    where: WhitelistEntries_bool_exp
  ): [WhitelistEntries!]!

  """
  fetch aggregated fields from the table: "Whitelist"
  """
  Whitelist_aggregate(
    """distinct select on columns"""
    distinct_on: [Whitelist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [Whitelist_order_by!]

    """filter the rows returned"""
    where: Whitelist_bool_exp
  ): Whitelist_aggregate!

  """fetch data from the table: "Whitelist" using primary key columns"""
  Whitelist_by_pk(merkleRoot: String!): Whitelist

  """
  fetch data from the table in a streaming manner: "Whitelist"
  """
  Whitelist_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [Whitelist_stream_cursor_input]!

    """filter the rows returned"""
    where: Whitelist_bool_exp
  ): [Whitelist!]!

  """
  fetch data from the table: "action"
  """
  action(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch aggregated fields from the table: "action"
  """
  action_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """fetch data from the table: "action" using primary key columns"""
  action_by_pk(id: uuid!): action

  """
  fetch data from the table in a streaming manner: "action"
  """
  action_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [action_stream_cursor_input]!

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """
  fetch data from the table: "article"
  """
  article(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): [article!]!

  """
  fetch aggregated fields from the table: "article"
  """
  article_aggregate(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): article_aggregate!

  """fetch data from the table: "article" using primary key columns"""
  article_by_pk(id: Int!): article

  """
  fetch data from the table: "article_generative_token"
  """
  article_generative_token(
    """distinct select on columns"""
    distinct_on: [article_generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_generative_token_order_by!]

    """filter the rows returned"""
    where: article_generative_token_bool_exp
  ): [article_generative_token!]!

  """
  fetch aggregated fields from the table: "article_generative_token"
  """
  article_generative_token_aggregate(
    """distinct select on columns"""
    distinct_on: [article_generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_generative_token_order_by!]

    """filter the rows returned"""
    where: article_generative_token_bool_exp
  ): article_generative_token_aggregate!

  """
  fetch data from the table: "article_generative_token" using primary key columns
  """
  article_generative_token_by_pk(article_id: Int!, generative_token_id: String!): article_generative_token

  """
  fetch data from the table in a streaming manner: "article_generative_token"
  """
  article_generative_token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [article_generative_token_stream_cursor_input]!

    """filter the rows returned"""
    where: article_generative_token_bool_exp
  ): [article_generative_token!]!

  """
  fetch data from the table: "article_ledger"
  """
  article_ledger(
    """distinct select on columns"""
    distinct_on: [article_ledger_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_ledger_order_by!]

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): [article_ledger!]!

  """
  fetch aggregated fields from the table: "article_ledger"
  """
  article_ledger_aggregate(
    """distinct select on columns"""
    distinct_on: [article_ledger_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_ledger_order_by!]

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): article_ledger_aggregate!

  """fetch data from the table: "article_ledger" using primary key columns"""
  article_ledger_by_pk(article_id: Int!, owner_id: String!): article_ledger

  """
  fetch data from the table in a streaming manner: "article_ledger"
  """
  article_ledger_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [article_ledger_stream_cursor_input]!

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): [article_ledger!]!

  """
  fetch data from the table: "article_revision"
  """
  article_revision(
    """distinct select on columns"""
    distinct_on: [article_revision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_revision_order_by!]

    """filter the rows returned"""
    where: article_revision_bool_exp
  ): [article_revision!]!

  """
  fetch aggregated fields from the table: "article_revision"
  """
  article_revision_aggregate(
    """distinct select on columns"""
    distinct_on: [article_revision_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_revision_order_by!]

    """filter the rows returned"""
    where: article_revision_bool_exp
  ): article_revision_aggregate!

  """
  fetch data from the table: "article_revision" using primary key columns
  """
  article_revision_by_pk(article_id: Int!, iteration: smallint!): article_revision

  """
  fetch data from the table in a streaming manner: "article_revision"
  """
  article_revision_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [article_revision_stream_cursor_input]!

    """filter the rows returned"""
    where: article_revision_bool_exp
  ): [article_revision!]!

  """
  fetch data from the table in a streaming manner: "article"
  """
  article_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [article_stream_cursor_input]!

    """filter the rows returned"""
    where: article_bool_exp
  ): [article!]!

  """
  fetch data from the table: "auction"
  """
  auction(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): [auction!]!

  """
  fetch aggregated fields from the table: "auction"
  """
  auction_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): auction_aggregate!

  """
  fetch data from the table: "auction_bid"
  """
  auction_bid(
    """distinct select on columns"""
    distinct_on: [auction_bid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_order_by!]

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): [auction_bid!]!

  """
  fetch aggregated fields from the table: "auction_bid"
  """
  auction_bid_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_bid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_order_by!]

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): auction_bid_aggregate!

  """fetch data from the table: "auction_bid" using primary key columns"""
  auction_bid_by_pk(id: uuid!): auction_bid

  """
  fetch data from the table in a streaming manner: "auction_bid"
  """
  auction_bid_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auction_bid_stream_cursor_input]!

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): [auction_bid!]!

  """
  fetch data from the table: "auction_bid_table"
  """
  auction_bid_table(
    """distinct select on columns"""
    distinct_on: [auction_bid_table_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_table_order_by!]

    """filter the rows returned"""
    where: auction_bid_table_bool_exp
  ): [auction_bid_table!]!

  """
  fetch aggregated fields from the table: "auction_bid_table"
  """
  auction_bid_table_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_bid_table_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_table_order_by!]

    """filter the rows returned"""
    where: auction_bid_table_bool_exp
  ): auction_bid_table_aggregate!

  """
  fetch data from the table: "auction_bid_table" using primary key columns
  """
  auction_bid_table_by_pk(id: Int!): auction_bid_table

  """
  fetch data from the table in a streaming manner: "auction_bid_table"
  """
  auction_bid_table_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auction_bid_table_stream_cursor_input]!

    """filter the rows returned"""
    where: auction_bid_table_bool_exp
  ): [auction_bid_table!]!

  """fetch data from the table: "auction" using primary key columns"""
  auction_by_pk(id: Int!, version: Int!): auction

  """
  fetch data from the table in a streaming manner: "auction"
  """
  auction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [auction_stream_cursor_input]!

    """filter the rows returned"""
    where: auction_bool_exp
  ): [auction!]!

  """
  fetch data from the table: "codex"
  """
  codex(
    """distinct select on columns"""
    distinct_on: [codex_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_order_by!]

    """filter the rows returned"""
    where: codex_bool_exp
  ): [codex!]!

  """
  fetch aggregated fields from the table: "codex"
  """
  codex_aggregate(
    """distinct select on columns"""
    distinct_on: [codex_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_order_by!]

    """filter the rows returned"""
    where: codex_bool_exp
  ): codex_aggregate!

  """fetch data from the table: "codex" using primary key columns"""
  codex_by_pk(id: String!, token_version: generative_token_version!): codex

  """
  fetch data from the table in a streaming manner: "codex"
  """
  codex_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [codex_stream_cursor_input]!

    """filter the rows returned"""
    where: codex_bool_exp
  ): [codex!]!

  """
  fetch data from the table: "codex_update_request"
  """
  codex_update_request(
    """distinct select on columns"""
    distinct_on: [codex_update_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_update_request_order_by!]

    """filter the rows returned"""
    where: codex_update_request_bool_exp
  ): [codex_update_request!]!

  """
  fetch aggregated fields from the table: "codex_update_request"
  """
  codex_update_request_aggregate(
    """distinct select on columns"""
    distinct_on: [codex_update_request_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_update_request_order_by!]

    """filter the rows returned"""
    where: codex_update_request_bool_exp
  ): codex_update_request_aggregate!

  """
  fetch data from the table: "codex_update_request" using primary key columns
  """
  codex_update_request_by_pk(codex_id: String!, token_id: String!, token_version: generative_token_version!): codex_update_request

  """
  fetch data from the table in a streaming manner: "codex_update_request"
  """
  codex_update_request_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [codex_update_request_stream_cursor_input]!

    """filter the rows returned"""
    where: codex_update_request_bool_exp
  ): [codex_update_request!]!

  """
  fetch data from the table: "collaboration"
  """
  collaboration(
    """distinct select on columns"""
    distinct_on: [collaboration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collaboration_order_by!]

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): [collaboration!]!

  """
  fetch aggregated fields from the table: "collaboration"
  """
  collaboration_aggregate(
    """distinct select on columns"""
    distinct_on: [collaboration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collaboration_order_by!]

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): collaboration_aggregate!

  """fetch data from the table: "collaboration" using primary key columns"""
  collaboration_by_pk(collaboration_contract_id: String!, collaborator_id: String!): collaboration

  """
  fetch data from the table in a streaming manner: "collaboration"
  """
  collaboration_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [collaboration_stream_cursor_input]!

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): [collaboration!]!

  """
  fetch data from the table: "collection_offer"
  """
  collection_offer(
    """distinct select on columns"""
    distinct_on: [collection_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_offer_order_by!]

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): [collection_offer!]!

  """
  fetch aggregated fields from the table: "collection_offer"
  """
  collection_offer_aggregate(
    """distinct select on columns"""
    distinct_on: [collection_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_offer_order_by!]

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): collection_offer_aggregate!

  """
  fetch data from the table: "collection_offer" using primary key columns
  """
  collection_offer_by_pk(id: String!, version: Int!): collection_offer

  """
  fetch data from the table in a streaming manner: "collection_offer"
  """
  collection_offer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [collection_offer_stream_cursor_input]!

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): [collection_offer!]!

  """
  fetch data from the table: "generative_token"
  """
  generative_token(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): [generative_token!]!

  """
  fetch aggregated fields from the table: "generative_token"
  """
  generative_token_aggregate(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): generative_token_aggregate!

  """
  fetch data from the table: "generative_token" using primary key columns
  """
  generative_token_by_pk(id: String!): generative_token

  """
  fetch data from the table in a streaming manner: "generative_token"
  """
  generative_token_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [generative_token_stream_cursor_input]!

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): [generative_token!]!

  """
  fetch data from the table: "gentk_assign"
  """
  gentk_assign(
    """distinct select on columns"""
    distinct_on: [gentk_assign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gentk_assign_order_by!]

    """filter the rows returned"""
    where: gentk_assign_bool_exp
  ): [gentk_assign!]!

  """
  fetch aggregated fields from the table: "gentk_assign"
  """
  gentk_assign_aggregate(
    """distinct select on columns"""
    distinct_on: [gentk_assign_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [gentk_assign_order_by!]

    """filter the rows returned"""
    where: gentk_assign_bool_exp
  ): gentk_assign_aggregate!

  """fetch data from the table: "gentk_assign" using primary key columns"""
  gentk_assign_by_pk(gentk_id: String!, gentk_issuer_version: generative_token_version!): gentk_assign

  """
  fetch data from the table in a streaming manner: "gentk_assign"
  """
  gentk_assign_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [gentk_assign_stream_cursor_input]!

    """filter the rows returned"""
    where: gentk_assign_bool_exp
  ): [gentk_assign!]!

  """
  fetch data from the table: "ipfs_cid"
  """
  ipfs_cid(
    """distinct select on columns"""
    distinct_on: [ipfs_cid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ipfs_cid_order_by!]

    """filter the rows returned"""
    where: ipfs_cid_bool_exp
  ): [ipfs_cid!]!

  """
  fetch aggregated fields from the table: "ipfs_cid"
  """
  ipfs_cid_aggregate(
    """distinct select on columns"""
    distinct_on: [ipfs_cid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [ipfs_cid_order_by!]

    """filter the rows returned"""
    where: ipfs_cid_bool_exp
  ): ipfs_cid_aggregate!

  """fetch data from the table: "ipfs_cid" using primary key columns"""
  ipfs_cid_by_pk(cid: String!): ipfs_cid

  """
  fetch data from the table in a streaming manner: "ipfs_cid"
  """
  ipfs_cid_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [ipfs_cid_stream_cursor_input]!

    """filter the rows returned"""
    where: ipfs_cid_bool_exp
  ): [ipfs_cid!]!

  """
  fetch data from the table: "listing"
  """
  listing(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): [listing!]!

  """
  fetch aggregated fields from the table: "listing"
  """
  listing_aggregate(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): listing_aggregate!

  """fetch data from the table: "listing" using primary key columns"""
  listing_by_pk(id: String!, version: Int!): listing

  """
  fetch data from the table in a streaming manner: "listing"
  """
  listing_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [listing_stream_cursor_input]!

    """filter the rows returned"""
    where: listing_bool_exp
  ): [listing!]!

  """
  fetch data from the table: "market_stats"
  """
  market_stats(
    """distinct select on columns"""
    distinct_on: [market_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_order_by!]

    """filter the rows returned"""
    where: market_stats_bool_exp
  ): [market_stats!]!

  """
  fetch aggregated fields from the table: "market_stats"
  """
  market_stats_aggregate(
    """distinct select on columns"""
    distinct_on: [market_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_order_by!]

    """filter the rows returned"""
    where: market_stats_bool_exp
  ): market_stats_aggregate!

  """fetch data from the table: "market_stats" using primary key columns"""
  market_stats_by_pk(token_id: String!): market_stats

  """
  fetch data from the table: "market_stats_history"
  """
  market_stats_history(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): [market_stats_history!]!

  """
  fetch aggregated fields from the table: "market_stats_history"
  """
  market_stats_history_aggregate(
    """distinct select on columns"""
    distinct_on: [market_stats_history_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [market_stats_history_order_by!]

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): market_stats_history_aggregate!

  """
  fetch data from the table: "market_stats_history" using primary key columns
  """
  market_stats_history_by_pk(id: Int!): market_stats_history

  """
  fetch data from the table in a streaming manner: "market_stats_history"
  """
  market_stats_history_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [market_stats_history_stream_cursor_input]!

    """filter the rows returned"""
    where: market_stats_history_bool_exp
  ): [market_stats_history!]!

  """
  fetch data from the table in a streaming manner: "market_stats"
  """
  market_stats_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [market_stats_stream_cursor_input]!

    """filter the rows returned"""
    where: market_stats_bool_exp
  ): [market_stats!]!

  """
  fetch data from the table: "media_image"
  """
  media_image(
    """distinct select on columns"""
    distinct_on: [media_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_image_order_by!]

    """filter the rows returned"""
    where: media_image_bool_exp
  ): [media_image!]!

  """
  fetch aggregated fields from the table: "media_image"
  """
  media_image_aggregate(
    """distinct select on columns"""
    distinct_on: [media_image_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [media_image_order_by!]

    """filter the rows returned"""
    where: media_image_bool_exp
  ): media_image_aggregate!

  """fetch data from the table: "media_image" using primary key columns"""
  media_image_by_pk(cid: bpchar!): media_image

  """
  fetch data from the table in a streaming manner: "media_image"
  """
  media_image_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [media_image_stream_cursor_input]!

    """filter the rows returned"""
    where: media_image_bool_exp
  ): [media_image!]!

  """
  fetch data from the table: "mint_ticket"
  """
  mint_ticket(
    """distinct select on columns"""
    distinct_on: [mint_ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_order_by!]

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): [mint_ticket!]!

  """
  fetch aggregated fields from the table: "mint_ticket"
  """
  mint_ticket_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_order_by!]

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): mint_ticket_aggregate!

  """fetch data from the table: "mint_ticket" using primary key columns"""
  mint_ticket_by_pk(id: String!): mint_ticket

  """An array relationship"""
  mint_ticket_settings(
    """distinct select on columns"""
    distinct_on: [mint_ticket_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_settings_order_by!]

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): [mint_ticket_settings!]!

  """An aggregate relationship"""
  mint_ticket_settings_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_ticket_settings_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_settings_order_by!]

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): mint_ticket_settings_aggregate!

  """
  fetch data from the table: "mint_ticket_settings" using primary key columns
  """
  mint_ticket_settings_by_pk(id: String!): mint_ticket_settings

  """
  fetch data from the table in a streaming manner: "mint_ticket_settings"
  """
  mint_ticket_settings_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mint_ticket_settings_stream_cursor_input]!

    """filter the rows returned"""
    where: mint_ticket_settings_bool_exp
  ): [mint_ticket_settings!]!

  """
  fetch data from the table in a streaming manner: "mint_ticket"
  """
  mint_ticket_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [mint_ticket_stream_cursor_input]!

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): [mint_ticket!]!

  """
  fetch data from the table: "moderation_reason"
  """
  moderation_reason(
    """distinct select on columns"""
    distinct_on: [moderation_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [moderation_reason_order_by!]

    """filter the rows returned"""
    where: moderation_reason_bool_exp
  ): [moderation_reason!]!

  """
  fetch aggregated fields from the table: "moderation_reason"
  """
  moderation_reason_aggregate(
    """distinct select on columns"""
    distinct_on: [moderation_reason_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [moderation_reason_order_by!]

    """filter the rows returned"""
    where: moderation_reason_bool_exp
  ): moderation_reason_aggregate!

  """
  fetch data from the table: "moderation_reason" using primary key columns
  """
  moderation_reason_by_pk(id: String!): moderation_reason

  """
  fetch data from the table in a streaming manner: "moderation_reason"
  """
  moderation_reason_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [moderation_reason_stream_cursor_input]!

    """filter the rows returned"""
    where: moderation_reason_bool_exp
  ): [moderation_reason!]!

  """
  fetch data from the table: "objkt"
  """
  objkt(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): [objkt!]!

  """
  fetch aggregated fields from the table: "objkt"
  """
  objkt_aggregate(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): objkt_aggregate!

  """fetch data from the table: "objkt" using primary key columns"""
  objkt_by_pk(id: String!, issuer_version: generative_token_version!): objkt

  """
  fetch data from the table in a streaming manner: "objkt"
  """
  objkt_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [objkt_stream_cursor_input]!

    """filter the rows returned"""
    where: objkt_bool_exp
  ): [objkt!]!

  """
  fetch data from the table: "offer"
  """
  offer(
    """distinct select on columns"""
    distinct_on: [offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_order_by!]

    """filter the rows returned"""
    where: offer_bool_exp
  ): [offer!]!

  """
  fetch aggregated fields from the table: "offer"
  """
  offer_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_order_by!]

    """filter the rows returned"""
    where: offer_bool_exp
  ): offer_aggregate!

  """fetch data from the table: "offer" using primary key columns"""
  offer_by_pk(id: String!, version: Int!): offer

  """
  fetch data from the table in a streaming manner: "offer"
  """
  offer_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [offer_stream_cursor_input]!

    """filter the rows returned"""
    where: offer_bool_exp
  ): [offer!]!

  """
  fetch data from the table: "pricing_dutch_auction"
  """
  pricing_dutch_auction(
    """distinct select on columns"""
    distinct_on: [pricing_dutch_auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_dutch_auction_order_by!]

    """filter the rows returned"""
    where: pricing_dutch_auction_bool_exp
  ): [pricing_dutch_auction!]!

  """
  fetch aggregated fields from the table: "pricing_dutch_auction"
  """
  pricing_dutch_auction_aggregate(
    """distinct select on columns"""
    distinct_on: [pricing_dutch_auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_dutch_auction_order_by!]

    """filter the rows returned"""
    where: pricing_dutch_auction_bool_exp
  ): pricing_dutch_auction_aggregate!

  """
  fetch data from the table: "pricing_dutch_auction" using primary key columns
  """
  pricing_dutch_auction_by_pk(id: String!): pricing_dutch_auction

  """
  fetch data from the table in a streaming manner: "pricing_dutch_auction"
  """
  pricing_dutch_auction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pricing_dutch_auction_stream_cursor_input]!

    """filter the rows returned"""
    where: pricing_dutch_auction_bool_exp
  ): [pricing_dutch_auction!]!

  """
  fetch data from the table: "pricing_fixed"
  """
  pricing_fixed(
    """distinct select on columns"""
    distinct_on: [pricing_fixed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_fixed_order_by!]

    """filter the rows returned"""
    where: pricing_fixed_bool_exp
  ): [pricing_fixed!]!

  """
  fetch aggregated fields from the table: "pricing_fixed"
  """
  pricing_fixed_aggregate(
    """distinct select on columns"""
    distinct_on: [pricing_fixed_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [pricing_fixed_order_by!]

    """filter the rows returned"""
    where: pricing_fixed_bool_exp
  ): pricing_fixed_aggregate!

  """fetch data from the table: "pricing_fixed" using primary key columns"""
  pricing_fixed_by_pk(id: String!): pricing_fixed

  """
  fetch data from the table in a streaming manner: "pricing_fixed"
  """
  pricing_fixed_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [pricing_fixed_stream_cursor_input]!

    """filter the rows returned"""
    where: pricing_fixed_bool_exp
  ): [pricing_fixed!]!

  """
  fetch data from the table: "redeemable"
  """
  redeemable(
    """distinct select on columns"""
    distinct_on: [redeemable_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redeemable_order_by!]

    """filter the rows returned"""
    where: redeemable_bool_exp
  ): [redeemable!]!

  """
  fetch aggregated fields from the table: "redeemable"
  """
  redeemable_aggregate(
    """distinct select on columns"""
    distinct_on: [redeemable_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redeemable_order_by!]

    """filter the rows returned"""
    where: redeemable_bool_exp
  ): redeemable_aggregate!

  """fetch data from the table: "redeemable" using primary key columns"""
  redeemable_by_pk(address: String!): redeemable

  """
  fetch data from the table in a streaming manner: "redeemable"
  """
  redeemable_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [redeemable_stream_cursor_input]!

    """filter the rows returned"""
    where: redeemable_bool_exp
  ): [redeemable!]!

  """
  fetch data from the table: "redemption"
  """
  redemption(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): [redemption!]!

  """
  fetch aggregated fields from the table: "redemption"
  """
  redemption_aggregate(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): redemption_aggregate!

  """fetch data from the table: "redemption" using primary key columns"""
  redemption_by_pk(id: Int!): redemption

  """
  fetch data from the table in a streaming manner: "redemption"
  """
  redemption_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [redemption_stream_cursor_input]!

    """filter the rows returned"""
    where: redemption_bool_exp
  ): [redemption!]!

  """
  fetch data from the table: "report"
  """
  report(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!

  """
  fetch aggregated fields from the table: "report"
  """
  report_aggregate(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): report_aggregate!

  """fetch data from the table: "report" using primary key columns"""
  report_by_pk(id: uuid!): report

  """
  fetch data from the table in a streaming manner: "report"
  """
  report_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [report_stream_cursor_input]!

    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!

  """
  fetch data from the table: "reserve"
  """
  reserve(
    """distinct select on columns"""
    distinct_on: [reserve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reserve_order_by!]

    """filter the rows returned"""
    where: reserve_bool_exp
  ): [reserve!]!

  """
  fetch aggregated fields from the table: "reserve"
  """
  reserve_aggregate(
    """distinct select on columns"""
    distinct_on: [reserve_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [reserve_order_by!]

    """filter the rows returned"""
    where: reserve_bool_exp
  ): reserve_aggregate!

  """fetch data from the table: "reserve" using primary key columns"""
  reserve_by_pk(id: Int!): reserve

  """
  fetch data from the table in a streaming manner: "reserve"
  """
  reserve_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [reserve_stream_cursor_input]!

    """filter the rows returned"""
    where: reserve_bool_exp
  ): [reserve!]!

  """
  fetch data from the table: "split"
  """
  split(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """
  fetch aggregated fields from the table: "split"
  """
  split_aggregate(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): split_aggregate!

  """fetch data from the table: "split" using primary key columns"""
  split_by_pk(id: Int!): split

  """
  fetch data from the table in a streaming manner: "split"
  """
  split_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [split_stream_cursor_input]!

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """
  fetch data from the table: "transaction"
  """
  transaction(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch aggregated fields from the table: "transaction"
  """
  transaction_aggregate(
    """distinct select on columns"""
    distinct_on: [transaction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [transaction_order_by!]

    """filter the rows returned"""
    where: transaction_bool_exp
  ): transaction_aggregate!

  """fetch data from the table: "transaction" using primary key columns"""
  transaction_by_pk(id: Int!): transaction

  """
  fetch data from the table in a streaming manner: "transaction"
  """
  transaction_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [transaction_stream_cursor_input]!

    """filter the rows returned"""
    where: transaction_bool_exp
  ): [transaction!]!

  """
  fetch data from the table: "user"
  """
  user(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!

  """
  fetch aggregated fields from the table: "user"
  """
  user_aggregate(
    """distinct select on columns"""
    distinct_on: [user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_order_by!]

    """filter the rows returned"""
    where: user_bool_exp
  ): user_aggregate!

  """fetch data from the table: "user" using primary key columns"""
  user_by_pk(id: String!): user

  """
  fetch data from the table: "user_stats"
  """
  user_stats(
    """distinct select on columns"""
    distinct_on: [user_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_stats_order_by!]

    """filter the rows returned"""
    where: user_stats_bool_exp
  ): [user_stats!]!

  """
  fetch aggregated fields from the table: "user_stats"
  """
  user_stats_aggregate(
    """distinct select on columns"""
    distinct_on: [user_stats_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_stats_order_by!]

    """filter the rows returned"""
    where: user_stats_bool_exp
  ): user_stats_aggregate!

  """fetch data from the table: "user_stats" using primary key columns"""
  user_stats_by_pk(user_id: String!): user_stats

  """
  fetch data from the table in a streaming manner: "user_stats"
  """
  user_stats_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stats_stream_cursor_input]!

    """filter the rows returned"""
    where: user_stats_bool_exp
  ): [user_stats!]!

  """
  fetch data from the table in a streaming manner: "user"
  """
  user_stream(
    """maximum number of rows returned in a single batch"""
    batch_size: Int!

    """cursor to stream the results returned by the query"""
    cursor: [user_stream_cursor_input]!

    """filter the rows returned"""
    where: user_bool_exp
  ): [user!]!
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "transaction"
"""
type transaction {
  """An object relationship"""
  article: article
  article_id: Int
  created_at: timestamptz!

  """An object relationship"""
  generative_token: generative_token
  id: Int!

  """An object relationship"""
  objkt: objkt
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String!
  price: numeric!
  ticket_id: String
  token_id: String
  type: transaction_type_enum!
}

"""
aggregated selection of "transaction"
"""
type transaction_aggregate {
  aggregate: transaction_aggregate_fields
  nodes: [transaction!]!
}

input transaction_aggregate_bool_exp {
  count: transaction_aggregate_bool_exp_count
}

input transaction_aggregate_bool_exp_count {
  arguments: [transaction_select_column!]
  distinct: Boolean
  filter: transaction_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "transaction"
"""
type transaction_aggregate_fields {
  avg: transaction_avg_fields
  count(columns: [transaction_select_column!], distinct: Boolean): Int!
  max: transaction_max_fields
  min: transaction_min_fields
  stddev: transaction_stddev_fields
  stddev_pop: transaction_stddev_pop_fields
  stddev_samp: transaction_stddev_samp_fields
  sum: transaction_sum_fields
  var_pop: transaction_var_pop_fields
  var_samp: transaction_var_samp_fields
  variance: transaction_variance_fields
}

"""
order by aggregate values of table "transaction"
"""
input transaction_aggregate_order_by {
  avg: transaction_avg_order_by
  count: order_by
  max: transaction_max_order_by
  min: transaction_min_order_by
  stddev: transaction_stddev_order_by
  stddev_pop: transaction_stddev_pop_order_by
  stddev_samp: transaction_stddev_samp_order_by
  sum: transaction_sum_order_by
  var_pop: transaction_var_pop_order_by
  var_samp: transaction_var_samp_order_by
  variance: transaction_variance_order_by
}

"""
input type for inserting array relation for remote table "transaction"
"""
input transaction_arr_rel_insert_input {
  data: [transaction_insert_input!]!

  """upsert condition"""
  on_conflict: transaction_on_conflict
}

"""aggregate avg on columns"""
type transaction_avg_fields {
  article_id: Float
  id: Float
  price: Float
}

"""
order by avg() on columns of table "transaction"
"""
input transaction_avg_order_by {
  article_id: order_by
  id: order_by
  price: order_by
}

"""
Boolean expression to filter rows from the table "transaction". All fields are combined with a logical 'AND'.
"""
input transaction_bool_exp {
  _and: [transaction_bool_exp!]
  _not: transaction_bool_exp
  _or: [transaction_bool_exp!]
  article: article_bool_exp
  article_id: Int_comparison_exp
  created_at: timestamptz_comparison_exp
  generative_token: generative_token_bool_exp
  id: Int_comparison_exp
  objkt: objkt_bool_exp
  objkt_id: String_comparison_exp
  objkt_issuer_version: generative_token_version_comparison_exp
  op_hash: String_comparison_exp
  price: numeric_comparison_exp
  ticket_id: String_comparison_exp
  token_id: String_comparison_exp
  type: transaction_type_enum_comparison_exp
}

"""
unique or primary key constraints on table "transaction"
"""
enum transaction_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_89eadb93a89810556e1cbcd6ab9
}

"""
input type for incrementing numeric columns in table "transaction"
"""
input transaction_inc_input {
  article_id: Int
  id: Int
  price: numeric
}

"""
input type for inserting data into table "transaction"
"""
input transaction_insert_input {
  article: article_obj_rel_insert_input
  article_id: Int
  created_at: timestamptz
  generative_token: generative_token_obj_rel_insert_input
  id: Int
  objkt: objkt_obj_rel_insert_input
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  price: numeric
  ticket_id: String
  token_id: String
  type: transaction_type_enum
}

"""aggregate max on columns"""
type transaction_max_fields {
  article_id: Int
  created_at: timestamptz
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  price: numeric
  ticket_id: String
  token_id: String
  type: transaction_type_enum
}

"""
order by max() on columns of table "transaction"
"""
input transaction_max_order_by {
  article_id: order_by
  created_at: order_by
  id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  op_hash: order_by
  price: order_by
  ticket_id: order_by
  token_id: order_by
  type: order_by
}

"""aggregate min on columns"""
type transaction_min_fields {
  article_id: Int
  created_at: timestamptz
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  price: numeric
  ticket_id: String
  token_id: String
  type: transaction_type_enum
}

"""
order by min() on columns of table "transaction"
"""
input transaction_min_order_by {
  article_id: order_by
  created_at: order_by
  id: order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  op_hash: order_by
  price: order_by
  ticket_id: order_by
  token_id: order_by
  type: order_by
}

"""
response of any mutation on the table "transaction"
"""
type transaction_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [transaction!]!
}

"""
on_conflict condition type for table "transaction"
"""
input transaction_on_conflict {
  constraint: transaction_constraint!
  update_columns: [transaction_update_column!]! = []
  where: transaction_bool_exp
}

"""Ordering options when selecting data from "transaction"."""
input transaction_order_by {
  article: article_order_by
  article_id: order_by
  created_at: order_by
  generative_token: generative_token_order_by
  id: order_by
  objkt: objkt_order_by
  objkt_id: order_by
  objkt_issuer_version: order_by
  op_hash: order_by
  price: order_by
  ticket_id: order_by
  token_id: order_by
  type: order_by
}

"""primary key columns input for table: transaction"""
input transaction_pk_columns_input {
  id: Int!
}

"""
select columns of table "transaction"
"""
enum transaction_select_column {
  """column name"""
  article_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  op_hash

  """column name"""
  price

  """column name"""
  ticket_id

  """column name"""
  token_id

  """column name"""
  type
}

"""
input type for updating data in table "transaction"
"""
input transaction_set_input {
  article_id: Int
  created_at: timestamptz
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  price: numeric
  ticket_id: String
  token_id: String
  type: transaction_type_enum
}

"""aggregate stddev on columns"""
type transaction_stddev_fields {
  article_id: Float
  id: Float
  price: Float
}

"""
order by stddev() on columns of table "transaction"
"""
input transaction_stddev_order_by {
  article_id: order_by
  id: order_by
  price: order_by
}

"""aggregate stddev_pop on columns"""
type transaction_stddev_pop_fields {
  article_id: Float
  id: Float
  price: Float
}

"""
order by stddev_pop() on columns of table "transaction"
"""
input transaction_stddev_pop_order_by {
  article_id: order_by
  id: order_by
  price: order_by
}

"""aggregate stddev_samp on columns"""
type transaction_stddev_samp_fields {
  article_id: Float
  id: Float
  price: Float
}

"""
order by stddev_samp() on columns of table "transaction"
"""
input transaction_stddev_samp_order_by {
  article_id: order_by
  id: order_by
  price: order_by
}

"""
Streaming cursor of the table "transaction"
"""
input transaction_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: transaction_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input transaction_stream_cursor_value_input {
  article_id: Int
  created_at: timestamptz
  id: Int
  objkt_id: String
  objkt_issuer_version: generative_token_version
  op_hash: String
  price: numeric
  ticket_id: String
  token_id: String
  type: transaction_type_enum
}

"""aggregate sum on columns"""
type transaction_sum_fields {
  article_id: Int
  id: Int
  price: numeric
}

"""
order by sum() on columns of table "transaction"
"""
input transaction_sum_order_by {
  article_id: order_by
  id: order_by
  price: order_by
}

scalar transaction_type_enum

"""
Boolean expression to compare columns of type "transaction_type_enum". All fields are combined with logical 'AND'.
"""
input transaction_type_enum_comparison_exp {
  _eq: transaction_type_enum
  _gt: transaction_type_enum
  _gte: transaction_type_enum
  _in: [transaction_type_enum!]
  _is_null: Boolean
  _lt: transaction_type_enum
  _lte: transaction_type_enum
  _neq: transaction_type_enum
  _nin: [transaction_type_enum!]
}

"""
update columns of table "transaction"
"""
enum transaction_update_column {
  """column name"""
  article_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  objkt_id

  """column name"""
  objkt_issuer_version

  """column name"""
  op_hash

  """column name"""
  price

  """column name"""
  ticket_id

  """column name"""
  token_id

  """column name"""
  type
}

input transaction_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: transaction_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: transaction_set_input

  """filter the rows which have to be updated"""
  where: transaction_bool_exp!
}

"""aggregate var_pop on columns"""
type transaction_var_pop_fields {
  article_id: Float
  id: Float
  price: Float
}

"""
order by var_pop() on columns of table "transaction"
"""
input transaction_var_pop_order_by {
  article_id: order_by
  id: order_by
  price: order_by
}

"""aggregate var_samp on columns"""
type transaction_var_samp_fields {
  article_id: Float
  id: Float
  price: Float
}

"""
order by var_samp() on columns of table "transaction"
"""
input transaction_var_samp_order_by {
  article_id: order_by
  id: order_by
  price: order_by
}

"""aggregate variance on columns"""
type transaction_variance_fields {
  article_id: Float
  id: Float
  price: Float
}

"""
order by variance() on columns of table "transaction"
"""
input transaction_variance_order_by {
  article_id: order_by
  id: order_by
  price: order_by
}

"""
columns and relationships of "user"
"""
type user {
  """An array relationship"""
  actions(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """An array relationship"""
  actionsByIssuerId(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): [action!]!

  """An aggregate relationship"""
  actionsByIssuerId_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """An aggregate relationship"""
  actions_aggregate(
    """distinct select on columns"""
    distinct_on: [action_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [action_order_by!]

    """filter the rows returned"""
    where: action_bool_exp
  ): action_aggregate!

  """An array relationship"""
  article_ledgers(
    """distinct select on columns"""
    distinct_on: [article_ledger_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_ledger_order_by!]

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): [article_ledger!]!

  """An aggregate relationship"""
  article_ledgers_aggregate(
    """distinct select on columns"""
    distinct_on: [article_ledger_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_ledger_order_by!]

    """filter the rows returned"""
    where: article_ledger_bool_exp
  ): article_ledger_aggregate!

  """An array relationship"""
  articles(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): [article!]!

  """An aggregate relationship"""
  articles_aggregate(
    """distinct select on columns"""
    distinct_on: [article_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [article_order_by!]

    """filter the rows returned"""
    where: article_bool_exp
  ): article_aggregate!

  """An array relationship"""
  auction_bids(
    """distinct select on columns"""
    distinct_on: [auction_bid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_order_by!]

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): [auction_bid!]!

  """An aggregate relationship"""
  auction_bids_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_bid_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_bid_order_by!]

    """filter the rows returned"""
    where: auction_bid_bool_exp
  ): auction_bid_aggregate!

  """An array relationship"""
  auctions(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): [auction!]!

  """An aggregate relationship"""
  auctions_aggregate(
    """distinct select on columns"""
    distinct_on: [auction_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auction_order_by!]

    """filter the rows returned"""
    where: auction_bool_exp
  ): auction_aggregate!
  authorizations: _int2!
  avatarMediaId: bpchar
  avatar_uri: String

  """An array relationship"""
  codexes(
    """distinct select on columns"""
    distinct_on: [codex_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_order_by!]

    """filter the rows returned"""
    where: codex_bool_exp
  ): [codex!]!

  """An aggregate relationship"""
  codexes_aggregate(
    """distinct select on columns"""
    distinct_on: [codex_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [codex_order_by!]

    """filter the rows returned"""
    where: codex_bool_exp
  ): codex_aggregate!

  """An array relationship"""
  collaborations(
    """distinct select on columns"""
    distinct_on: [collaboration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collaboration_order_by!]

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): [collaboration!]!

  """An array relationship"""
  collaborationsByCollaboratorId(
    """distinct select on columns"""
    distinct_on: [collaboration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collaboration_order_by!]

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): [collaboration!]!

  """An aggregate relationship"""
  collaborationsByCollaboratorId_aggregate(
    """distinct select on columns"""
    distinct_on: [collaboration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collaboration_order_by!]

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): collaboration_aggregate!

  """An aggregate relationship"""
  collaborations_aggregate(
    """distinct select on columns"""
    distinct_on: [collaboration_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collaboration_order_by!]

    """filter the rows returned"""
    where: collaboration_bool_exp
  ): collaboration_aggregate!

  """An array relationship"""
  collection_offers(
    """distinct select on columns"""
    distinct_on: [collection_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_offer_order_by!]

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): [collection_offer!]!

  """An aggregate relationship"""
  collection_offers_aggregate(
    """distinct select on columns"""
    distinct_on: [collection_offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [collection_offer_order_by!]

    """filter the rows returned"""
    where: collection_offer_bool_exp
  ): collection_offer_aggregate!
  created_at: timestamptz!
  description: String
  flag: user_flag_enum!

  """An array relationship"""
  generative_tokens(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): [generative_token!]!

  """An aggregate relationship"""
  generative_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [generative_token_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [generative_token_order_by!]

    """filter the rows returned"""
    where: generative_token_bool_exp
  ): generative_token_aggregate!
  id: String!

  """An array relationship"""
  listings(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): [listing!]!

  """An array relationship"""
  listingsByAcceptedById(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): [listing!]!

  """An aggregate relationship"""
  listingsByAcceptedById_aggregate(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): listing_aggregate!

  """An aggregate relationship"""
  listings_aggregate(
    """distinct select on columns"""
    distinct_on: [listing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [listing_order_by!]

    """filter the rows returned"""
    where: listing_bool_exp
  ): listing_aggregate!

  """An object relationship"""
  media_image: media_image
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  metadata_uri: String

  """An array relationship"""
  mint_tickets(
    """distinct select on columns"""
    distinct_on: [mint_ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_order_by!]

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): [mint_ticket!]!

  """An aggregate relationship"""
  mint_tickets_aggregate(
    """distinct select on columns"""
    distinct_on: [mint_ticket_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [mint_ticket_order_by!]

    """filter the rows returned"""
    where: mint_ticket_bool_exp
  ): mint_ticket_aggregate!

  """An object relationship"""
  moderation_reason: moderation_reason
  moderation_reason_id: String
  name: String

  """An array relationship"""
  objkts(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): [objkt!]!

  """An array relationship"""
  objktsByOwnerId(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): [objkt!]!

  """An aggregate relationship"""
  objktsByOwnerId_aggregate(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): objkt_aggregate!

  """An aggregate relationship"""
  objkts_aggregate(
    """distinct select on columns"""
    distinct_on: [objkt_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [objkt_order_by!]

    """filter the rows returned"""
    where: objkt_bool_exp
  ): objkt_aggregate!

  """An array relationship"""
  offers(
    """distinct select on columns"""
    distinct_on: [offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_order_by!]

    """filter the rows returned"""
    where: offer_bool_exp
  ): [offer!]!

  """An aggregate relationship"""
  offers_aggregate(
    """distinct select on columns"""
    distinct_on: [offer_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [offer_order_by!]

    """filter the rows returned"""
    where: offer_bool_exp
  ): offer_aggregate!

  """An array relationship"""
  redemptions(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): [redemption!]!

  """An aggregate relationship"""
  redemptions_aggregate(
    """distinct select on columns"""
    distinct_on: [redemption_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [redemption_order_by!]

    """filter the rows returned"""
    where: redemption_bool_exp
  ): redemption_aggregate!

  """An array relationship"""
  reports(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): [report!]!

  """An aggregate relationship"""
  reports_aggregate(
    """distinct select on columns"""
    distinct_on: [report_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [report_order_by!]

    """filter the rows returned"""
    where: report_bool_exp
  ): report_aggregate!

  """An array relationship"""
  splits(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): [split!]!

  """An aggregate relationship"""
  splits_aggregate(
    """distinct select on columns"""
    distinct_on: [split_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [split_order_by!]

    """filter the rows returned"""
    where: split_bool_exp
  ): split_aggregate!
  type: user_type_enum!
  updated_at: timestamptz!

  """An object relationship"""
  user_stat: user_stats
}

"""
aggregated selection of "user"
"""
type user_aggregate {
  aggregate: user_aggregate_fields
  nodes: [user!]!
}

input user_aggregate_bool_exp {
  count: user_aggregate_bool_exp_count
}

input user_aggregate_bool_exp_count {
  arguments: [user_select_column!]
  distinct: Boolean
  filter: user_bool_exp
  predicate: Int_comparison_exp!
}

"""
aggregate fields of "user"
"""
type user_aggregate_fields {
  count(columns: [user_select_column!], distinct: Boolean): Int!
  max: user_max_fields
  min: user_min_fields
}

"""
order by aggregate values of table "user"
"""
input user_aggregate_order_by {
  count: order_by
  max: user_max_order_by
  min: user_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input user_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "user"
"""
input user_arr_rel_insert_input {
  data: [user_insert_input!]!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
Boolean expression to filter rows from the table "user". All fields are combined with a logical 'AND'.
"""
input user_bool_exp {
  _and: [user_bool_exp!]
  _not: user_bool_exp
  _or: [user_bool_exp!]
  actions: action_bool_exp
  actionsByIssuerId: action_bool_exp
  actionsByIssuerId_aggregate: action_aggregate_bool_exp
  actions_aggregate: action_aggregate_bool_exp
  article_ledgers: article_ledger_bool_exp
  article_ledgers_aggregate: article_ledger_aggregate_bool_exp
  articles: article_bool_exp
  articles_aggregate: article_aggregate_bool_exp
  auction_bids: auction_bid_bool_exp
  auction_bids_aggregate: auction_bid_aggregate_bool_exp
  auctions: auction_bool_exp
  auctions_aggregate: auction_aggregate_bool_exp
  authorizations: _int2_comparison_exp
  avatarMediaId: bpchar_comparison_exp
  avatar_uri: String_comparison_exp
  codexes: codex_bool_exp
  codexes_aggregate: codex_aggregate_bool_exp
  collaborations: collaboration_bool_exp
  collaborationsByCollaboratorId: collaboration_bool_exp
  collaborationsByCollaboratorId_aggregate: collaboration_aggregate_bool_exp
  collaborations_aggregate: collaboration_aggregate_bool_exp
  collection_offers: collection_offer_bool_exp
  collection_offers_aggregate: collection_offer_aggregate_bool_exp
  created_at: timestamptz_comparison_exp
  description: String_comparison_exp
  flag: user_flag_enum_comparison_exp
  generative_tokens: generative_token_bool_exp
  generative_tokens_aggregate: generative_token_aggregate_bool_exp
  id: String_comparison_exp
  listings: listing_bool_exp
  listingsByAcceptedById: listing_bool_exp
  listingsByAcceptedById_aggregate: listing_aggregate_bool_exp
  listings_aggregate: listing_aggregate_bool_exp
  media_image: media_image_bool_exp
  metadata: jsonb_comparison_exp
  metadata_uri: String_comparison_exp
  mint_tickets: mint_ticket_bool_exp
  mint_tickets_aggregate: mint_ticket_aggregate_bool_exp
  moderation_reason: moderation_reason_bool_exp
  moderation_reason_id: String_comparison_exp
  name: String_comparison_exp
  objkts: objkt_bool_exp
  objktsByOwnerId: objkt_bool_exp
  objktsByOwnerId_aggregate: objkt_aggregate_bool_exp
  objkts_aggregate: objkt_aggregate_bool_exp
  offers: offer_bool_exp
  offers_aggregate: offer_aggregate_bool_exp
  redemptions: redemption_bool_exp
  redemptions_aggregate: redemption_aggregate_bool_exp
  reports: report_bool_exp
  reports_aggregate: report_aggregate_bool_exp
  splits: split_bool_exp
  splits_aggregate: split_aggregate_bool_exp
  type: user_type_enum_comparison_exp
  updated_at: timestamptz_comparison_exp
  user_stat: user_stats_bool_exp
}

"""
unique or primary key constraints on table "user"
"""
enum user_constraint {
  """
  unique or primary key constraint on columns "id"
  """
  PK_cace4a159ff9f2512dd42373760
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input user_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input user_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input user_delete_key_input {
  metadata: String
}

scalar user_flag_enum

"""
Boolean expression to compare columns of type "user_flag_enum". All fields are combined with logical 'AND'.
"""
input user_flag_enum_comparison_exp {
  _eq: user_flag_enum
  _gt: user_flag_enum
  _gte: user_flag_enum
  _in: [user_flag_enum!]
  _is_null: Boolean
  _lt: user_flag_enum
  _lte: user_flag_enum
  _neq: user_flag_enum
  _nin: [user_flag_enum!]
}

"""
input type for inserting data into table "user"
"""
input user_insert_input {
  actions: action_arr_rel_insert_input
  actionsByIssuerId: action_arr_rel_insert_input
  article_ledgers: article_ledger_arr_rel_insert_input
  articles: article_arr_rel_insert_input
  auction_bids: auction_bid_arr_rel_insert_input
  auctions: auction_arr_rel_insert_input
  authorizations: _int2
  avatarMediaId: bpchar
  avatar_uri: String
  codexes: codex_arr_rel_insert_input
  collaborations: collaboration_arr_rel_insert_input
  collaborationsByCollaboratorId: collaboration_arr_rel_insert_input
  collection_offers: collection_offer_arr_rel_insert_input
  created_at: timestamptz
  description: String
  flag: user_flag_enum
  generative_tokens: generative_token_arr_rel_insert_input
  id: String
  listings: listing_arr_rel_insert_input
  listingsByAcceptedById: listing_arr_rel_insert_input
  media_image: media_image_obj_rel_insert_input
  metadata: jsonb
  metadata_uri: String
  mint_tickets: mint_ticket_arr_rel_insert_input
  moderation_reason: moderation_reason_obj_rel_insert_input
  moderation_reason_id: String
  name: String
  objkts: objkt_arr_rel_insert_input
  objktsByOwnerId: objkt_arr_rel_insert_input
  offers: offer_arr_rel_insert_input
  redemptions: redemption_arr_rel_insert_input
  reports: report_arr_rel_insert_input
  splits: split_arr_rel_insert_input
  type: user_type_enum
  updated_at: timestamptz
  user_stat: user_stats_obj_rel_insert_input
}

"""aggregate max on columns"""
type user_max_fields {
  avatarMediaId: bpchar
  avatar_uri: String
  created_at: timestamptz
  description: String
  flag: user_flag_enum
  id: String
  metadata_uri: String
  moderation_reason_id: String
  name: String
  type: user_type_enum
  updated_at: timestamptz
}

"""
order by max() on columns of table "user"
"""
input user_max_order_by {
  avatarMediaId: order_by
  avatar_uri: order_by
  created_at: order_by
  description: order_by
  flag: order_by
  id: order_by
  metadata_uri: order_by
  moderation_reason_id: order_by
  name: order_by
  type: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type user_min_fields {
  avatarMediaId: bpchar
  avatar_uri: String
  created_at: timestamptz
  description: String
  flag: user_flag_enum
  id: String
  metadata_uri: String
  moderation_reason_id: String
  name: String
  type: user_type_enum
  updated_at: timestamptz
}

"""
order by min() on columns of table "user"
"""
input user_min_order_by {
  avatarMediaId: order_by
  avatar_uri: order_by
  created_at: order_by
  description: order_by
  flag: order_by
  id: order_by
  metadata_uri: order_by
  moderation_reason_id: order_by
  name: order_by
  type: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "user"
"""
type user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user!]!
}

"""
input type for inserting object relation for remote table "user"
"""
input user_obj_rel_insert_input {
  data: user_insert_input!

  """upsert condition"""
  on_conflict: user_on_conflict
}

"""
on_conflict condition type for table "user"
"""
input user_on_conflict {
  constraint: user_constraint!
  update_columns: [user_update_column!]! = []
  where: user_bool_exp
}

"""Ordering options when selecting data from "user"."""
input user_order_by {
  actionsByIssuerId_aggregate: action_aggregate_order_by
  actions_aggregate: action_aggregate_order_by
  article_ledgers_aggregate: article_ledger_aggregate_order_by
  articles_aggregate: article_aggregate_order_by
  auction_bids_aggregate: auction_bid_aggregate_order_by
  auctions_aggregate: auction_aggregate_order_by
  authorizations: order_by
  avatarMediaId: order_by
  avatar_uri: order_by
  codexes_aggregate: codex_aggregate_order_by
  collaborationsByCollaboratorId_aggregate: collaboration_aggregate_order_by
  collaborations_aggregate: collaboration_aggregate_order_by
  collection_offers_aggregate: collection_offer_aggregate_order_by
  created_at: order_by
  description: order_by
  flag: order_by
  generative_tokens_aggregate: generative_token_aggregate_order_by
  id: order_by
  listingsByAcceptedById_aggregate: listing_aggregate_order_by
  listings_aggregate: listing_aggregate_order_by
  media_image: media_image_order_by
  metadata: order_by
  metadata_uri: order_by
  mint_tickets_aggregate: mint_ticket_aggregate_order_by
  moderation_reason: moderation_reason_order_by
  moderation_reason_id: order_by
  name: order_by
  objktsByOwnerId_aggregate: objkt_aggregate_order_by
  objkts_aggregate: objkt_aggregate_order_by
  offers_aggregate: offer_aggregate_order_by
  redemptions_aggregate: redemption_aggregate_order_by
  reports_aggregate: report_aggregate_order_by
  splits_aggregate: split_aggregate_order_by
  type: order_by
  updated_at: order_by
  user_stat: user_stats_order_by
}

"""primary key columns input for table: user"""
input user_pk_columns_input {
  id: String!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input user_prepend_input {
  metadata: jsonb
}

"""
select columns of table "user"
"""
enum user_select_column {
  """column name"""
  authorizations

  """column name"""
  avatarMediaId

  """column name"""
  avatar_uri

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  flag

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  metadata_uri

  """column name"""
  moderation_reason_id

  """column name"""
  name

  """column name"""
  type

  """column name"""
  updated_at
}

"""
input type for updating data in table "user"
"""
input user_set_input {
  authorizations: _int2
  avatarMediaId: bpchar
  avatar_uri: String
  created_at: timestamptz
  description: String
  flag: user_flag_enum
  id: String
  metadata: jsonb
  metadata_uri: String
  moderation_reason_id: String
  name: String
  type: user_type_enum
  updated_at: timestamptz
}

"""
columns and relationships of "user_stats"
"""
type user_stats {
  from: timestamptz
  prim_volume_nb: bigint
  prim_volume_nb7d: bigint
  prim_volume_nb24: bigint
  prim_volume_nb30d: bigint
  prim_volume_tz: bigint
  prim_volume_tz7d: bigint
  prim_volume_tz24: bigint
  prim_volume_tz30d: bigint
  sec_volume_nb: bigint
  sec_volume_nb7d: bigint
  sec_volume_nb24: bigint
  sec_volume_nb30d: bigint
  sec_volume_tz: bigint
  sec_volume_tz7d: bigint
  sec_volume_tz24: bigint
  sec_volume_tz30d: bigint
  to: timestamptz

  """An object relationship"""
  user: user!
  user_id: String!
}

"""
aggregated selection of "user_stats"
"""
type user_stats_aggregate {
  aggregate: user_stats_aggregate_fields
  nodes: [user_stats!]!
}

"""
aggregate fields of "user_stats"
"""
type user_stats_aggregate_fields {
  avg: user_stats_avg_fields
  count(columns: [user_stats_select_column!], distinct: Boolean): Int!
  max: user_stats_max_fields
  min: user_stats_min_fields
  stddev: user_stats_stddev_fields
  stddev_pop: user_stats_stddev_pop_fields
  stddev_samp: user_stats_stddev_samp_fields
  sum: user_stats_sum_fields
  var_pop: user_stats_var_pop_fields
  var_samp: user_stats_var_samp_fields
  variance: user_stats_variance_fields
}

"""aggregate avg on columns"""
type user_stats_avg_fields {
  prim_volume_nb: Float
  prim_volume_nb7d: Float
  prim_volume_nb24: Float
  prim_volume_nb30d: Float
  prim_volume_tz: Float
  prim_volume_tz7d: Float
  prim_volume_tz24: Float
  prim_volume_tz30d: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""
Boolean expression to filter rows from the table "user_stats". All fields are combined with a logical 'AND'.
"""
input user_stats_bool_exp {
  _and: [user_stats_bool_exp!]
  _not: user_stats_bool_exp
  _or: [user_stats_bool_exp!]
  from: timestamptz_comparison_exp
  prim_volume_nb: bigint_comparison_exp
  prim_volume_nb7d: bigint_comparison_exp
  prim_volume_nb24: bigint_comparison_exp
  prim_volume_nb30d: bigint_comparison_exp
  prim_volume_tz: bigint_comparison_exp
  prim_volume_tz7d: bigint_comparison_exp
  prim_volume_tz24: bigint_comparison_exp
  prim_volume_tz30d: bigint_comparison_exp
  sec_volume_nb: bigint_comparison_exp
  sec_volume_nb7d: bigint_comparison_exp
  sec_volume_nb24: bigint_comparison_exp
  sec_volume_nb30d: bigint_comparison_exp
  sec_volume_tz: bigint_comparison_exp
  sec_volume_tz7d: bigint_comparison_exp
  sec_volume_tz24: bigint_comparison_exp
  sec_volume_tz30d: bigint_comparison_exp
  to: timestamptz_comparison_exp
  user: user_bool_exp
  user_id: String_comparison_exp
}

"""
unique or primary key constraints on table "user_stats"
"""
enum user_stats_constraint {
  """
  unique or primary key constraint on columns "user_id"
  """
  PK_0e0da843088caf61925ded4434e
}

"""
input type for incrementing numeric columns in table "user_stats"
"""
input user_stats_inc_input {
  prim_volume_nb: bigint
  prim_volume_nb7d: bigint
  prim_volume_nb24: bigint
  prim_volume_nb30d: bigint
  prim_volume_tz: bigint
  prim_volume_tz7d: bigint
  prim_volume_tz24: bigint
  prim_volume_tz30d: bigint
  sec_volume_nb: bigint
  sec_volume_nb7d: bigint
  sec_volume_nb24: bigint
  sec_volume_nb30d: bigint
  sec_volume_tz: bigint
  sec_volume_tz7d: bigint
  sec_volume_tz24: bigint
  sec_volume_tz30d: bigint
}

"""
input type for inserting data into table "user_stats"
"""
input user_stats_insert_input {
  from: timestamptz
  prim_volume_nb: bigint
  prim_volume_nb7d: bigint
  prim_volume_nb24: bigint
  prim_volume_nb30d: bigint
  prim_volume_tz: bigint
  prim_volume_tz7d: bigint
  prim_volume_tz24: bigint
  prim_volume_tz30d: bigint
  sec_volume_nb: bigint
  sec_volume_nb7d: bigint
  sec_volume_nb24: bigint
  sec_volume_nb30d: bigint
  sec_volume_tz: bigint
  sec_volume_tz7d: bigint
  sec_volume_tz24: bigint
  sec_volume_tz30d: bigint
  to: timestamptz
  user: user_obj_rel_insert_input
  user_id: String
}

"""aggregate max on columns"""
type user_stats_max_fields {
  from: timestamptz
  prim_volume_nb: bigint
  prim_volume_nb7d: bigint
  prim_volume_nb24: bigint
  prim_volume_nb30d: bigint
  prim_volume_tz: bigint
  prim_volume_tz7d: bigint
  prim_volume_tz24: bigint
  prim_volume_tz30d: bigint
  sec_volume_nb: bigint
  sec_volume_nb7d: bigint
  sec_volume_nb24: bigint
  sec_volume_nb30d: bigint
  sec_volume_tz: bigint
  sec_volume_tz7d: bigint
  sec_volume_tz24: bigint
  sec_volume_tz30d: bigint
  to: timestamptz
  user_id: String
}

"""aggregate min on columns"""
type user_stats_min_fields {
  from: timestamptz
  prim_volume_nb: bigint
  prim_volume_nb7d: bigint
  prim_volume_nb24: bigint
  prim_volume_nb30d: bigint
  prim_volume_tz: bigint
  prim_volume_tz7d: bigint
  prim_volume_tz24: bigint
  prim_volume_tz30d: bigint
  sec_volume_nb: bigint
  sec_volume_nb7d: bigint
  sec_volume_nb24: bigint
  sec_volume_nb30d: bigint
  sec_volume_tz: bigint
  sec_volume_tz7d: bigint
  sec_volume_tz24: bigint
  sec_volume_tz30d: bigint
  to: timestamptz
  user_id: String
}

"""
response of any mutation on the table "user_stats"
"""
type user_stats_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_stats!]!
}

"""
input type for inserting object relation for remote table "user_stats"
"""
input user_stats_obj_rel_insert_input {
  data: user_stats_insert_input!

  """upsert condition"""
  on_conflict: user_stats_on_conflict
}

"""
on_conflict condition type for table "user_stats"
"""
input user_stats_on_conflict {
  constraint: user_stats_constraint!
  update_columns: [user_stats_update_column!]! = []
  where: user_stats_bool_exp
}

"""Ordering options when selecting data from "user_stats"."""
input user_stats_order_by {
  from: order_by
  prim_volume_nb: order_by
  prim_volume_nb7d: order_by
  prim_volume_nb24: order_by
  prim_volume_nb30d: order_by
  prim_volume_tz: order_by
  prim_volume_tz7d: order_by
  prim_volume_tz24: order_by
  prim_volume_tz30d: order_by
  sec_volume_nb: order_by
  sec_volume_nb7d: order_by
  sec_volume_nb24: order_by
  sec_volume_nb30d: order_by
  sec_volume_tz: order_by
  sec_volume_tz7d: order_by
  sec_volume_tz24: order_by
  sec_volume_tz30d: order_by
  to: order_by
  user: user_order_by
  user_id: order_by
}

"""primary key columns input for table: user_stats"""
input user_stats_pk_columns_input {
  user_id: String!
}

"""
select columns of table "user_stats"
"""
enum user_stats_select_column {
  """column name"""
  from

  """column name"""
  prim_volume_nb

  """column name"""
  prim_volume_nb7d

  """column name"""
  prim_volume_nb24

  """column name"""
  prim_volume_nb30d

  """column name"""
  prim_volume_tz

  """column name"""
  prim_volume_tz7d

  """column name"""
  prim_volume_tz24

  """column name"""
  prim_volume_tz30d

  """column name"""
  sec_volume_nb

  """column name"""
  sec_volume_nb7d

  """column name"""
  sec_volume_nb24

  """column name"""
  sec_volume_nb30d

  """column name"""
  sec_volume_tz

  """column name"""
  sec_volume_tz7d

  """column name"""
  sec_volume_tz24

  """column name"""
  sec_volume_tz30d

  """column name"""
  to

  """column name"""
  user_id
}

"""
input type for updating data in table "user_stats"
"""
input user_stats_set_input {
  from: timestamptz
  prim_volume_nb: bigint
  prim_volume_nb7d: bigint
  prim_volume_nb24: bigint
  prim_volume_nb30d: bigint
  prim_volume_tz: bigint
  prim_volume_tz7d: bigint
  prim_volume_tz24: bigint
  prim_volume_tz30d: bigint
  sec_volume_nb: bigint
  sec_volume_nb7d: bigint
  sec_volume_nb24: bigint
  sec_volume_nb30d: bigint
  sec_volume_tz: bigint
  sec_volume_tz7d: bigint
  sec_volume_tz24: bigint
  sec_volume_tz30d: bigint
  to: timestamptz
  user_id: String
}

"""aggregate stddev on columns"""
type user_stats_stddev_fields {
  prim_volume_nb: Float
  prim_volume_nb7d: Float
  prim_volume_nb24: Float
  prim_volume_nb30d: Float
  prim_volume_tz: Float
  prim_volume_tz7d: Float
  prim_volume_tz24: Float
  prim_volume_tz30d: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""aggregate stddev_pop on columns"""
type user_stats_stddev_pop_fields {
  prim_volume_nb: Float
  prim_volume_nb7d: Float
  prim_volume_nb24: Float
  prim_volume_nb30d: Float
  prim_volume_tz: Float
  prim_volume_tz7d: Float
  prim_volume_tz24: Float
  prim_volume_tz30d: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""aggregate stddev_samp on columns"""
type user_stats_stddev_samp_fields {
  prim_volume_nb: Float
  prim_volume_nb7d: Float
  prim_volume_nb24: Float
  prim_volume_nb30d: Float
  prim_volume_tz: Float
  prim_volume_tz7d: Float
  prim_volume_tz24: Float
  prim_volume_tz30d: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""
Streaming cursor of the table "user_stats"
"""
input user_stats_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stats_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stats_stream_cursor_value_input {
  from: timestamptz
  prim_volume_nb: bigint
  prim_volume_nb7d: bigint
  prim_volume_nb24: bigint
  prim_volume_nb30d: bigint
  prim_volume_tz: bigint
  prim_volume_tz7d: bigint
  prim_volume_tz24: bigint
  prim_volume_tz30d: bigint
  sec_volume_nb: bigint
  sec_volume_nb7d: bigint
  sec_volume_nb24: bigint
  sec_volume_nb30d: bigint
  sec_volume_tz: bigint
  sec_volume_tz7d: bigint
  sec_volume_tz24: bigint
  sec_volume_tz30d: bigint
  to: timestamptz
  user_id: String
}

"""aggregate sum on columns"""
type user_stats_sum_fields {
  prim_volume_nb: bigint
  prim_volume_nb7d: bigint
  prim_volume_nb24: bigint
  prim_volume_nb30d: bigint
  prim_volume_tz: bigint
  prim_volume_tz7d: bigint
  prim_volume_tz24: bigint
  prim_volume_tz30d: bigint
  sec_volume_nb: bigint
  sec_volume_nb7d: bigint
  sec_volume_nb24: bigint
  sec_volume_nb30d: bigint
  sec_volume_tz: bigint
  sec_volume_tz7d: bigint
  sec_volume_tz24: bigint
  sec_volume_tz30d: bigint
}

"""
update columns of table "user_stats"
"""
enum user_stats_update_column {
  """column name"""
  from

  """column name"""
  prim_volume_nb

  """column name"""
  prim_volume_nb7d

  """column name"""
  prim_volume_nb24

  """column name"""
  prim_volume_nb30d

  """column name"""
  prim_volume_tz

  """column name"""
  prim_volume_tz7d

  """column name"""
  prim_volume_tz24

  """column name"""
  prim_volume_tz30d

  """column name"""
  sec_volume_nb

  """column name"""
  sec_volume_nb7d

  """column name"""
  sec_volume_nb24

  """column name"""
  sec_volume_nb30d

  """column name"""
  sec_volume_tz

  """column name"""
  sec_volume_tz7d

  """column name"""
  sec_volume_tz24

  """column name"""
  sec_volume_tz30d

  """column name"""
  to

  """column name"""
  user_id
}

input user_stats_updates {
  """increments the numeric columns with given value of the filtered values"""
  _inc: user_stats_inc_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_stats_set_input

  """filter the rows which have to be updated"""
  where: user_stats_bool_exp!
}

"""aggregate var_pop on columns"""
type user_stats_var_pop_fields {
  prim_volume_nb: Float
  prim_volume_nb7d: Float
  prim_volume_nb24: Float
  prim_volume_nb30d: Float
  prim_volume_tz: Float
  prim_volume_tz7d: Float
  prim_volume_tz24: Float
  prim_volume_tz30d: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""aggregate var_samp on columns"""
type user_stats_var_samp_fields {
  prim_volume_nb: Float
  prim_volume_nb7d: Float
  prim_volume_nb24: Float
  prim_volume_nb30d: Float
  prim_volume_tz: Float
  prim_volume_tz7d: Float
  prim_volume_tz24: Float
  prim_volume_tz30d: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""aggregate variance on columns"""
type user_stats_variance_fields {
  prim_volume_nb: Float
  prim_volume_nb7d: Float
  prim_volume_nb24: Float
  prim_volume_nb30d: Float
  prim_volume_tz: Float
  prim_volume_tz7d: Float
  prim_volume_tz24: Float
  prim_volume_tz30d: Float
  sec_volume_nb: Float
  sec_volume_nb7d: Float
  sec_volume_nb24: Float
  sec_volume_nb30d: Float
  sec_volume_tz: Float
  sec_volume_tz7d: Float
  sec_volume_tz24: Float
  sec_volume_tz30d: Float
}

"""
Streaming cursor of the table "user"
"""
input user_stream_cursor_input {
  """Stream column input with initial value"""
  initial_value: user_stream_cursor_value_input!

  """cursor ordering"""
  ordering: cursor_ordering
}

"""Initial value of the column from where the streaming should start"""
input user_stream_cursor_value_input {
  authorizations: _int2
  avatarMediaId: bpchar
  avatar_uri: String
  created_at: timestamptz
  description: String
  flag: user_flag_enum
  id: String
  metadata: jsonb
  metadata_uri: String
  moderation_reason_id: String
  name: String
  type: user_type_enum
  updated_at: timestamptz
}

scalar user_type_enum

"""
Boolean expression to compare columns of type "user_type_enum". All fields are combined with logical 'AND'.
"""
input user_type_enum_comparison_exp {
  _eq: user_type_enum
  _gt: user_type_enum
  _gte: user_type_enum
  _in: [user_type_enum!]
  _is_null: Boolean
  _lt: user_type_enum
  _lte: user_type_enum
  _neq: user_type_enum
  _nin: [user_type_enum!]
}

"""
update columns of table "user"
"""
enum user_update_column {
  """column name"""
  authorizations

  """column name"""
  avatarMediaId

  """column name"""
  avatar_uri

  """column name"""
  created_at

  """column name"""
  description

  """column name"""
  flag

  """column name"""
  id

  """column name"""
  metadata

  """column name"""
  metadata_uri

  """column name"""
  moderation_reason_id

  """column name"""
  name

  """column name"""
  type

  """column name"""
  updated_at
}

input user_updates {
  """append existing jsonb value of filtered columns with new jsonb value"""
  _append: user_append_input

  """
  delete the field or element with specified path (for JSON arrays, negative integers count from the end)
  """
  _delete_at_path: user_delete_at_path_input

  """
  delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
  """
  _delete_elem: user_delete_elem_input

  """
  delete key/value pair or string element. key/value pairs are matched based on their key value
  """
  _delete_key: user_delete_key_input

  """prepend existing jsonb value of filtered columns with new jsonb value"""
  _prepend: user_prepend_input

  """sets the columns of the filtered rows to the given values"""
  _set: user_set_input

  """filter the rows which have to be updated"""
  where: user_bool_exp!
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
{"version":3,"sources":["../src/sdk/math.ts","../../fxhash-params/src/utils.ts","../src/sdk/index.ts","../src/index.ts"],"sourcesContent":["import { ResettableRandFunction } from \"types\"\n\nexport const alphabet =\n  \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n\nfunction b58dec(str: string): number {\n  return [...str].reduce(function (p: number, c: string): number {\n    return (p * alphabet.length + alphabet.indexOf(c)) | 0\n  }, 0)\n}\n\nfunction sfc32(seed: number[]): () => number {\n  let a = seed[0] | 0\n  let b = seed[1] | 0\n  let c = seed[2] | 0\n  let d = seed[3] | 0\n  return function () {\n    a |= 0\n    b |= 0\n    c |= 0\n    d |= 0\n    const t = (((a + b) | 0) + d) | 0\n    d = (d + 1) | 0\n    a = b ^ (b >>> 9)\n    b = (c + (c << 3)) | 0\n    c = (c << 21) | (c >>> 11)\n    c = (c + t) | 0\n    return (t >>> 0) / 4294967296\n  }\n}\n\nfunction matcher(str: string, start: number): number[] {\n  return str\n    .slice(start)\n    .match(new RegExp(\".{\" + ((str.length - start) >> 2) + \"}\", \"g\"))\n    .map(function (substring: string): number {\n      return b58dec(substring)\n    })\n}\n\nexport function getRandomHash(n: number): string {\n  return Array(n)\n    .fill(0)\n    .map(function (_) {\n      return alphabet[(Math.random() * alphabet.length) | 0]\n    })\n    .join(\"\")\n}\n\nexport function createFxRandom(\n  fxhash: string,\n  start: number\n): ResettableRandFunction {\n  return sfc32(matcher(fxhash, start))\n}\n","import {\n  hexString,\n  FxParamDefinition,\n  FxParamProcessor,\n  FxParamProcessors,\n  FxParamTypeMap,\n  FxParamType,\n  FxParamsData,\n  FxParamValue,\n  FxParamTranformType,\n  FxParamTransformationTypeMap,\n  FxParamProcessorTransformer,\n} from \"./types\"\n\nexport function rgbaToHex(r: number, g: number, b: number, a: number): string {\n  const outParts = [\n    r.toString(16),\n    g.toString(16),\n    b.toString(16),\n    Math.round(a * 255)\n      .toString(16)\n      .substring(0, 2),\n  ]\n\n  // Pad single-digit output values\n  outParts.forEach(function (part, i) {\n    if (part.length === 1) {\n      outParts[i] = \"0\" + part\n    }\n  })\n\n  return \"#\" + outParts.join(\"\")\n}\n\nfunction completeHexColor(hexCode: hexString | string): string {\n  let hex = hexCode.replace(\"#\", \"\")\n  if (hex.length === 6) {\n    hex = `${hex}ff`\n  }\n  if (hex.length === 3) {\n    hex = `${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}ff`\n  }\n  return hex\n}\n\nexport function hexToRgba(hexCode: hexString) {\n  const hex = completeHexColor(hexCode)\n\n  const r = parseInt(hex.substring(0, 2), 16)\n  const g = parseInt(hex.substring(2, 4), 16)\n  const b = parseInt(hex.substring(4, 6), 16)\n  const a =\n    Math.round(\n      (parseInt(hex.substring(6, 8), 16) / 255 + Number.EPSILON) * 100\n    ) / 100\n\n  return { r, g, b, a }\n}\n\nconst stringToHex = function (s: string) {\n  let rtn = \"\"\n  for (let i = 0; i < s.length; i++) {\n    rtn += s.charCodeAt(i).toString(16).padStart(4, \"0\")\n  }\n  return rtn\n}\nconst hexToString = function (h: string) {\n  const hx = h.match(/.{1,4}/g) || []\n  let rtn = \"\"\n  for (let i = 0; i < hx.length; i++) {\n    const int = parseInt(hx[i], 16)\n    if (int === 0) break\n    rtn += String.fromCharCode(int)\n  }\n  return rtn\n}\n\nexport const MIN_SAFE_INT64 = BigInt(\"-9223372036854775808\")\nexport const MAX_SAFE_INT64 = BigInt(\"9223372036854775807\")\n\nexport const ParameterProcessors: FxParamProcessors = {\n  number: {\n    serialize: input => {\n      const view = new DataView(new ArrayBuffer(8))\n      view.setFloat64(0, input)\n      return view.getBigUint64(0).toString(16).padStart(16, \"0\")\n    },\n    deserialize: input => {\n      const view = new DataView(new ArrayBuffer(8))\n      for (let i = 0; i < 8; i++) {\n        view.setUint8(i, parseInt(input.substring(i * 2, i * 2 + 2), 16))\n      }\n      return view.getFloat64(0)\n    },\n    bytesLength: () => 8,\n    constrain: (value, definition) => {\n      let min = Number.MIN_SAFE_INTEGER\n      if (typeof definition.options?.min !== \"undefined\")\n        min = Number(definition.options.min)\n      let max = Number.MAX_SAFE_INTEGER\n      if (typeof definition.options?.max !== \"undefined\")\n        max = Number(definition.options.max)\n      max = Math.min(max, Number.MAX_SAFE_INTEGER)\n      min = Math.max(min, Number.MIN_SAFE_INTEGER)\n      const v = Math.min(Math.max(value, min), max)\n      if (definition?.options?.step) {\n        const t = 1.0 / definition?.options?.step\n        return Math.round(v * t) / t\n      }\n      return v\n    },\n    random: definition => {\n      let min = Number.MIN_SAFE_INTEGER\n      if (typeof definition.options?.min !== \"undefined\")\n        min = Number(definition.options.min)\n      let max = Number.MAX_SAFE_INTEGER\n      if (typeof definition.options?.max !== \"undefined\")\n        max = Number(definition.options.max)\n      max = Math.min(max, Number.MAX_SAFE_INTEGER)\n      min = Math.max(min, Number.MIN_SAFE_INTEGER)\n      const v = Math.random() * (max - min) + min\n      if (definition?.options?.step) {\n        const t = 1.0 / definition?.options?.step\n        return Math.round(v * t) / t\n      }\n      return v\n    },\n  },\n  bigint: {\n    serialize: (input: any) => {\n      const view = new DataView(new ArrayBuffer(8))\n      view.setBigInt64(0, BigInt(input))\n      return view.getBigUint64(0).toString(16).padStart(16, \"0\")\n    },\n    deserialize: (input: any) => {\n      const view = new DataView(new ArrayBuffer(8))\n      for (let i = 0; i < 8; i++) {\n        view.setUint8(i, parseInt(input.substring(i * 2, i * 2 + 2), 16))\n      }\n      return view.getBigInt64(0)\n    },\n    bytesLength: () => 8,\n    random: (definition) => {\n      let min = MIN_SAFE_INT64\n      let max = MAX_SAFE_INT64\n      if (typeof definition.options?.min !== \"undefined\")\n        min = BigInt(definition.options.min)\n      if (typeof definition.options?.max !== \"undefined\")\n        max = BigInt(definition.options.max)\n      const range = max - min\n      const bits = range.toString(2).length\n      let random\n      do {\n        random = BigInt(\n          \"0b\" +\n            Array.from(\n              crypto.getRandomValues(new Uint8Array(Math.ceil(bits / 8)))\n            )\n              .map((b) => b.toString(2).padStart(8, \"0\"))\n              .join(\"\")\n        )\n      } while (random > range)\n      return random + min\n    },\n  },\n  boolean: {\n    serialize: (input) => {\n      return typeof input === \"boolean\"\n        ? input\n          ? \"01\"\n          : \"00\"\n        : typeof input === \"string\"\n        ? input === \"true\"\n          ? \"01\"\n          : \"00\"\n        : \"00\"\n    },\n    deserialize: (input) => {\n      return input === \"00\" ? false : true\n    },\n    bytesLength: () => 1,\n    random: () => Math.random() < 0.5,\n  },\n\n  color: {\n    serialize: (input: string) => {\n      return completeHexColor(input)\n    },\n\n    deserialize: (input): hexString => {\n      return input as hexString\n    },\n    bytesLength: () => 4,\n    transform: (input: string) => {\n      const color = completeHexColor(input)\n      const r = parseInt(color.slice(0, 2), 16)\n      const g = parseInt(color.slice(2, 4), 16)\n      const b = parseInt(color.slice(4, 6), 16)\n      const a = parseInt(color.slice(6, 8), 16)\n      return {\n        hex: {\n          rgb: \"#\" + input.slice(0, 6),\n          rgba: \"#\" + input,\n        },\n        obj: {\n          rgb: { r, g, b },\n          rgba: { r, g, b, a },\n        },\n        arr: {\n          rgb: [r, g, b],\n          rgba: [r, g, b, a],\n        },\n      }\n    },\n    constrain: (value) => {\n      const hex = value.replace(\"#\", \"\")\n      return hex.slice(0, 8).padEnd(8, \"f\")\n    },\n    random: () =>\n      `${[...Array(8)]\n        .map(() => Math.floor(Math.random() * 16).toString(16))\n        .join(\"\")}`,\n  },\n\n  string: {\n    serialize: (input, def) => {\n      if (!def.version) {\n        let hex = stringToHex(input.substring(0, 64))\n        hex = hex.padEnd(64 * 4, \"0\")\n        return hex\n      }\n      let max = 64\n      if (typeof def.options?.maxLength !== \"undefined\")\n        max = Number(def.options.maxLength)\n      let hex = stringToHex(input.substring(0, max))\n      hex = hex.padEnd(max * 4, \"0\")\n      return hex\n    },\n    deserialize: (input) => {\n      return hexToString(input)\n    },\n\n    bytesLength: (def) => {\n      if (!def.version) {\n        return 64 * 2\n      }\n      if (typeof def.options?.maxLength !== \"undefined\")\n        return Number(def.options.maxLength) * 2\n      return 64 * 2\n    },\n    random: (definition) => {\n      let min = 0\n      if (typeof definition.options?.minLength !== \"undefined\")\n        min = definition.options.minLength\n      let max = 64\n      if (typeof definition.options?.maxLength !== \"undefined\")\n        max = definition.options.maxLength\n      const length = Math.round(Math.random() * (max - min) + min)\n      return [...Array(length)]\n        .map((i) => (~~(Math.random() * 36)).toString(36))\n        .join(\"\")\n    },\n    constrain: (value, definition) => {\n      let min = 0\n      if (typeof definition.options?.minLength !== \"undefined\")\n        min = definition.options.minLength\n      let max = 64\n      if (typeof definition.options?.maxLength !== \"undefined\")\n        max = definition.options.maxLength\n      const v = value.slice(0, max)\n      if (v.length < min) {\n        return v.padEnd(min)\n      }\n      return v\n    },\n  },\n\n  bytes: {\n    serialize: (input, def) => {\n      return Array.from(input)\n        .map((i) => i.toString(16).padStart(2, \"0\"))\n        .join(\"\")\n    },\n    deserialize: (input, def) => {\n      const len = input.length / 2\n      const uint8 = new Uint8Array(len)\n      let idx\n      for (let i = 0; i < len; i++) {\n        idx = i * 2\n        uint8[i] = parseInt(`${input[idx]}${input[idx + 1]}`, 16)\n      }\n      return uint8\n    },\n    bytesLength: (def) => def.options.length,\n    random: (def) => {\n      const len = def.options?.length || 0\n      const uint8 = new Uint8Array(len)\n      for (let i = 0; i < len; i++) {\n        uint8[i] = (Math.random() * 255) | 0\n      }\n      return uint8\n    },\n  },\n\n  select: {\n    serialize: (input, def) => {\n      // find the index of the input in the array of options\n      return Math.min(255, def.options?.options?.indexOf(input) || 0)\n        .toString(16)\n        .padStart(2, \"0\")\n    },\n\n    deserialize: (input, def) => {\n      // get the index, which is the input\n      const idx = parseInt(input, 16)\n      return def.options?.options?.[idx] || def.options?.options?.[0] || \"\"\n    },\n\n    bytesLength: () => 1, // index between 0 and 255\n    constrain: (value, definition) => {\n      if (definition.options.options.includes(value)) {\n        return value\n      }\n      return definition.options.options[0]\n    },\n    random: (definition) => {\n      const index = Math.round(\n        Math.random() * (definition.options.options.length - 1) + 0\n      )\n      return definition?.options?.options[index]\n    },\n  },\n}\n\n// params are injected into the piece using the binary representation of the\n// numbers, to keep precision\nexport function serializeParams(\n  params: any,\n  definition: FxParamDefinition<any>[]\n) {\n  // a single hex string will be used for all the params\n  let bytes = \"\"\n  if (!definition) return bytes\n  // loop through each parameter from the definition to find the associated\n  // parameter as set on the UI\n  for (const def of definition) {\n    const { id, type } = def\n    const processor = ParameterProcessors[\n      type as FxParamType\n    ] as FxParamProcessor<any>\n    // if the param is definined in the object\n\n    const v = params[id] as FxParamTypeMap[]\n    const val =\n      typeof v !== \"undefined\"\n        ? v\n        : typeof def.default !== \"undefined\"\n        ? def.default\n        : processor.random(def)\n    const serialized = processor.serialize(val, def)\n    bytes += serialized\n  }\n\n  return bytes\n}\n\n// takes an array of bytes, in hexadecimal format, and a parametric space\n// definition and outputs an array of parameters, mapping the definition and\n// validating input based on the definition constraints\nexport function deserializeParams(\n  bytes: string,\n  definition: FxParamDefinition<FxParamType>[],\n  options: { withTransform?: boolean, transformType?: FxParamTranformType }\n) {\n  const params: Record<string, FxParamValue<FxParamType> | FxParamTransformationTypeMap[FxParamType]> = {}\n  for (const def of definition) {\n    const processor = ParameterProcessors[\n      def.type as FxParamType\n    ] as FxParamProcessor<FxParamType>\n    const transformer = options.withTransform && processor[options.transformType || \"transform\"] as FxParamProcessorTransformer<FxParamType>\n    if (!bytes) {\n      let v\n      if (typeof def.default === \"undefined\") v = processor.random(def)\n      else v = def.default\n      params[def.id] = transformer ? transformer(v, def) : v\n      continue\n    }\n    // extract the length from the bytes & shift the initial bytes string\n    const bytesLen = processor.bytesLength(def)\n    const valueBytes = bytes.substring(0, bytesLen * 2)\n    bytes = bytes.substring(bytesLen * 2)\n    // deserialize the bytes into the params\n    const val = processor.deserialize(valueBytes, def) as FxParamValue<FxParamType>\n    params[def.id] = transformer ? transformer(val, def) : val\n  }\n  return params\n}\n\n\n// Consolidates parameters from both a params object provided by the token\n// and the dat object of params, which is stored by the controls component.\nexport function consolidateParams(params: any, data: any) {\n  if (!params) return []\n\n  const rtn = [...params]\n\n  for (const p in rtn) {\n    const definition = rtn[p]\n    const { id, type, default: def } = definition\n    if (data && data.hasOwnProperty(id)) {\n      rtn[p].value = data[id]\n    } else {\n      const processor = ParameterProcessors[\n        type as FxParamType\n      ] as FxParamProcessor<any>\n      let v\n      if (typeof def === \"undefined\") v = processor.random(definition)\n      else v = def\n      rtn[p].value = processor.transform?.(v) || v\n    }\n  }\n\n  return rtn\n}\n\nexport function getRandomParamValues(\n  params: FxParamDefinition<FxParamType>[],\n  options?: { noTransform: boolean }\n): any {\n  return params.reduce((acc, definition) => {\n    const processor = ParameterProcessors[\n      definition.type as FxParamType\n    ] as FxParamProcessor<FxParamType>\n    const v = processor.random(definition) as FxParamType\n    acc[definition.id] = options?.noTransform\n      ? v\n      : processor.transform?.(v) || v\n    return acc\n  }, {} as Record<string, any>)\n}\n\nexport function sumBytesParams(\n  definitions: FxParamDefinition<FxParamType>[]\n): number {\n  return (\n    definitions?.reduce(\n      (acc, def) =>\n        acc +\n        (\n          ParameterProcessors[\n            def.type as FxParamType\n          ] as FxParamProcessor<FxParamType>\n        ).bytesLength(def),\n      0\n    ) || 0\n  )\n}\n\nexport function stringifyParamsData(data: FxParamsData) {\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === \"bigint\") return value.toString()\n    return value\n  })\n}\n\nexport function jsonStringifyBigint(data: any): string {\n  return JSON.stringify(data, (key, value) => {\n    if (typeof value === \"bigint\") return value.toString()\n    return value\n  })\n}\n\n\nexport const processParam = (paramId: string, value: FxParamValue<FxParamType>, definitions: FxParamDefinition<FxParamType>[], transformType: FxParamTranformType): FxParamValue<FxParamType> | FxParamTransformationTypeMap[FxParamType] => {\n    const definition = definitions.find(d => d.id === paramId)\n    const processor = ParameterProcessors[definition.type]\n    const transformer = (processor[transformType] as FxParamProcessorTransformer<FxParamType>)\n    return transformer?.(value, definition) || value\n  }\n\nexport const processParams = (values: FxParamsData, definitions: FxParamDefinition<FxParamType>[], transformType: FxParamTranformType) => {\n    const paramValues = {}\n    for (const definition of definitions) {\n      const processor = ParameterProcessors[definition.type]\n      const value = values[definition.id]\n      // deserialize the bytes into the params\n      const transformer = (processor[transformType] as FxParamProcessorTransformer<FxParamType>)\n      paramValues[definition.id] = transformer?.(value, definition) || value\n\n    }\n    return paramValues\n  }\n\n","import { FxHashApi, FxHashExecutionContext } from \"../types\"\nimport { createFxRandom, getRandomHash } from \"./math\"\nimport {\n  serializeParams,\n  processParams,\n  processParam,\n  deserializeParams,\n  ParameterProcessors,\n} from \"@fxhash/params/utils\"\n\nexport function createFxhashSdk(window, options): FxHashApi {\n  const { parent } = window\n\n  const search = new URLSearchParams(window.location.search)\n  // make fxrandstring from hash\n  const fxhash = search.get(\"fxhash\") || \"oo\" + getRandomHash(49)\n  let fxrand = createFxRandom(fxhash, 2)\n  // make fxrandminter from minter address\n  const fxminter = search.get(\"fxminter\") || \"tz1\" + getRandomHash(33)\n  let fxrandminter = createFxRandom(fxminter, 3)\n  // true if preview mode active, false otherwise\n  // you can append preview=1 to the URL to simulate preview active\n  const isFxpreview = search.get(\"preview\") === \"1\"\n  // call this method to trigger the preview\n  function fxpreview() {\n    window.dispatchEvent(new Event(\"fxhash-preview\"))\n    setTimeout(() => fxpreview(), 500)\n  }\n  // get the byte params from the URL\n  const searchParams = window.location.hash\n  const initialInputBytes = searchParams?.replace(\"#0x\", \"\")\n\n  const $fx = {\n    _version: \"3.3.0\",\n    _processors: ParameterProcessors,\n    // where params def & features will be stored\n    _params: undefined,\n    _features: undefined,\n    // where the parameter values are stored\n    _paramValues: {},\n    _listeners: {},\n    _receiveUpdateParams: async function (newRawValues, onDefault) {\n      const handlers = await this.propagateEvent(\"params:update\", newRawValues)\n      handlers.forEach(([optInDefault, onDone]) => {\n        if (!(typeof optInDefault == \"boolean\" && !optInDefault)) {\n          this._updateParams(newRawValues)\n          onDefault?.()\n        }\n        onDone?.(optInDefault, newRawValues)\n      })\n      if (handlers.length === 0) {\n        this._updateParams(newRawValues)\n        onDefault?.()\n      }\n    },\n    _updateParams: function (newRawValues) {\n      const constrained = processParams(\n        { ...this._rawValues, ...newRawValues },\n        this._params,\n        \"constrain\"\n      )\n      Object.keys(constrained).forEach(paramId => {\n        this._rawValues[paramId] = constrained[paramId]\n      })\n      this._paramValues = processParams(\n        this._rawValues,\n        this._params,\n        \"transform\"\n      )\n      this._updateInputBytes()\n    },\n    _updateInputBytes: function () {\n      const bytes = serializeParams(this._rawValues, this._params)\n      this.inputBytes = bytes\n    },\n    _emitParams: function (newRawValues) {\n      const constrainedValues = Object.keys(newRawValues).reduce(\n        (acc, paramId) => {\n          acc[paramId] = processParam(\n            paramId,\n            newRawValues[paramId],\n            this._params,\n            \"constrain\"\n          )\n          return acc\n        },\n        {}\n      )\n      this._receiveUpdateParams(constrainedValues, () => {\n        parent.postMessage(\n          {\n            id: \"fxhash_emit:params:update\",\n            data: {\n              params: constrainedValues,\n            },\n          },\n          \"*\"\n        )\n      })\n    },\n    hash: fxhash,\n    rand: fxrand,\n    minter: fxminter,\n    randminter: fxrandminter,\n    iteration: Number(search.get(\"fxiteration\")) || 1,\n    context:\n      (search.get(\"fxcontext\") as FxHashExecutionContext) || \"standalone\",\n    preview: fxpreview,\n    isPreview: isFxpreview,\n    params: function (definition) {\n      this._params = definition.map(def => ({ ...def, version: this._version }))\n      this._rawValues = deserializeParams(initialInputBytes, this._params, {\n        withTransform: true,\n        transformType: \"constrain\",\n      })\n      this._paramValues = processParams(\n        this._rawValues,\n        this._params,\n        \"transform\"\n      )\n      this._updateInputBytes()\n    },\n    features: function (features) {\n      this._features = features\n    },\n    getFeature: function (id) {\n      return this._features[id]\n    },\n    getFeatures: function () {\n      return this._features\n    },\n    getParam: function (id) {\n      return this._paramValues[id]\n    },\n    getParams: function () {\n      return this._paramValues\n    },\n    getRawParam: function (id) {\n      return this._rawValues[id]\n    },\n    getRawParams: function () {\n      return this._rawValues\n    },\n    getRandomParam: function (id) {\n      const definition = this._params.find(d => d.id === id)\n      const processor = ParameterProcessors[definition.type]\n      return processor.random(definition)\n    },\n    getDefinitions: function () {\n      return this._params\n    },\n    stringifyParams: function (params) {\n      return JSON.stringify(\n        params || this._rawValues,\n        (key, value) => {\n          if (typeof value === \"bigint\") return value.toString()\n          return value\n        },\n        2\n      )\n    },\n    on: function (name, callback, onDone) {\n      if (!this._listeners[name]) {\n        this._listeners[name] = []\n      }\n      this._listeners[name].push([callback, onDone])\n      return () => {\n        const index = this._listeners[name].findIndex(([c]) => c === callback)\n        if (index > -1) {\n          this._listeners[name].splice(index, 1)\n        }\n      }\n    },\n    propagateEvent: async function (name, data) {\n      const results = []\n      if (this._listeners?.[name]) {\n        for (const [callback, onDone] of this._listeners[name]) {\n          const result = callback(data)\n          results.push([\n            result instanceof Promise ? await result : result,\n            onDone,\n          ])\n        }\n      }\n      return results\n    },\n    emit: function (id, data) {\n      switch (id) {\n        case \"params:update\":\n          this._emitParams(data)\n          break\n        default:\n          console.log(\"$fx.emit called with unknown id:\", id)\n          break\n      }\n    },\n  }\n  const resetFxRand: () => void = () => {\n    fxrand = createFxRandom(fxhash, 2)\n    $fx.rand = fxrand\n    fxrand.reset = resetFxRand\n  }\n  fxrand.reset = resetFxRand\n  const resetFxRandMinter: () => void = () => {\n    fxrandminter = createFxRandom(fxminter, 3)\n    $fx.randminter = fxrandminter\n    fxrandminter.reset = resetFxRandMinter\n  }\n  fxrandminter.reset = resetFxRandMinter\n\n  window.addEventListener(\"message\", event => {\n    if (event.data === \"fxhash_getInfo\") {\n      parent.postMessage(\n        {\n          id: \"fxhash_getInfo\",\n          data: {\n            version: window.$fx._version,\n            hash: window.$fx.hash,\n            iteration: window.$fx.iteration,\n            features: window.$fx.getFeatures(),\n            params: {\n              definitions: window.$fx.getDefinitions(),\n              values: window.$fx.getRawParams(),\n            },\n            minter: window.$fx.minter,\n          },\n        },\n        \"*\"\n      )\n    }\n    if (event.data?.id === \"fxhash_params:update\") {\n      const { params } = event.data.data\n      if (params) window.$fx._receiveUpdateParams(params)\n    }\n  })\n  return $fx\n}\n","import { createFxhashSdk } from \"./sdk/index\"\n\nwindow.$fx = createFxhashSdk(window, {})\n\nexport * from \"./types\"\n"],"mappings":"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","names":["hex","window"]}